<!DOCTYPE html>
<!-- æ³°æ‹‰ç‘äºšModåˆ¶ä½œæ•™ç¨‹æ–‡æ¡£æŸ¥çœ‹å™¨é¡µé¢ -->
<html lang="zh-CN" data-theme="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ–‡æ¡£æŸ¥çœ‹å™¨ - æ³°æ‹‰ç‘äºšModåˆ¶ä½œæ•™ç¨‹</title>

    <!-- SEOä¼˜åŒ–æ ‡ç­¾ï¼ˆå®é™…å€¼ä¼šåœ¨è„šæœ¬ä¸­æ ¹æ® ?file å’Œæ–‡æ¡£å…ƒæ•°æ®æ›´æ–°ï¼‰ -->
    <meta name="description" content="æ³°æ‹‰ç‘äºšModåˆ¶ä½œæ•™ç¨‹æ–‡æ¡£é˜…è¯»é¡µé¢ï¼Œæ”¯æŒç›®å½•ã€ä»£ç é«˜äº®ä¸åˆ†ç±»å¯¼èˆªã€‚">
    <meta name="keywords" content="æ³°æ‹‰ç‘äºš,Mod,æ•™ç¨‹,tModLoader,C#,æ–‡æ¡£">
    <meta name="author" content="æ³°æ‹‰ç‘äºšModç¤¾åŒº">
    <meta name="robots" content="index, follow">

    <!-- Open Graphæ ‡ç­¾ -->
    <meta property="og:title" content="æ–‡æ¡£æŸ¥çœ‹å™¨ - æ³°æ‹‰ç‘äºšModåˆ¶ä½œæ•™ç¨‹">
    <meta property="og:description" content="æ³°æ‹‰ç‘äºšModåˆ¶ä½œæ•™ç¨‹æ–‡æ¡£é˜…è¯»é¡µé¢ï¼Œæ”¯æŒç›®å½•ã€ä»£ç é«˜äº®ä¸åˆ†ç±»å¯¼èˆªã€‚">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://dpapyru.github.io/docs/viewer.html">
    <meta property="og:image" content="https://dpapyru.github.io/assets/imgs/Green_tModLoader.png">
    <meta property="og:site_name" content="æ³°æ‹‰ç‘äºšModåˆ¶ä½œæ•™ç¨‹">
    <meta property="og:locale" content="zh_CN">

    <!-- Twitter Cardæ ‡ç­¾ -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="æ–‡æ¡£æŸ¥çœ‹å™¨ - æ³°æ‹‰ç‘äºšModåˆ¶ä½œæ•™ç¨‹">
    <meta name="twitter:description" content="æ³°æ‹‰ç‘äºšModåˆ¶ä½œæ•™ç¨‹æ–‡æ¡£é˜…è¯»é¡µé¢ï¼Œæ”¯æŒç›®å½•ã€ä»£ç é«˜äº®ä¸åˆ†ç±»å¯¼èˆªã€‚">
    <meta name="twitter:image" content="https://dpapyru.github.io/assets/imgs/Green_tModLoader.png">

    <!-- è§„èŒƒURLï¼ˆå®é™…å€¼ä¼šåœ¨è„šæœ¬ä¸­æ ¹æ® ?file æ›´æ–°ï¼‰ -->
    <link rel="canonical" href="https://dpapyru.github.io/docs/viewer.html">

    <!-- åŠ è½½CSSæ ·å¼æ–‡ä»¶ -->
    <link rel="stylesheet" href="../assets/css/style.css"> <!-- ä¸»æ ·å¼æ–‡ä»¶ -->
    <link rel="stylesheet" href="../assets/css/prism.min.css"> <!-- ä»£ç é«˜äº®æ ·å¼ -->
    <link rel="stylesheet" href="../assets/css/rider-dark-theme.css"> <!-- Rider Darkä»£ç é«˜äº®ä¸»é¢˜ -->
    <link rel="stylesheet" href="../assets/css/knowledge-cards.css"> <!-- æµ®åŠ¨çŸ¥è¯†å¡ç‰Œ -->
    <link rel="icon" type="image/png" href="../assets/imgs/Green_tModLoader.png"> <!-- ç½‘ç«™å›¾æ ‡ -->

    <!-- å…¥ç«™æµ‹è¯„è·³è½¬ï¼ˆé¦–æ¬¡è¿›å…¥å¯è·³è¿‡ï¼‰ -->
    <script src="../assets/js/onboarding-gate.js"></script>

    <!-- ä¸»é¢˜åˆ‡æ¢è„šæœ¬ - æ—©æœŸåŠ è½½ä»¥é¿å…é—ªçƒ -->
    <script src="../assets/js/theme-init.js"></script>
</head>

<body class="viewer-page">
    <a class="skip-link" href="#main-content">è·³åˆ°ä¸»è¦å†…å®¹</a>
    <!-- ç½‘ç«™å¤´éƒ¨å¯¼èˆªåŒºåŸŸ -->
    <header class="site-header">
        <div class="container">
            <!-- å¤´éƒ¨å†…å®¹å®¹å™¨ï¼šåŒ…å«ç½‘ç«™logoã€å¯¼èˆªèœå•å’Œç§»åŠ¨ç«¯èœå•æŒ‰é’® -->
            <div class="header-content">
                <!-- ç½‘ç«™logoå’Œæ ‡é¢˜ -->
                <div class="logo">
                    <a href="../index.html">
                        <img src="../assets/imgs/Green_tModLoader.png" alt="æ³°æ‹‰ç‘äºšModåˆ¶ä½œæ•™ç¨‹" class="logo-image">
                        <h1 class="site-title">æ³°æ‹‰ç‘äºšModåˆ¶ä½œæ•™ç¨‹</h1>
                    </a>
                </div>
                <!-- ä¸»å¯¼èˆªèœå• -->
                <nav class="main-nav" id="main-nav">
                    <ul class="nav-list">
                        <li class="nav-item"><a href="../index.html" class="nav-link">é¦–é¡µ</a></li>
                        <li class="nav-item"><a href="index.html" class="nav-link active" aria-current="page">æ–‡æ¡£</a></li>
                        <li class="nav-item"><a href="../qa.html" class="nav-link">é—®ç­”</a></li>
                        <li class="nav-item"><a href="https://github.com/DPapyru/DPapyru.github.io" class="nav-link"
                                target="_blank" rel="noopener noreferrer">GitHub</a></li>
                    </ul>
                </nav>
                <!-- ç§»åŠ¨ç«¯èœå•åˆ‡æ¢æŒ‰é’® -->
	                <button class="mobile-menu-toggle" type="button" aria-label="åˆ‡æ¢èœå•" aria-controls="main-nav" aria-expanded="false">
	                    <span class="bar"></span>
	                    <span class="bar"></span>
	                    <span class="bar"></span>
	                </button>
	                <!-- æ‰‹æœºç«¯æ–‡æ¡£å¯¼èˆªæŒ‰é’® -->
	                <button class="mobile-nav-toggle" id="mobile-nav-toggle" type="button" aria-label="æ–‡æ¡£å¯¼èˆª" aria-controls="mobile-nav-overlay" aria-expanded="false">
	                    <span class="nav-icon">â˜°</span>
	                    <span class="nav-text">å¯¼èˆª</span>
	                </button>
            </div>
        </div>
    </header>

    <!-- Learn é£æ ¼æç¤ºæ¡ï¼ˆä¸å½±å“é˜…è¯»ï¼‰ -->
    <div class="learn-top-banner" id="learn-top-banner" role="status" aria-live="polite" aria-hidden="true" style="display:none;">
        <div class="container-fluid learn-top-banner-inner">
            <div class="learn-top-banner-left">
                <span class="learn-top-banner-icon" aria-hidden="true">â“˜</span>
                <div class="learn-top-banner-text" id="learn-top-banner-text">ä½ å°šæœªå®Œæˆæµ‹è¯„ã€‚</div>
            </div>
            <button class="learn-top-banner-close" id="learn-top-banner-close" type="button" aria-label="å…³é—­æç¤º">âœ•</button>
        </div>
    </div>

    <!-- ç½‘ç«™ä¸»ä½“å®¹å™¨ï¼šåŒ…å«ä¾§è¾¹æ å’Œä¸»å†…å®¹åŒº -->
    <div class="site-container">
	        <!-- å·¦ä¾§è¾¹æ ï¼šæ–‡æ¡£å¯¼èˆªå’Œç›¸å…³é“¾æ¥ -->
	        <aside class="sidebar">
	            <div class="sidebar-content">
                    <!-- Learn é£æ ¼ï¼šä¾§è¾¹æ å¿«é€ŸæŸ¥æ‰¾ -->
                    <div class="learn-sidebar-search" role="search">
                        <input class="learn-sidebar-search-input" id="sidebar-quick-search" type="search" placeholder="æŒ‰æ ‡é¢˜æŸ¥æ‰¾" aria-label="æŒ‰æ ‡é¢˜æŸ¥æ‰¾" autocomplete="off">
                    </div>
	                <!-- ä¾§è¾¹æ ç¬¬ä¸€éƒ¨åˆ†ï¼šæ–‡æ¡£å¯¼èˆª -->
	                <div class="sidebar-section">
	                    <h3 class="sidebar-title">æ–‡æ¡£å¯¼èˆª</h3>
	                    <ul class="sidebar-list" id="category-sidebar">
	                        <!-- åˆ†ç±»ä¾§è¾¹æ å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
                    </ul>
                </div>
		                <!-- ä¾§è¾¹æ ç¬¬äºŒéƒ¨åˆ†ï¼šå½“å‰åˆ†ç±»æ–‡æ¡£ -->
		                <div class="sidebar-section">
		                    <h3 class="sidebar-title" id="current-category-title">å½“å‰åˆ†ç±»</h3>
		                    <ul class="sidebar-list" id="current-category-docs">
		                        <!-- å½“å‰åˆ†ç±»çš„æ–‡æ¡£åˆ—è¡¨å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
		                    </ul>
		                </div>
		                <!-- ä¾§è¾¹æ ç¬¬ä¸‰éƒ¨åˆ†ï¼šè´¡çŒ®è€…ä¿¡æ¯ -->
		                <div class="sidebar-section">
		                    <h3 class="sidebar-title">è´¡çŒ®è€…</h3>
		                    <div class="contributors">
		                        <p>æ¬¢è¿å‚ä¸è´¡çŒ®ï¼</p>
                        <a href="viewer.html?file=æ€ä¹ˆè´¡çŒ®/æ•™å­¦æ–‡ç« å†™ä½œæŒ‡å—.md" class="btn btn-small">å¦‚ä½•è´¡çŒ®</a>
                    </div>
                </div>
            </div>
        </aside>

        <!-- ä¸»å†…å®¹åŒºåŸŸï¼šæ˜¾ç¤ºMarkdownæ–‡æ¡£å†…å®¹ -->
        <main class="main-content" id="main-content" tabindex="-1">
            <div class="content-wrapper">
                <!-- æ•™ç¨‹å¤´éƒ¨åŒºåŸŸï¼šåŒ…å«é¢åŒ…å±‘å¯¼èˆªå’Œæ–‡æ¡£å…ƒä¿¡æ¯ -->
                <div class="tutorial-header">
                    <!-- é¢åŒ…å±‘å¯¼èˆª -->
                    <div class="tutorial-topbar">
                        <div class="breadcrumb">
                            <a href="../index.html">é¦–é¡µ</a> &gt;
                            <a href="index.html">æ–‡æ¡£</a> &gt;
                            <span class="current" id="current-doc-name">æ–‡æ¡£</span>
	                        </div>
	                        <div class="tutorial-actions" aria-label="é˜…è¯»å·¥å…·">
	                            <button class="btn btn-small btn-outline" id="focus-mode-toggle" type="button" aria-pressed="false">ç„¦ç‚¹æ¨¡å¼</button>
	                            <button class="btn btn-small btn-outline" id="learning-settings-toggle" type="button" aria-haspopup="dialog" aria-controls="learning-settings-overlay" aria-expanded="false">åˆ†æµè®¾ç½®</button>
	                            <button class="btn btn-small btn-outline" id="author-mode-toggle" type="button" aria-pressed="false">ä½œè€…æ¨¡å¼</button>
	                        </div>
	                    </div>
                    <!-- æ–‡æ¡£æ ‡é¢˜ -->
                    <h1 class="tutorial-title" id="doc-title">æ–‡æ¡£</h1>
                    <!-- æ–‡æ¡£å…ƒä¿¡æ¯ï¼šéš¾åº¦ã€æ—¶é—´ã€ä½œè€…ã€æ›´æ–°æ—¥æœŸ -->
                    <div class="tutorial-meta" id="doc-meta">
                        <span class="difficulty">éš¾åº¦: <span class="difficulty-badge" id="doc-difficulty">æœªçŸ¥</span></span>
                        <span class="time">é¢„è®¡æ—¶é—´: <span id="doc-time">æœªçŸ¥</span></span>
                        <span class="author">ä½œè€…: <span id="doc-author">æœªçŸ¥</span></span>
                        <span class="date">æ›´æ–°æ—¥æœŸ: <span id="doc-date">æœªçŸ¥</span></span>
                    </div>
                    <!-- å­¦ä¹ åå¥½/é—¨æ§›æç¤ºï¼ˆä¸æ‹¦æˆªé˜…è¯»ï¼‰ -->
                    <div class="learning-hints" id="learning-hints" aria-live="polite">
                        <div id="learning-hint-recommendation"></div>
                        <div id="learning-hint-prefs"></div>
                        <div id="learning-hint-author"></div>
                    </div>
                </div>

                <!-- æ•™ç¨‹å†…å®¹åŒºåŸŸï¼šåŠ è½½å’Œæ˜¾ç¤ºMarkdownå†…å®¹ -->
                <div class="tutorial-content">
                    <!-- åŠ è½½çŠ¶æ€æŒ‡ç¤ºå™¨ï¼šæ˜¾ç¤ºå†…å®¹åŠ è½½ä¸­çš„æç¤º -->
                    <div id="loading-indicator" class="loading-indicator" role="status" aria-live="polite" aria-busy="true">
                        <div class="loading-spinner"></div>
                        <p>æ­£åœ¨åŠ è½½å†…å®¹...</p>
                    </div>

                    <!-- é”™è¯¯ä¿¡æ¯å®¹å™¨ï¼šå½“å†…å®¹åŠ è½½å¤±è´¥æ—¶æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯ -->
                    <div id="error-message" class="error-message" style="display: none;" role="alert" aria-live="assertive" aria-hidden="true">
                        <h3>åŠ è½½å¤±è´¥</h3>
                        <p id="error-text">æ— æ³•åŠ è½½æ–‡æ¡£å†…å®¹ï¼Œè¯·ç¨åå†è¯•ã€‚</p>
                    </div>

                    <!-- ç›®å½•å®¹å™¨ï¼šè‡ªåŠ¨ç”Ÿæˆçš„æ–‡æ¡£ç›®å½• -->
                    <nav id="table-of-contents" class="table-of-contents" style="display: none;" aria-label="ç›®å½•">
                        <h3>æœ¬æ–‡å†…å®¹</h3>
                        <ul id="toc-list"></ul>
                    </nav>

		                    <!-- Markdownå†…å®¹å®¹å™¨ï¼šæ¸²æŸ“åçš„HTMLå†…å®¹å°†æ’å…¥è¿™é‡Œ -->
		                    <div id="markdown-content" class="markdown-content" style="display: none;">
		                        <!-- æ–‡æ¡£å†…å®¹å°†é€šè¿‡Markdownæ¸²æŸ“åæ’å…¥è¿™é‡Œ -->
		                    </div>
		                </div>

		                <!-- ä½œè€…æ¨¡å¼è¯Šæ–­ï¼ˆä»…ä½œè€…/è´¡çŒ®è€…å¯ç”¨ï¼Œä¸å½±å“è¯»è€…ï¼‰ -->
		                <section class="learning-author-diagnostics" id="learning-author-diagnostics" aria-label="ä½œè€…æ¨¡å¼è¯Šæ–­" style="display:none;">
		                    <div class="learning-author-diagnostics-header">
		                        <h3 class="learning-author-diagnostics-title">ä½œè€…æ¨¡å¼è¯Šæ–­</h3>
		                        <button type="button" class="btn btn-small btn-outline" id="author-mode-disable">å…³é—­ä½œè€…æ¨¡å¼</button>
		                    </div>
		                    <div class="learning-author-panel" id="learning-author-panel"></div>
		                </section>
	
		                <!-- è¯„è®ºåŒºï¼ˆGiscusï¼‰ -->
		                <section class="comments-section" id="comments" aria-label="è¯„è®ºåŒº">
		                    <h3 class="comments-title">è¯„è®º</h3>
		                    <div id="giscus-container" class="giscus-container">
	                        <p class="comments-placeholder">è¯„è®ºåŒºåŠ è½½ä¸­â€¦</p>
	                    </div>
	                </section>
	
	                <!-- æ•™ç¨‹åº•éƒ¨åŒºåŸŸï¼šå¯¼èˆªé“¾æ¥å’Œåé¦ˆè¡¨å• -->
	                <div class="tutorial-footer">
	                    <!-- æ•™ç¨‹å¯¼èˆªï¼šä¸Šä¸€ç¯‡/ä¸‹ä¸€ç¯‡é“¾æ¥ -->
	                    <div class="tutorial-navigation">
                        <a href="index.html" class="btn btn-outline prev-tutorial">â† è¿”å›æ–‡æ¡£åˆ—è¡¨</a>
	                        <a href="?file=Modderå…¥é—¨/DPapyru-ä»è¿™é‡Œå¼€å§‹.md" class="btn btn-secondary">æŸ¥çœ‹æ•™ç¨‹</a>
                        <a href="?file=æ€ä¹ˆè´¡çŒ®/æ•™å­¦æ–‡ç« å†™ä½œæŒ‡å—.md" class="btn btn-primary next-tutorial">è´¡çŒ®æŒ‡å— â†’</a>
                    </div>
                    <!-- æ•™ç¨‹åé¦ˆï¼šç”¨æˆ·åé¦ˆå’Œé—®é¢˜æäº¤ -->
                    <div class="tutorial-feedback">
                        <h3>æ•™ç¨‹åé¦ˆ</h3>
                        <p>å¦‚æœä½ å¯¹æœ¬æ•™ç¨‹æœ‰ä»»ä½•é—®é¢˜æˆ–å»ºè®®ï¼Œæ¬¢è¿åœ¨GitHubä¸Šæå‡ºIssueæˆ–PRã€‚</p>
                        <a href="https://github.com/DPapyru/DPapyru.github.io/issues" class="btn btn-small"
                            target="_blank" rel="noopener noreferrer">æä¾›åé¦ˆ</a>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- ç½‘ç«™åº•éƒ¨åŒºåŸŸ -->
    <footer class="site-footer">
        <div class="container">
            <!-- åº•éƒ¨å†…å®¹å®¹å™¨ -->
            <div class="footer-content">
                <!-- åº•éƒ¨ç¬¬ä¸€æ ï¼šå…³äºé¡¹ç›® -->
                <div class="footer-section">
                    <h4>å…³äºé¡¹ç›®</h4>
                    <p>è¿™æ˜¯ä¸€ä¸ªé¢å‘æ³°æ‹‰ç‘äºšModå¼€å‘è€…çš„åä½œæ•™ç¨‹é¡¹ç›®ï¼Œæ—¨åœ¨é™ä½Modåˆ¶ä½œé—¨æ§›ã€‚</p>
                </div>
                <!-- åº•éƒ¨ç¬¬äºŒæ ï¼šå¿«é€Ÿé“¾æ¥ -->
                <div class="footer-section">
                    <h4>å¿«é€Ÿé“¾æ¥</h4>
                    <ul>
                        <li><a href="../index.html">é¦–é¡µ</a></li>
                        <li><a href="index.html">æ–‡æ¡£</a></li>
                        <li><a href="https://github.com/DPapyru/DPapyru.github.io" target="_blank" rel="noopener noreferrer">GitHub</a></li>
                    </ul>
                </div>
                <!-- åº•éƒ¨ç¬¬ä¸‰æ ï¼šè”ç³»æˆ‘ä»¬ -->
                <div class="footer-section">
                    <h4>è”ç³»æˆ‘ä»¬</h4>
                    <ul>
                        <li><a href="https://github.com/DPapyru/DPapyru.github.io" target="_blank" rel="noopener noreferrer">GitHub</a></li>
                        <li><a href="mailto:contact@example.com">é‚®ç®±</a></li>
                    </ul>
                </div>
            </div>
            <!-- åº•éƒ¨ç‰ˆæƒä¿¡æ¯ -->
            <div class="footer-bottom">
                <p>&copy; 2023 æ³°æ‹‰ç‘äºšModåˆ¶ä½œæ•™ç¨‹. é‡‡ç”¨ <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener noreferrer">CC
                        BY 4.0</a> è®¸å¯åè®®ã€‚</p>
            </div>
        </div>
    </footer>

	    <!-- æ‰‹æœºç«¯å¯¼èˆªè¦†ç›–å±‚ -->
	    <div class="mobile-nav-overlay" id="mobile-nav-overlay" role="dialog" aria-modal="true" aria-label="æ–‡æ¡£å¯¼èˆª" aria-hidden="true">
        <!-- å¯¼èˆªåŒºåŸŸ (å å±å¹•2/3) -->
        <div class="mobile-nav-content">
            <div class="mobile-nav-header">
                <h3>æ–‡æ¡£å¯¼èˆª</h3>
                <button class="mobile-nav-close" id="mobile-nav-close" type="button" aria-label="å…³é—­å¯¼èˆª">âœ•</button>
            </div>
            <div class="mobile-nav-body">
                <!-- å¯¼èˆªå†…å®¹å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                <div class="mobile-nav-sections" id="mobile-nav-sections">
                    <!-- åˆ†ç±»å¯¼èˆªå°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>
        </div>
        <!-- åŠé€æ˜è¿”å›åŒºåŸŸ (å å±å¹•1/3) -->
	        <button class="mobile-nav-back" id="mobile-nav-back" type="button" aria-label="è¿”å›æ–‡ç« ">
	            <div class="mobile-nav-back-hint">
	                <p>ç‚¹å‡»æ­¤å¤„è¿”å›æ–‡ç« </p>
	                <div class="back-arrow">â†‘</div>
	            </div>
	        </button>
	    </div>

	    <!-- Learn é£æ ¼ï¼šåˆ†æµè®¾ç½®å¼¹å±‚ï¼ˆä»ä¾§è¾¹æ ç§»å‡ºï¼‰ -->
	    <div class="learn-modal-overlay" id="learning-settings-overlay" role="dialog" aria-modal="true" aria-label="åˆ†æµè®¾ç½®" aria-hidden="true" style="display:none;">
	        <div class="learn-modal" role="document">
	            <div class="learn-modal-header">
	                <div class="learn-modal-title">åˆ†æµè®¾ç½®</div>
	                <button class="learn-modal-close" id="learning-settings-close" type="button" aria-label="å…³é—­">âœ•</button>
	            </div>
	            <div class="learn-modal-body">
	                <div class="learning-sidebar-panel" id="learning-sidebar-panel">
	                    <!-- å°†é€šè¿‡ JavaScript åŠ¨æ€ç”Ÿæˆ -->
	                </div>
	            </div>
	        </div>
	    </div>

		    <!-- åŠ è½½JavaScriptæ–‡ä»¶ -->
			    <script src="../assets/js/site-config.js"></script>
			    <script src="../assets/js/marked.min.js"></script> <!-- Markdownè§£æåº“ -->
			    <script src="../assets/js/mermaid.min.js"></script> <!-- Mermaidæµç¨‹å›¾æ¸²æŸ“ -->
			    <script src="../assets/js/site-quiz.js"></script> <!-- Quiz é¢˜ç›®æ¸²æŸ“ -->
			    <script src="../assets/js/prism.min.js"></script> <!-- ä»£ç é«˜äº®åº“ -->
			    <script src="../assets/js/prism-csharp.min.js"></script> <!-- C#è¯­è¨€é«˜äº®æ”¯æŒ -->
                <script src="../assets/js/knowledge-core.js"></script> <!-- çŸ¥è¯†å¡ç‰Œï¼šæ ¸å¿ƒé€»è¾‘ -->
                <script src="../assets/js/knowledge-cards.js"></script> <!-- çŸ¥è¯†å¡ç‰Œï¼šUI -->
    <script>
        // Mermaid å…œåº•åŠ è½½ï¼šå¦‚æœæœ¬åœ°èµ„æºç¼ºå¤±/åŠ è½½å¤±è´¥ï¼Œåˆ™å°è¯•ä» CDN åŠ è½½ï¼ˆä¸å½±å“å·²æœ‰æœ¬åœ°åŠ è½½ï¼‰
        (function ensureMermaidLoaded() {
            if (window.mermaid) {
                window.__MERMAID_LOADED = true;
                window.__MERMAID_LOAD_PROMISE = Promise.resolve(true);
                return;
            }

            if (window.__MERMAID_LOAD_PROMISE) return;

            const cdnUrl = 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js';
            window.__MERMAID_LOAD_PROMISE = new Promise((resolve) => {
                const script = document.createElement('script');
                script.src = cdnUrl;
                script.async = true;
                script.referrerPolicy = 'no-referrer';
                script.onload = () => {
                    window.__MERMAID_LOADED = true;
                    console.log('Mermaid å·²ä» CDN åŠ è½½');
                    resolve(true);
                };
                script.onerror = () => {
                    console.warn('Mermaid CDN åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ assets/js/mermaid.min.js æ˜¯å¦å­˜åœ¨');
                    resolve(false);
                };
                document.head.appendChild(script);
            });
        })();
    </script>
    <script>
        // è®¾ç½®ä¸€ä¸ªæ ‡å¿—ï¼Œå‘Šè¯‰main.jsè¿™æ˜¯viewer.htmlé¡µé¢ï¼Œä¸è¦æ‰§è¡Œè‡ªåŠ¨åŠ è½½
        window.IS_VIEWER_PAGE = true;

        // ç¦ç”¨main.jsä¸­çš„è·¯ç”±ç³»ç»Ÿï¼Œé¿å…å¹²æ‰°viewer.htmlçš„æ–‡ä»¶åŠ è½½
        window.DISABLE_ROUTER = true;
    </script>
	    <script src="../assets/js/main.js"></script> <!-- ä¸»è¦åŠŸèƒ½è„šæœ¬ -->
	    <script src="../assets/js/navigation.js"></script> <!-- å¯¼èˆªåŠŸèƒ½è„šæœ¬ -->
	    <script src="../assets/js/giscus-docs.js"></script> <!-- æ–‡æ¡£è¯„è®ºï¼ˆGiscusï¼‰ -->
	
	    <script>
        // æ–‡æ¡£é…ç½®å’Œå…ƒæ•°æ®ç®¡ç†
        let VIEWER_DOC_CONFIG = null;
        let ALL_DOCS = [];
	        let CURRENT_DOC_PATH = null;
	        let DOC_LOOKUP_MAP = null;
	        
	        function initializeMermaidOnce() {
	            if (window.__MERMAID_INITIALIZED) return;
	            if (!window.mermaid || typeof window.mermaid.initialize !== 'function') return;
		            window.mermaid.initialize({
		                startOnLoad: false,
		                theme: 'dark',
		                securityLevel: 'strict',
		                flowchart: {
		                    htmlLabels: true,
		                    // Mermaid ä¼šä¸ºç®­å¤´é¢„ç•™ä¸€ç‚¹é•¿åº¦ï¼Œå­å›¾æ ‡é¢˜åŒºåŸŸå¤ªç´§æ—¶ç®­å¤´ä¼šâ€œæˆ³è¿›æ ‡é¢˜é‡Œâ€
		                    titleTopMargin: 36
		                }
		            });
		            window.__MERMAID_INITIALIZED = true;
		        }

	        function autoWrapMermaidFlowchartSource(source, maxCharsPerLine = 16) {
	            const text = String(source || '');
	            const lines = text.split('\n');
	            const firstNonEmpty = lines.find(line => String(line).trim()) || '';
	            const diagramType = String(firstNonEmpty).trim().split(/\s+/)[0] || '';

	            // ä»…å¯¹ flowchart/graph åšè‡ªåŠ¨æ¢è¡Œï¼Œé¿å…è¯¯ä¼¤ sequenceDiagram ç­‰å…¶å®ƒè¯­æ³•
	            if (diagramType !== 'flowchart' && diagramType !== 'graph') return text;

	            function isBreakChar(ch) {
	                return (
	                    ch === ' ' ||
	                    ch === 'ã€€' ||
	                    ch === '/' ||
	                    ch === 'ï¼' ||
	                    ch === '|' ||
	                    ch === 'ï¼š' ||
	                    ch === ':' ||
	                    ch === 'ï¼Œ' ||
	                    ch === ',' ||
	                    ch === 'ã€' ||
	                    ch === ';' ||
	                    ch === 'ï¼›' ||
	                    ch === '-' ||
	                    ch === 'â€”'
	                );
	            }

	            function trimStartSpaces(chars) {
	                while (chars.length > 0 && (chars[0] === ' ' || chars[0] === 'ã€€')) chars.shift();
	                return chars;
	            }

	            function trimEndSpaces(chars) {
	                while (chars.length > 0 && (chars[chars.length - 1] === ' ' || chars[chars.length - 1] === 'ã€€')) chars.pop();
	                return chars;
	            }

	            function findLastBreakIndex(chars) {
	                for (let i = chars.length - 1; i >= 0; i--) {
	                    if (isBreakChar(chars[i])) return i + 1; // åœ¨è¯¥å­—ç¬¦åæ–­è¡Œ
	                }
	                return -1;
	            }

	            function wrapLabel(label) {
	                const raw = String(label || '');
	                if (!raw) return raw;
	                if (raw.includes('<br') || raw.includes('\\n')) return raw;

	                const chars = Array.from(raw);
	                const out = [];
	                let line = [];
	                let lastBreakIndex = -1;

	                for (let i = 0; i < chars.length; i++) {
	                    const ch = chars[i];
	                    line.push(ch);
	                    if (isBreakChar(ch)) lastBreakIndex = line.length;

	                    const isLast = i === chars.length - 1;
	                    if (!isLast && line.length >= maxCharsPerLine) {
	                        const cut = lastBreakIndex > 0 ? lastBreakIndex : line.length;
	                        const before = trimEndSpaces(line.slice(0, cut)).join('');
	                        out.push(before);
	                        out.push('<br/>');

	                        line = trimStartSpaces(line.slice(cut));
	                        lastBreakIndex = findLastBreakIndex(line);
	                    }
	                }

	                if (line.length > 0) out.push(line.join(''));
	                return out.join('');
	            }

	            function wrapSquareBracketLabels(line) {
	                let cursor = 0;
	                let output = '';
	                while (cursor < line.length) {
	                    const open = line.indexOf('[', cursor);
	                    if (open === -1) {
	                        output += line.slice(cursor);
	                        break;
	                    }
	                    const close = line.indexOf(']', open + 1);
	                    if (close === -1) {
	                        output += line.slice(cursor);
	                        break;
	                    }

	                    const label = line.slice(open + 1, close);
	                    output += line.slice(cursor, open + 1);
	                    output += wrapLabel(label);
	                    output += ']';
	                    cursor = close + 1;
	                }
	                return output;
	            }

		            return lines.map(wrapSquareBracketLabels).join('\n');
		        }

		        function postProcessMermaidSvg(container) {
		            if (!container) return;
		            const svg = container.querySelector('svg');
		            if (!svg) return;

		            try {
		                // 1) ä¿®å¤ç»˜åˆ¶å±‚çº§ï¼šç¡®ä¿èŠ‚ç‚¹å±‚æ°¸è¿œåœ¨è¿çº¿å±‚ä¸Šæ–¹ï¼Œé¿å…è¿çº¿â€œç©¿è¿‡â€èŠ‚ç‚¹çš„è§†è§‰é—®é¢˜
		                const root = svg.querySelector('g.root');
		                if (root) {
		                    const edgePaths = root.querySelector(':scope > g.edgePaths');
		                    const edgeLabels = root.querySelector(':scope > g.edgeLabels');
		                    const nodes = root.querySelector(':scope > g.nodes');
		                    if (edgePaths) root.appendChild(edgePaths);
		                    if (edgeLabels) root.appendChild(edgeLabels);
		                    if (nodes) root.appendChild(nodes);
		                }

		                // 2) é˜²å¾¡æ€§ä¿®å¤ï¼šæŸäº›é…ç½®/æµè§ˆå™¨ä¸‹èŠ‚ç‚¹å¡«å……å¯èƒ½å˜æˆé€æ˜ï¼Œå¯¼è‡´åº•ä¸‹çš„è¿çº¿å¯è§
		                const shapes = svg.querySelectorAll(
		                    '.node rect, .node polygon, .node ellipse, .node circle, .node path,' +
		                    '.rough-node rect, .rough-node polygon, .rough-node ellipse, .rough-node circle, .rough-node path'
		                );

		                shapes.forEach((shape) => {
		                    if (!shape || !window.getComputedStyle) return;
		                    const computed = window.getComputedStyle(shape);
		                    const fill = String(computed.fill || '').trim();
		                    const fillOpacity = String(computed.fillOpacity || '').trim();

		                    const opacityNumber = parseFloat(fillOpacity);
		                    const isTransparentFill =
		                        !fill ||
		                        fill === 'none' ||
		                        fill === 'transparent' ||
		                        /rgba\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*0\s*\)/.test(fill) ||
		                        (!Number.isNaN(opacityNumber) && opacityNumber === 0);

		                    if (!isTransparentFill) return;
		                    shape.style.fill = 'var(--bg-color)';
		                    shape.style.fillOpacity = '1';
		                });
		            } catch (error) {
		                console.warn('Mermaid SVG åå¤„ç†å¤±è´¥:', error);
		            }
		        }

		        async function renderMermaidFlowcharts(root) {
		            try {
		                if (!root) return;
		                const nodes = root.querySelectorAll('.flowchart.mermaid');
	                if (!nodes || nodes.length === 0) return;
	                if (!window.mermaid) {
	                    if (window.__MERMAID_LOAD_PROMISE) {
	                        await window.__MERMAID_LOAD_PROMISE;
	                    }
	                    if (!window.mermaid) {
	                        console.warn('Mermaid æœªåŠ è½½ï¼Œè·³è¿‡æµç¨‹å›¾æ¸²æŸ“');
	                        return;
	                    }
	                }

	                initializeMermaidOnce();

	                // è‡ªåŠ¨æ¢è¡Œï¼šåœ¨ Mermaid å¸ƒå±€è®¡ç®—ä¹‹å‰æ”¹å†™ sourceï¼Œé¿å…é•¿ä¸­æ–‡æ–‡æœ¬è¢«è£åˆ‡
	                nodes.forEach((node) => {
	                    if (!node || node.getAttribute('data-processed') === 'true') return;
	                    const original = node.textContent || '';
	                    const updated = autoWrapMermaidFlowchartSource(original, 16);
	                    if (updated !== original) node.textContent = updated;
	                });

	                if (document.fonts && document.fonts.ready && typeof document.fonts.ready.then === 'function') {
	                    await document.fonts.ready;
	                }

		                if (typeof window.mermaid.run === 'function') {
		                    await window.mermaid.run({ nodes });
		                } else if (typeof window.mermaid.init === 'function') {
		                    window.mermaid.init(undefined, nodes);
		                }

		                nodes.forEach((node) => postProcessMermaidSvg(node));
		            } catch (error) {
		                console.warn('æµç¨‹å›¾æ¸²æŸ“å¤±è´¥:', error);
		            }
		        }

        // ä¸»åˆ†ç±»é…ç½® - å°†ä»é…ç½®æ–‡ä»¶åŠ¨æ€åŠ è½½
        let MAIN_CATEGORIES = {};
        
        // ä¸»é¢˜é¢†åŸŸé…ç½® - å°†ä»é…ç½®æ–‡ä»¶åŠ¨æ€åŠ è½½
        let TOPIC_AREAS = {};
        
        // è·¯å¾„é‡å®šå‘æ˜ å°„ - å°†ä»é…ç½®æ–‡ä»¶åŠ¨æ€åŠ è½½
        let VIEWER_PATH_REDIRECTS = {};

        // æ–‡æ¡£æŸ¥çœ‹å™¨çš„ä¸»è¦JavaScripté€»è¾‘
			        document.addEventListener('DOMContentLoaded', function () {
			            console.log('=== docs/viewer.html: é¡µé¢åŠ è½½å®Œæˆ ===');
			            console.log('=== è¯Šæ–­ä¿¡æ¯ ===');
			            console.log('å½“å‰é¡µé¢URL:', window.location.href);
			            console.log('å½“å‰é¡µé¢è·¯å¾„:', window.location.pathname);
			            console.log('å½“å‰æœç´¢å‚æ•°:', window.location.search);

	                    // Learn é£æ ¼ï¼šç„¦ç‚¹æ¨¡å¼ä¸ä¾§è¾¹æ å¿«é€ŸæŸ¥æ‰¾
	                    initializeViewerFocusMode();
	                    initializeSidebarQuickSearch();
	                    initializeLearningSettingsUi();
		
			            // ä½œè€…æ¨¡å¼ï¼šæ”¯æŒ ?author=1/0ï¼Œå¹¶æŒä¹…åŒ–åˆ° localStorage
			            initializeLearningAuthorModeFromUrl();

	            // åˆå§‹åŒ–MDæ¸²æŸ“å™¨ï¼ˆä¼˜å…ˆï¼Œé¿å…å…¶å®ƒåˆå§‹åŒ–å¼‚å¸¸å¯¼è‡´ Markdown æ— æ³•æ¸²æŸ“ï¼‰
	            initializeMarkedRender();

	            // åˆå§‹åŒ–ä¾§è¾¹æ æ»šåŠ¨åŠŸèƒ½
	            initializeSidebarScrolling();

            // åˆå§‹åŒ–æ–‡æ¡£é…ç½®
            initializeDocumentConfig().then(() => {
                // åˆå§‹åŒ–åˆ†ç±»å¯¼èˆª
                initializeCategoryNavigation();

                // ä»URLå‚æ•°è·å–è¦åŠ è½½çš„Markdownæ–‡ä»¶
                const urlParams = new URLSearchParams(window.location.search);
                let markdownFile = urlParams.get('file');
                console.log('ä»URLå‚æ•°è·å–çš„æ–‡ä»¶å:', markdownFile);

                // å¦‚æœæ²¡æœ‰æŒ‡å®šæ–‡ä»¶ï¼Œå°è¯•ä»è·¯å¾„ä¸­è·å–
                if (!markdownFile) {
                    const pathParts = window.location.pathname.split('/');
                    markdownFile = pathParts[pathParts.length - 1];
                    console.log('ä»è·¯å¾„è·å–çš„æ–‡ä»¶å:', markdownFile);
                }

                // å¦‚æœè¿˜æ˜¯æ²¡æœ‰ï¼Œé»˜è®¤åŠ è½½ç¬¬ä¸€ä¸ªå¯ç”¨çš„æ–‡æ¡£
                if (!markdownFile || !markdownFile.endsWith('.md')) {
                    // å°è¯•ä»é…ç½®ä¸­è·å–ç¬¬ä¸€ä¸ªæ–‡æ¡£
                    if (ALL_DOCS && ALL_DOCS.length > 0) {
                        markdownFile = ALL_DOCS[0].filename || ALL_DOCS[0].path;
                        console.log('ä½¿ç”¨é…ç½®ä¸­çš„ç¬¬ä¸€ä¸ªæ–‡æ¡£:', markdownFile);
	                    } else {
	                        // å¦‚æœæ²¡æœ‰é…ç½®ï¼Œä½¿ç”¨å·²çŸ¥çš„æ–‡æ¡£
	                        markdownFile = 'Modderå…¥é—¨/DPapyru-ä»è¿™é‡Œå¼€å§‹.md';
	                        console.log('ä½¿ç”¨é»˜è®¤æ–‡æ¡£:', markdownFile);
	                    }
	                }

                console.log(`docs/viewer.html: å‡†å¤‡åŠ è½½Markdownæ–‡ä»¶: ${markdownFile}`);

                // å»¶è¿ŸåŠ è½½ï¼Œç¡®ä¿æ‰€æœ‰è„šæœ¬éƒ½å·²åˆå§‹åŒ–
                setTimeout(function () {
                    // ç›´æ¥ä½¿ç”¨æœ¬åœ°åŠ è½½å‡½æ•°ï¼Œé¿å…main.jsä¸­çš„è·¯å¾„å¤„ç†é—®é¢˜
                    console.log('docs/viewer.html: ä½¿ç”¨æœ¬åœ°loadMarkdownDirectlyå‡½æ•°');
                    loadMarkdownDirectly(markdownFile);
                }, 200);
            });

	            // åˆå§‹åŒ–ä¸‹æ‹‰èœå•
	            initializeDropdownMenu();

			            // åˆå§‹åŒ–æ‰‹æœºç«¯å¯¼èˆª
			            initializeMobileNavigation();
			        });

			        function initializeLearningSettingsUi() {
			            const openBtn = document.getElementById('learning-settings-toggle');
			            const overlay = document.getElementById('learning-settings-overlay');
			            const closeBtn = document.getElementById('learning-settings-close');
			            const authorToggle = document.getElementById('author-mode-toggle');
			            const authorDisable = document.getElementById('author-mode-disable');
			            if (!openBtn || !overlay) return;

			            function setOpen(isOpen) {
			                overlay.style.display = isOpen ? 'flex' : 'none';
			                overlay.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
			                openBtn.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
			                document.body.style.overflow = isOpen ? 'hidden' : '';
			            }

			            function open() { setOpen(true); }
			            function close() { setOpen(false); }

			            openBtn.addEventListener('click', open);
			            if (closeBtn) closeBtn.addEventListener('click', close);
			            overlay.addEventListener('click', function (e) {
			                if (e.target === overlay) close();
			            });
			            document.addEventListener('keydown', function (e) {
			                if (e.key === 'Escape' && overlay.getAttribute('aria-hidden') === 'false') close();
			            });

			            if (authorToggle) {
			                authorToggle.addEventListener('click', function () {
			                    const next = !isLearningAuthorModeEnabled();
			                    writeLearningAuthorMode(next);
			                    rerenderCurrentDocPreserveScroll();
			                });
			            }

			            if (authorDisable) {
			                authorDisable.addEventListener('click', function () {
			                    writeLearningAuthorMode(false);
			                    rerenderCurrentDocPreserveScroll();
			                });
			            }
			        }

		        async function initializeMarkedRender() {
		            console.log('åˆå§‹åŒ–MDæ¸²æŸ“å™¨...');

	            try {
	                function escapeHtml(text) {
	                    return String(text)
	                        .replace(/&/g, '&amp;')
	                        .replace(/</g, '&lt;')
	                        .replace(/>/g, '&gt;')
	                        .replace(/"/g, '&quot;')
	                        .replace(/'/g, '&#39;');
	                }

	                function normalizeMarkedArgs(href, title, text) {
	                    if (href && typeof href === 'object') {
	                        return {
	                            href: href.href,
	                            title: href.title,
	                            text: href.text || href.raw || ''
	                        };
	                    }
	                    return { href, title, text };
	                }

	                function isSafeUrl(href) {
	                    if (!href) return true;
	                    const trimmed = String(href).trim().toLowerCase();
	                    return !(
	                        trimmed.startsWith('javascript:') ||
	                        trimmed.startsWith('data:') ||
	                        trimmed.startsWith('vbscript:')
	                    );
	                }

	                const renderer = (marked.Renderer && typeof marked.Renderer === 'function')
	                    ? new marked.Renderer()
	                    : null;

		                if (renderer) {
	                    // ç¦æ­¢åœ¨ Markdown ä¸­æ¸²æŸ“åŸå§‹ HTMLï¼ˆé˜²æ­¢ XSSï¼‰
	                    renderer.html = (html) => escapeHtml(html);

	                    // è¿‡æ»¤å±é™©é“¾æ¥åè®®
	                    renderer.link = (href, title, text) => {
	                        const normalized = normalizeMarkedArgs(href, title, text);
	                        if (!isSafeUrl(normalized.href)) return escapeHtml(normalized.text || '');

	                        const rawHref = String(normalized.href || '');
	                        const safeText = normalized.text || '';
	                        const safeTitle = normalized.title ? ` title="${escapeHtml(normalized.title)}"` : '';

	                        if (rawHref.startsWith('#')) {
	                            return `<a href="${escapeHtml(rawHref)}"${safeTitle}>${safeText}</a>`;
	                        }

	                        const hashIndex = rawHref.indexOf('#');
	                        const hash = hashIndex >= 0 ? rawHref.slice(hashIndex) : '';
	                        const baseHref = hashIndex >= 0 ? rawHref.slice(0, hashIndex) : rawHref;

	                        if (!baseHref) return escapeHtml(safeText);

	                        if (
	                            baseHref.includes('.html') ||
	                            baseHref.startsWith('?') ||
	                            baseHref.includes('viewer.html') ||
	                            baseHref.includes('folder.html') ||
	                            /^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(baseHref)
	                        ) {
	                            return `<a href="${escapeHtml(rawHref)}"${safeTitle}>${safeText}</a>`;
	                        }

	                        const resolvedDoc = resolveDocLinkPath(baseHref, CURRENT_DOC_PATH);
	                        if (resolvedDoc) {
	                            const finalHref = `viewer.html?file=${encodeURIComponent(resolvedDoc)}${hash}`;
	                            return `<a href="${escapeHtml(finalHref)}"${safeTitle}>${safeText}</a>`;
	                        }

	                        const resolvedRelative = resolveRelativeHref(baseHref, CURRENT_DOC_PATH);
	                        const finalHref = `viewer.html?file=${encodeURIComponent(resolvedRelative)}${hash}`;
	                        return `<a href="${escapeHtml(finalHref)}"${safeTitle}>${safeText}</a>`;
	                    };

		                    renderer.image = (href, title, text) => {
	                        const normalized = normalizeMarkedArgs(href, title, text);
	                        if (!isSafeUrl(normalized.href)) return '';
	                        const resolvedSrc = resolveRelativeHref(normalized.href, CURRENT_DOC_PATH);
	                        const safeSrc = escapeHtml(resolvedSrc);
	                        const safeAlt = escapeHtml(normalized.text || '');
	                        const safeTitle = normalized.title ? ` title="${escapeHtml(normalized.title)}"` : '';
	                        return `<img src="${safeSrc}" alt="${safeAlt}"${safeTitle} loading="lazy" decoding="async" />`;
		                    };

		                    renderer.code = (code, lang) => {
		                        // marked ç‰ˆæœ¬å·®å¼‚å…¼å®¹ï¼šæœ‰çš„ç‰ˆæœ¬ä¼ å…¥ (code, lang)ï¼Œæœ‰çš„ç‰ˆæœ¬ä¼ å…¥ token å¯¹è±¡
		                        if (code && typeof code === 'object') {
		                            lang = code.lang;
		                            code = code.text || code.raw || '';
		                        }

		                        let language = String(lang || '').trim().toLowerCase();
		                        if (language === 'c#' || language === 'cs' || language === 'dotnet') {
		                            language = 'csharp';
		                        }
		                        const safeCode = escapeHtml(code || '');

		                        if (language === 'mermaid') {
		                            return `<div class="flowchart mermaid">${safeCode}</div>`;
		                        }

		                        if (language) {
		                            return `<pre><code class="language-${escapeHtml(language)}">${safeCode}</code></pre>`;
		                        }
		                        return `<pre><code>${safeCode}</code></pre>`;
		                    };
		                }

	                // é…ç½® marked.js é€‰é¡¹ï¼ˆGitHub Pages çº¯é™æ€ç¯å¢ƒï¼‰
	                marked.setOptions({
	                    renderer: renderer || undefined,
	                    highlight: function (code, lang) {
	                        let language = String(lang || '').trim().toLowerCase();
	                        if (language === 'c#' || language === 'cs' || language === 'dotnet') {
	                            language = 'csharp';
	                        }
	                        if (typeof Prism !== 'undefined' && language && Prism.languages[language]) {
	                            return Prism.highlight(code, Prism.languages[language], language);
	                        }
	                        return code;
	                    },
	                    breaks: true,
	                    gfm: true,
	                    tables: true,
	                    smartLists: true,
	                    smartypants: true,
	                    mangle: true,
	                    headerIds: true,
	                    xhtml: false,
	                    pedantic: false
	                });
	                console.log('MDæ¸²æŸ“å™¨åˆå§‹åŒ–å®Œæ¯•!');
	            } catch (error) {
	                console.error('åˆå§‹åŒ–MDæ¸²æŸ“å™¨å¤±è´¥:', error);
	            }
	        }

        // åˆå§‹åŒ–æ–‡æ¡£é…ç½®
        async function initializeDocumentConfig() {
            try {
                console.log('viewer.html: æ­£åœ¨åŠ è½½é…ç½®æ–‡ä»¶ï¼Œå½“å‰è·¯å¾„:', window.location.pathname);
                if (window.SiteConfig && typeof window.SiteConfig.load === 'function') {
                    VIEWER_DOC_CONFIG = await window.SiteConfig.load();
                } else {
                    const configResponse = await fetch('./config.json', { cache: 'no-store' });
                    if (!configResponse.ok) throw new Error('æ— æ³•åŠ è½½config.json: ' + configResponse.status);
                    VIEWER_DOC_CONFIG = await configResponse.json();
                }
                console.log('æˆåŠŸåŠ è½½é…ç½®æ–‡ä»¶:', VIEWER_DOC_CONFIG);
                    
                    // ä»é…ç½®æ–‡ä»¶ä¸­æå–åˆ†ç±»ã€ä¸»é¢˜å’Œè·¯å¾„æ˜ å°„
                    const categories = VIEWER_DOC_CONFIG.categories || {};
                    MAIN_CATEGORIES = {};
                    
                    // è½¬æ¢åˆ†ç±»æ ¼å¼ä»¥åŒ¹é…viewer.htmlçš„æœŸæœ›
                    Object.keys(categories).forEach(categoryKey => {
                        const category = categories[categoryKey];
                        const isSpecial = ["æ€ä¹ˆè´¡çŒ®", "Modderå…¥é—¨"].includes(categoryKey);
                        
                        MAIN_CATEGORIES[categoryKey] = {
                            title: category.title,
                            description: category.description,
                            icon: getCategoryIcon(categoryKey),
                            color: getCategoryColor(categoryKey),
                            order: getCategoryOrder(categoryKey),
                            special: isSpecial
                        };
                    });
                    
                    TOPIC_AREAS = VIEWER_DOC_CONFIG.topics || {};
                    VIEWER_PATH_REDIRECTS =
                        VIEWER_DOC_CONFIG.pathMappings ||
                        (VIEWER_DOC_CONFIG.settings && VIEWER_DOC_CONFIG.settings.pathMappings) ||
                        window.PATH_REDIRECTS ||
                        {};
                    
                    console.log('åŠ è½½çš„åˆ†ç±»:', MAIN_CATEGORIES);
                    console.log('åŠ è½½çš„ä¸»é¢˜:', TOPIC_AREAS);
                    console.log('åŠ è½½çš„è·¯å¾„æ˜ å°„:', VIEWER_PATH_REDIRECTS);
            } catch (error) {
                console.warn('åŠ è½½é…ç½®æ–‡ä»¶å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤é…ç½®:', error);
                VIEWER_DOC_CONFIG = generateDefaultConfig();
                // ä½¿ç”¨é»˜è®¤é…ç½®åˆå§‹åŒ–åˆ†ç±»ã€ä¸»é¢˜å’Œè·¯å¾„æ˜ å°„
                MAIN_CATEGORIES = getDefaultCategories();
                TOPIC_AREAS = getDefaultTopics();
                VIEWER_PATH_REDIRECTS = window.PATH_REDIRECTS || {};
            }

            // æ‰«ææ‰€æœ‰æ–‡æ¡£æ–‡ä»¶
            await scanAllDocuments();
        }

        // è·å–åˆ†ç±»å›¾æ ‡ - ä¼˜å…ˆä»é…ç½®æ–‡ä»¶è¯»å–ï¼Œå¦åˆ™ä½¿ç”¨é»˜è®¤å€¼
        function getCategoryIcon(categoryKey) {
            // é¦–å…ˆå°è¯•ä»é…ç½®æ–‡ä»¶ä¸­è·å–å›¾æ ‡
            if (VIEWER_DOC_CONFIG && VIEWER_DOC_CONFIG.categories && VIEWER_DOC_CONFIG.categories[categoryKey] && VIEWER_DOC_CONFIG.categories[categoryKey].icon) {
                return VIEWER_DOC_CONFIG.categories[categoryKey].icon;
            }
            
            // é»˜è®¤å›¾æ ‡æ˜ å°„
            const iconMap = {
                'å…¥é—¨': 'ğŸš€',
                'è¿›é˜¶': 'ğŸ“š',
                'é«˜çº§': 'ğŸ”¥',
                'ä¸ªäººåˆ†äº«': 'ğŸ’¡',
                'æ€ä¹ˆè´¡çŒ®': 'ğŸ¤',
                'Modderå…¥é—¨': 'ğŸ®'
            };
            return iconMap[categoryKey] || 'ğŸ“„';
        }

        // è·å–åˆ†ç±»é¢œè‰² - ä¼˜å…ˆä»é…ç½®æ–‡ä»¶è¯»å–ï¼Œå¦åˆ™ä½¿ç”¨é»˜è®¤å€¼
        function getCategoryColor(categoryKey) {
            // é¦–å…ˆå°è¯•ä»é…ç½®æ–‡ä»¶ä¸­è·å–é¢œè‰²
            if (VIEWER_DOC_CONFIG && VIEWER_DOC_CONFIG.categories && VIEWER_DOC_CONFIG.categories[categoryKey] && VIEWER_DOC_CONFIG.categories[categoryKey].color) {
                return VIEWER_DOC_CONFIG.categories[categoryKey].color;
            }
            
            // é»˜è®¤é¢œè‰²æ˜ å°„
            const colorMap = {
                'å…¥é—¨': '#4CAF50',
                'è¿›é˜¶': '#2196F3',
                'é«˜çº§': '#FF5722',
                'ä¸ªäººåˆ†äº«': '#FFC107',
                'æ€ä¹ˆè´¡çŒ®': '#9C27B0',
                'Modderå…¥é—¨': '#00BCD4'
            };
            return colorMap[categoryKey] || '#28a745';
        }

        // è·å–åˆ†ç±»æ’åº - ä¼˜å…ˆä»é…ç½®æ–‡ä»¶è¯»å–ï¼Œå¦åˆ™ä½¿ç”¨é»˜è®¤å€¼
        function getCategoryOrder(categoryKey) {
            // é¦–å…ˆå°è¯•ä»é…ç½®æ–‡ä»¶ä¸­è·å–æ’åº
            if (VIEWER_DOC_CONFIG && VIEWER_DOC_CONFIG.categories && VIEWER_DOC_CONFIG.categories[categoryKey] && VIEWER_DOC_CONFIG.categories[categoryKey].order !== undefined) {
                return VIEWER_DOC_CONFIG.categories[categoryKey].order;
            }
            
            // é»˜è®¤æ’åºæ˜ å°„
            const orderMap = {
                'å…¥é—¨': 1,
                'è¿›é˜¶': 2,
                'é«˜çº§': 3,
                'ä¸ªäººåˆ†äº«': 4,
                'æ€ä¹ˆè´¡çŒ®': 5,
                'Modderå…¥é—¨': 6
            };
            return orderMap[categoryKey] || 999;
        }

        // è·å–é»˜è®¤åˆ†ç±»é…ç½®
        function getDefaultCategories() {
            return {
                "å…¥é—¨": {
                    "title": "å…¥é—¨",
                    "description": "é€‚åˆåˆå­¦è€…çš„åŸºç¡€æ•™ç¨‹",
                    "icon": "ğŸš€",
                    "color": "#4CAF50",
                    "order": 1
                },
                "è¿›é˜¶": {
                    "title": "è¿›é˜¶",
                    "description": "æœ‰ä¸€å®šåŸºç¡€åçš„è¿›é˜¶æ•™ç¨‹",
                    "icon": "ğŸ“š",
                    "color": "#2196F3",
                    "order": 2
                },
                "é«˜çº§": {
                    "title": "é«˜çº§",
                    "description": "é¢å‘æœ‰ç»éªŒå¼€å‘è€…çš„é«˜çº§æ•™ç¨‹",
                    "icon": "ğŸ”¥",
                    "color": "#FF5722",
                    "order": 3
                },
                "ä¸ªäººåˆ†äº«": {
                    "title": "ä¸ªäººåˆ†äº«",
                    "description": "ç¤¾åŒºæˆå‘˜çš„ä¸ªäººç»éªŒå’ŒæŠ€å·§åˆ†äº«",
                    "icon": "ğŸ’¡",
                    "color": "#FFC107",
                    "order": 4
                },
                "æ€ä¹ˆè´¡çŒ®": {
                    "title": "æ€ä¹ˆè´¡çŒ®",
                    "description": "ä»‹ç»è´¡çŒ®è€…åº”è¯¥æ€ä¹ˆè´¡çŒ®æ–‡ç« ",
                    "icon": "ğŸ¤",
                    "color": "#9C27B0",
                    "order": 5,
                    "special": true
                },
                "Modderå…¥é—¨": {
                    "title": "Modderå…¥é—¨",
                    "description": "Modderå…¥é—¨ç›¸å…³çš„æ•™ç¨‹",
                    "icon": "ğŸ®",
                    "color": "#00BCD4",
                    "order": 6,
                    "special": true
                }
            };
        }

        // è·å–é»˜è®¤ä¸»é¢˜é…ç½®
        function getDefaultTopics() {
            return {
                "mod-basics": {
                    "title": "ModåŸºç¡€",
                    "description": "Modå¼€å‘çš„åŸºç¡€æ¦‚å¿µå’Œæ ¸å¿ƒAPI",
                    "icon": "ğŸ“–",
                    "order": 1
                },
                "env": {
                    "title": "ç¯å¢ƒé…ç½®",
                    "description": "å¼€å‘ç¯å¢ƒæ­å»ºå’Œé…ç½®",
                    "icon": "ğŸ› ï¸",
                    "order": 2
                },
                "items": {
                    "title": "ç‰©å“ç³»ç»Ÿ",
                    "description": "ç‰©å“ã€æ­¦å™¨å’Œè£…å¤‡çš„å¼€å‘",
                    "icon": "âš”ï¸",
                    "order": 3
                },
                "npcs": {
                    "title": "NPCç³»ç»Ÿ",
                    "description": "NPCçš„åˆ›å»ºå’Œè¡Œä¸ºå®šåˆ¶",
                    "icon": "ğŸ‘¥",
                    "order": 4
                },
                "world-gen": {
                    "title": "ä¸–ç•Œç”Ÿæˆ",
                    "description": "ä¸–ç•Œç”Ÿæˆå’Œåœ°å½¢ä¿®æ”¹",
                    "icon": "ğŸŒ",
                    "order": 5
                },
                "ui": {
                    "title": "UIç•Œé¢",
                    "description": "ç”¨æˆ·ç•Œé¢å’Œäº¤äº’è®¾è®¡",
                    "icon": "ğŸ¨",
                    "order": 6
                },
                "networking": {
                    "title": "ç½‘ç»œåŠŸèƒ½",
                    "description": "å¤šäººæ¸¸æˆå’Œç½‘ç»œé€šä¿¡",
                    "icon": "ğŸŒ",
                    "order": 7
                },
                "advanced": {
                    "title": "é«˜çº§åŠŸèƒ½",
                    "description": "é«˜çº§å¼€å‘æŠ€å·§å’Œä¼˜åŒ–",
                    "icon": "ğŸ”§",
                    "order": 8
                }
            };
        }

        // ç”Ÿæˆé»˜è®¤é…ç½®ï¼ˆå½“config.jsonä¸å­˜åœ¨æ—¶ï¼‰
        function generateDefaultConfig() {
            const config = {
                _metadata: {
                    version: "2.0.0",
                    schema: "tmodloader-docs-v2",
                    created: new Date().toISOString().split('T')[0],
                    lastUpdated: new Date().toISOString().split('T')[0],
                    description: "æ³°æ‹‰ç‘äºšModåˆ¶ä½œæ•™ç¨‹é…ç½®æ–‡ä»¶ - é»˜è®¤é…ç½®"
                },
                globalSettings: {
                    language: "zh",
                    theme: "default",
                    siteName: "æ³°æ‹‰ç‘äºšModåˆ¶ä½œæ•™ç¨‹",
                    siteDescription: "å…¨é¢çš„æ³°æ‹‰ç‘äºšModå¼€å‘æ•™ç¨‹èµ„æº",
                    baseUrl: "",
                    enableSearch: true,
                    enableDarkMode: true,
                    defaultOrder: 999,
                    dateFormat: "YYYY-MM-DD"
                },
                categories: {},
                topics: {},
                authors: {},
                all_files: [],
                pathMappings: {},
                settings: {
                    defaultCategory: "å…¥é—¨",
                    defaultTopic: "mod-basics",
                    specialCategories: ["æ€ä¹ˆè´¡çŒ®", "Modderå…¥é—¨"]
                }
            };

            // åˆå§‹åŒ–åˆ†ç±»ç»“æ„
            const defaultCategories = getDefaultCategories();
            Object.keys(defaultCategories).forEach(categoryKey => {
                config.categories[categoryKey] = {
                    ...defaultCategories[categoryKey],
                    topics: {
                        "mod-basics": {
                            title: "ModåŸºç¡€",
                            description: "Modå¼€å‘çš„åŸºç¡€æ¦‚å¿µå’Œæ ¸å¿ƒAPI",
                            files: []
                        }
                    }
                };
            });

            // åˆå§‹åŒ–ä¸»é¢˜ç»“æ„
            const defaultTopics = getDefaultTopics();
            Object.keys(defaultTopics).forEach(topicKey => {
                config.topics[topicKey] = defaultTopics[topicKey];
            });

            return config;
        }

        // æ‰«ææ‰€æœ‰æ–‡æ¡£æ–‡ä»¶
        async function scanAllDocuments() {
            console.log('=== scanAllDocuments() è¯Šæ–­å¼€å§‹ ===');
            try {
                // å®Œå…¨ä¾èµ–é…ç½®æ–‡ä»¶ï¼Œå› ä¸ºéƒ¨ç½²æ—¶ä¼šè°ƒç”¨ generate-index.js ç”Ÿæˆæ–°çš„ config.json
                try {
                    const config = VIEWER_DOC_CONFIG || (window.SiteConfig ? await window.SiteConfig.load() : null);
                    if (config) {
                        console.log('æˆåŠŸåŠ è½½é…ç½®æ–‡ä»¶:', config);

                        // ä»é…ç½®æ–‡ä»¶ä¸­æå–æ–‡æ¡£åˆ—è¡¨
                        ALL_DOCS = config.all_files || [];
                        console.log('ä»é…ç½®æ–‡ä»¶åŠ è½½çš„æ–‡æ¡£æ•°é‡:', ALL_DOCS.length);
                        console.log('ä»é…ç½®æ–‡ä»¶åŠ è½½çš„æ–‡æ¡£:', ALL_DOCS);

	                        // å¦‚æœé…ç½®æ–‡ä»¶ä¸­æœ‰æ–‡æ¡£ï¼Œç›´æ¥ä½¿ç”¨
	                        if (ALL_DOCS.length > 0) {
	                            // ç¡®ä¿æ¯ä¸ªæ–‡æ¡£éƒ½æœ‰å¿…è¦çš„å±æ€§
	                            ALL_DOCS = ALL_DOCS.map(doc => {
	                                return {
	                                    ...doc,
	                                    path: doc.path || doc.filename,
	                                    title: doc.title || doc.filename.replace('.md', ''),
	                                    author: doc.author || 'æœªçŸ¥',
	                                    category: doc.category || 'å…¥é—¨',
	                                    topic: doc.topic || 'mod-basics',
	                                    order: parseInt(doc.order) || 999,
	                                    description: doc.description || '',
	                                    last_updated: doc.last_updated || 'æœªçŸ¥'
	                                };
	                            });

                            console.log('å¤„ç†åçš„æ–‡æ¡£åˆ—è¡¨:', ALL_DOCS);
                            console.log('=== scanAllDocuments() è¯Šæ–­ç»“æŸ ===');
                            buildDocLookupMap();
                            return;
                        } else {
                            console.warn('é…ç½®æ–‡ä»¶ä¸­æ²¡æœ‰æ‰¾åˆ°æ–‡æ¡£');
                        }
                    } else {
                        console.warn('æ— æ³•è·å–é…ç½®æ–‡ä»¶ï¼Œæ–‡æ¡£åˆ—è¡¨ä¸ºç©º');
                    }
                } catch (configError) {
                    console.warn('åŠ è½½é…ç½®æ–‡ä»¶å¤±è´¥:', configError);
                }

                // å¦‚æœé…ç½®æ–‡ä»¶åŠ è½½å¤±è´¥æˆ–æ²¡æœ‰æ–‡æ¡£ï¼Œå°è¯•æ‰«æå¸¸è§çš„æ–‡æ¡£æ–‡ä»¶
                console.warn('é…ç½®æ–‡ä»¶ä¸å¯ç”¨ï¼Œå°è¯•æ‰«æå¸¸è§æ–‡æ¡£æ–‡ä»¶');
		                const commonFiles = [
		                    'Modderå…¥é—¨/DPapyru-ä»è¿™é‡Œå¼€å§‹.md',
		                    'æ€ä¹ˆè´¡çŒ®/æ•™å­¦æ–‡ç« å†™ä½œæŒ‡å—.md',
		                    'æ€ä¹ˆè´¡çŒ®/TopicSystemä½¿ç”¨æŒ‡å—.md',
		                    'èºçº¿ç¿»è¯‘tmlæ•™ç¨‹/0-å¼€å§‹/0-Home ä¸»é¡µ.md'
		                ];

                ALL_DOCS = [];

                for (const filename of commonFiles) {
                    try {
                        console.log(`å°è¯•å¤„ç†æ–‡æ¡£: ${filename}`);
                        // è·å–æ–‡æ¡£å†…å®¹å’Œå…ƒæ•°æ®
                        const docUrl = `./${filename}`;
                        const docResponse = await fetch(docUrl, { cache: 'no-store' });

                        if (docResponse.ok) {
                            const content = await docResponse.text();
                            const { metadata } = parseFrontMatter(content);

                            // å¤„ç†åˆ†ç±»æ˜ å°„
                            let category = metadata.category || 'å…¥é—¨';
                            if (category && MAIN_CATEGORIES[category] && MAIN_CATEGORIES[category].mapsTo) {
                                const oldCategory = category;
                                category = MAIN_CATEGORIES[category].mapsTo;
                                console.log(`æ–‡æ¡£ ${filename} çš„åˆ†ç±»ä» ${oldCategory} æ˜ å°„åˆ° ${category}`);
                            }

		                            const docInfo = {
		                                filename: filename,
		                                title: metadata.title || filename.replace('.md', ''),
		                                author: metadata.author || 'æœªçŸ¥',
		                                category: category,
		                                topic: metadata.topic || 'mod-basics',
		                                order: parseOrder(metadata.order),
		                                description: metadata.description || '',
		                                last_updated: metadata.last_updated || 'æœªçŸ¥'
		                            };

                            ALL_DOCS.push(docInfo);
                            console.log('æˆåŠŸæ·»åŠ æ–‡æ¡£:', docInfo.title);
                        } else {
                            console.warn(`æ–‡æ¡£ ${filename} è¯·æ±‚å¤±è´¥: ${docResponse.status} ${docResponse.statusText}`);
                        }
                    } catch (error) {
                        console.warn(`æ— æ³•å¤„ç†æ–‡æ¡£ ${filename}:`, error);
                    }
                }

                // æŒ‰åˆ†ç±»å’Œæ’åº
	                ALL_DOCS.sort((a, b) => {
	                    if (a.category !== b.category) {
	                        return (MAIN_CATEGORIES[a.category]?.order ?? 999) - (MAIN_CATEGORIES[b.category]?.order ?? 999);
	                    }
	                    return a.order - b.order;
	                });

                console.log('æ‰«æåˆ°çš„æ–‡æ¡£æ•°é‡:', ALL_DOCS.length);
                console.log('æ‰«æåˆ°çš„æ–‡æ¡£:', ALL_DOCS);
                console.log('=== scanAllDocuments() è¯Šæ–­ç»“æŸ ===');
                buildDocLookupMap();

            } catch (error) {
                console.error('æ‰«ææ–‡æ¡£å¤±è´¥:', error);
                console.log('=== scanAllDocuments() å› é”™è¯¯ç»“æŸ ===');
                // æä¾›ä¸€äº›é»˜è®¤æ–‡æ¡£
		                ALL_DOCS = [
		                    {
		                        filename: 'Modderå…¥é—¨/DPapyru-ä»è¿™é‡Œå¼€å§‹.md',
		                        path: 'Modderå…¥é—¨/DPapyru-ä»è¿™é‡Œå¼€å§‹.md',
		                        title: 'ä»è¿™é‡Œå¼€å§‹ï¼šModder å…¥é—¨æ€»è§ˆ',
		                        author: 'DPapyru',
		                        category: 'Modderå…¥é—¨',
	                        topic: 'mod-basics',
	                        order: 1,
	                        description: 'è§£é‡Š Modderå…¥é—¨çš„é˜…è¯»æ–¹å¼ï¼Œå¹¶æŒ‰ C#/tML ç†Ÿç»ƒåº¦ä¸åå¥½ç»™å‡ºå»ºè®®å…¥å£',
	                        last_updated: 'æœªçŸ¥'
	                    }
	                ];
                console.log('ä½¿ç”¨é»˜è®¤æ–‡æ¡£é…ç½®');
                buildDocLookupMap();
            }
        }

        function buildDocLookupMap() {
            const map = new Map();

            function addKey(key, value) {
                if (!key || !value) return;
                const strKey = String(key);
                map.set(strKey, value);
                const lower = strKey.toLowerCase();
                if (!map.has(lower)) map.set(lower, value);
            }

            function slugFromFilename(filename) {
                const base = String(filename || '').replace(/\.md$/i, '');
                if (!base) return '';
                const firstToken = base.split(' ')[0];
                return firstToken.replace(/^\d+-/, '');
            }

            (ALL_DOCS || []).forEach(doc => {
                const resolvedPath = doc && (doc.path || doc.filename);
                if (!resolvedPath) return;

                addKey(resolvedPath, resolvedPath);
                addKey(resolvedPath.replace(/\.md$/i, ''), resolvedPath);

                if (doc.filename) {
                    addKey(doc.filename, resolvedPath);
                    addKey(String(doc.filename).replace(/\.md$/i, ''), resolvedPath);

                    const slug = slugFromFilename(doc.filename);
                    addKey(slug, resolvedPath);
                    addKey(`${slug}.md`, resolvedPath);
                }

                if (doc.originalPath) {
                    addKey(doc.originalPath, resolvedPath);
                    addKey(String(doc.originalPath).replace(/\.md$/i, ''), resolvedPath);
                }
            });

            DOC_LOOKUP_MAP = map;
        }

        function normalizePath(inputPath) {
            const parts = String(inputPath || '').split('/');
            const stack = [];
            for (const part of parts) {
                if (!part || part === '.') continue;
                if (part === '..') {
                    if (stack.length) stack.pop();
                    continue;
                }
                stack.push(part);
            }
            return stack.join('/');
        }

        function resolveRelativeHref(rawHref, currentDocPath) {
            if (!currentDocPath) return rawHref;
            if (!rawHref) return rawHref;

            const hrefStr = String(rawHref);
            if (
                hrefStr.startsWith('#') ||
                hrefStr.startsWith('/') ||
                /^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(hrefStr)
            ) {
                return rawHref;
            }

            const hashIndex = hrefStr.indexOf('#');
            const baseHref = hashIndex >= 0 ? hrefStr.slice(0, hashIndex) : hrefStr;
            const hash = hashIndex >= 0 ? hrefStr.slice(hashIndex) : '';

            let decoded = baseHref;
            try {
                decoded = decodeURIComponent(baseHref);
            } catch {
                decoded = baseHref;
            }

            const baseDir = String(currentDocPath).split('/').slice(0, -1).join('/');
            if (!baseDir) return rawHref;

            const joined = normalizePath(`${baseDir}/${decoded.replace(/^\.?\//, '')}`);
            return `${joined}${hash}`;
        }

	        function resolveDocLinkPath(href, currentDocPath) {
	            if (!href) return null;

            const hrefStr = String(href);
            if (hrefStr.startsWith('/') || /^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(hrefStr)) return null;

            let decodedPath = hrefStr;
            try {
                decodedPath = decodeURIComponent(hrefStr);
            } catch {
                decodedPath = hrefStr;
            }

            decodedPath = decodedPath.replace(/^\.?\//, '').replace(/^docs\//, '');

            const candidates = [];
            if (decodedPath) {
                candidates.push(decodedPath);
                candidates.push(decodedPath.replace(/\.md$/i, ''));
                if (!decodedPath.endsWith('.md') && !decodedPath.includes('.')) {
                    candidates.push(`${decodedPath}.md`);
                }
            }

	            // ç‰¹ä¾‹ï¼šModderå…¥é—¨çš„â€œæ–‡ç« ä½¿ç”¨å†…å®¹ç´¢å¼•â€å¸Œæœ›åœ¨ä»»æ„å­ç›®å½•éƒ½èƒ½ç”¨åŒä¸€ç§çŸ­å†™æ³•
	            // ä¾‹å¦‚åœ¨ `Modderå…¥é—¨/1-å…¥é—¨/...` ä¸­å†™ `æ–‡ç« ä½¿ç”¨å†…å®¹ç´¢å¼•/...` æ—¶ï¼Œåº”è§£æä¸º `Modderå…¥é—¨/æ–‡ç« ä½¿ç”¨å†…å®¹ç´¢å¼•/...`
	            if (currentDocPath && decodedPath && decodedPath.startsWith('æ–‡ç« ä½¿ç”¨å†…å®¹ç´¢å¼•/')) {
	                const root = String(currentDocPath).split('/')[0];
	                if (root === 'Modderå…¥é—¨') {
	                    const anchored = normalizePath(`${root}/${decodedPath}`);
	                    candidates.unshift(anchored);
	                    candidates.unshift(anchored.replace(/\.md$/i, ''));
	                    if (!anchored.endsWith('.md') && !anchored.includes('.')) {
	                        candidates.unshift(`${anchored}.md`);
	                    }
	                }
	            }

            if (currentDocPath && decodedPath) {
                const baseDir = String(currentDocPath).split('/').slice(0, -1).join('/');
                if (baseDir) {
                    const joined = normalizePath(`${baseDir}/${decodedPath}`);
                    candidates.unshift(joined);
                    candidates.unshift(joined.replace(/\.md$/i, ''));
                    if (!joined.endsWith('.md') && !joined.includes('.')) {
                        candidates.unshift(`${joined}.md`);
                    }
                }
            }

            const lookup = DOC_LOOKUP_MAP;
            if (!lookup) return null;

            for (const c of candidates) {
                if (!c) continue;
                const hit = lookup.get(c) || lookup.get(String(c).toLowerCase());
                if (hit) return hit;
            }

	            return null;
	        }

	        const TRANSCLUSION_LINE_RE = /^\s*\{\[([^\]\n\r]+)\]\[([^\]\n\r]+)\]\}\s*$/;
	        const TRANSCLUSION_MAX_DEPTH = 4;
	        const TRANSCLUSION_MAX_FILES = 30;
	        const TRANSCLUSION_CACHE = new Map();
	        const LEARNING_PREFS_KEY = 'learningPreferences';
	        const LEARNING_PREF_OVERRIDES_KEY = 'learningPreferenceOverrides';
	        const LEARNING_NO_PREFS_HINT_DISMISSED_SESSION_KEY = 'learningNoPrefsHintDismissedSession';
	        const LEARNING_AUTHOR_MODE_KEY = 'learningAuthorMode';

	        const LEARNING_PREF_KEYS = [
	            { key: 'P_step', label: 'æ›´ç»†æ­¥éª¤', description: 'æ›´åå¥½æŒ‰æ­¥éª¤èµ°ï¼ˆå°‘è·³æ­¥ï¼‰' },
	            { key: 'P_code', label: 'æ›´å¤šä»£ç ', description: 'æ›´åå¥½ç›´æ¥çœ‹å¯è¿è¡Œä»£ç ' },
	            { key: 'P_theory', label: 'åŸç†è§£é‡Š', description: 'æ›´åå¥½å…ˆè®²åŸç†/æ¦‚å¿µå†ä¸Šæ‰‹' },
	            { key: 'P_minimal', label: 'æœ€å°ç¤ºä¾‹', description: 'æ›´åå¥½æœ€å°å¯ç”¨ç¤ºä¾‹ï¼ˆå‡å°‘æ‰©å±•ï¼‰' },
	            { key: 'P_troubleshoot', label: 'æ’é”™æ¸…å•', description: 'æ›´åå¥½å¸¸è§å‘/æ’é”™æ¸…å•' },
	            { key: 'P_best_practice', label: 'è§„èŒƒå†™æ³•', description: 'æ›´åå¥½è§„èŒƒ/æƒ¯ç”¨å†™æ³•ï¼ˆå¯ç»´æŠ¤æ€§ï¼‰' },
	            { key: 'P_api_reference', label: 'API è¯´æ˜', description: 'æ›´åå¥½ API è¯´æ˜/æŸ¥è¡¨å¼è§£é‡Š' },
	            { key: 'P_visual', label: 'å›¾ç¤ºç±»æ¯”', description: 'æ›´åå¥½å›¾ç¤º/ç±»æ¯”/ç»“æ„å›¾' },
	            { key: 'P_performance', label: 'æ€§èƒ½æ•æ„Ÿ', description: 'æ›´åå¥½æ€§èƒ½/GC/å¸§ç‡ç›¸å…³å†…å®¹' },
	            { key: 'P_rendering', label: 'æ¸²æŸ“æ–¹å‘', description: 'æ›´åå¥½ç»˜åˆ¶/Shader/é¡¶ç‚¹ç»˜åˆ¶ç›¸å…³å†…å®¹' }
	        ];

	        function safeJsonParse(raw, fallback) {
	            try {
	                if (!raw) return fallback;
	                const parsed = JSON.parse(raw);
	                return parsed == null ? fallback : parsed;
	            } catch (e) {
	                return fallback;
	            }
	        }

	        function getLearningAuthorModeFromUrl() {
	            try {
	                const url = new URL(window.location.href);
	                const v = url.searchParams.get('author');
	                if (v == null) return null;
	                if (v === '1' || v.toLowerCase() === 'true') return true;
	                if (v === '0' || v.toLowerCase() === 'false') return false;
	                return null;
	            } catch (e) {
	                return null;
	            }
	        }

	        function readLearningAuthorMode() {
	            try {
	                return window.localStorage.getItem(LEARNING_AUTHOR_MODE_KEY) === 'true';
	            } catch (e) {
	                return false;
	            }
	        }

	        function writeLearningAuthorMode(enabled) {
	            try {
	                window.localStorage.setItem(LEARNING_AUTHOR_MODE_KEY, enabled ? 'true' : 'false');
	            } catch (e) {
	                // ignore
	            }
	        }

	        function initializeLearningAuthorModeFromUrl() {
	            const parsed = getLearningAuthorModeFromUrl();
	            if (parsed == null) return;
	            writeLearningAuthorMode(Boolean(parsed));
	        }

	        function isLearningAuthorModeEnabled() {
	            return readLearningAuthorMode();
	        }

	        function escapeHtmlAttribute(value) {
	            return String(value || '')
	                .replace(/&/g, '&amp;')
	                .replace(/</g, '&lt;')
	                .replace(/>/g, '&gt;')
	                .replace(/"/g, '&quot;')
	                .replace(/'/g, '&#39;');
	        }

	        function createLearningDiagnostics(filePath) {
	            return {
	                filePath: String(filePath || ''),
	                createdAt: new Date().toISOString(),
	                condition: {
	                    blocks: 0,
	                    directives: { if: 0, elseif: 0, else: 0, end: 0 },
	                    inputLines: 0,
	                    outputLines: 0,
	                    removedLines: 0,
	                    errors: []
	                },
	                transclusion: {
	                    matchedLines: 0,
	                    expandedCount: 0,
	                    includedDocs: [],
	                    errors: []
	                },
	                metadata: {
	                    warnings: [],
	                    errors: []
	                },
	                structure: {
	                    warnings: []
	                },
	                links: {
	                    mdLinkErrors: [],
	                    imageErrors: [],
	                    scannedAt: null
	                }
	            };
	        }

	        function setCurrentLearningDiagnostics(diag) {
	            window.CURRENT_RENDER_DIAGNOSTICS = diag || null;
	        }

	        function getCurrentLearningDiagnostics() {
	            return window.CURRENT_RENDER_DIAGNOSTICS || null;
	        }

	        function isIndexedDocPath(docPath, currentDocPath) {
	            if (!docPath) return false;
	            const raw = String(docPath);
	            const cleaned = raw.replace(/^\.?\//, '').replace(/^docs\//, '');
	            const lookup = DOC_LOOKUP_MAP;

	            if (lookup) {
	                const candidates = [
	                    cleaned,
	                    cleaned.toLowerCase(),
	                    cleaned.replace(/\.md$/i, ''),
	                    cleaned.replace(/\.md$/i, '').toLowerCase()
	                ];
	                for (const c of candidates) {
	                    if (!c) continue;
	                    if (lookup.get(c)) return true;
	                }
	            }

	            if (ALL_DOCS && Array.isArray(ALL_DOCS) && ALL_DOCS.length) {
	                const hit = ALL_DOCS.find(d => {
	                    const p = d && (d.path || d.filename);
	                    return p === cleaned || d.filename === cleaned || d.path === cleaned || p === raw;
	                });
	                if (hit) return true;
	            }

	            if (currentDocPath) {
	                const resolved = resolveDocLinkPath(cleaned, currentDocPath);
	                if (resolved && resolved !== cleaned) return true;
	            }

	            return false;
	        }

	        function readLearningQuizPreferences() {
	            const raw = window.localStorage.getItem(LEARNING_PREFS_KEY);
	            const parsed = safeJsonParse(raw, {});
	            return parsed && typeof parsed === 'object' ? parsed : {};
	        }

	        function normalizeTriState(value) {
	            const v = String(value || '').toLowerCase();
	            if (v === 'on' || v === 'off' || v === 'auto') return v;
	            return 'auto';
	        }

	        function readLearningPreferenceOverrides() {
	            const raw = window.localStorage.getItem(LEARNING_PREF_OVERRIDES_KEY);
	            const parsed = safeJsonParse(raw, {});
	            const out = {};
	            if (!parsed || typeof parsed !== 'object') return out;
	            Object.keys(parsed).forEach(function (k) {
	                out[String(k)] = normalizeTriState(parsed[k]);
	            });
	            return out;
	        }

	        function writeLearningPreferenceOverrides(overrides) {
	            try {
	                window.localStorage.setItem(LEARNING_PREF_OVERRIDES_KEY, JSON.stringify(overrides || {}));
	            } catch (e) {
	                // ignore
	            }
	        }

	        function hasAnyNonAutoOverrides(overrides) {
	            if (!overrides) return false;
	            return Object.keys(overrides).some(function (k) {
	                const v = normalizeTriState(overrides[k]);
	                return v === 'on' || v === 'off';
	            });
	        }

	        function setSessionNoPrefsHintDismissed() {
	            try {
	                window.sessionStorage.setItem(LEARNING_NO_PREFS_HINT_DISMISSED_SESSION_KEY, 'true');
	            } catch (e) {
	                // ignore
	            }
	        }

	        function getSessionNoPrefsHintDismissed() {
	            try {
	                return window.sessionStorage.getItem(LEARNING_NO_PREFS_HINT_DISMISSED_SESSION_KEY) === 'true';
	            } catch (e) {
	                return false;
	            }
	        }

	        function derivePreferenceFlagsFromQuiz(quizPrefs) {
	            const prefs = quizPrefs && typeof quizPrefs === 'object' ? quizPrefs : {};
	            const flags = {};
	            LEARNING_PREF_KEYS.forEach(function (p) { flags[p.key] = 0; });

	            function getValue(id) {
	                const hit = prefs[id];
	                if (!hit || typeof hit !== 'object') return '';
	                return String(hit.value || '');
	            }

	            function enable(keys) {
	                (keys || []).forEach(function (k) { flags[k] = 1; });
	            }

	            const time = getValue('pref-time');
	            if (time === 'fast') enable(['P_minimal', 'P_code']);
	            else if (time === 'balanced') enable(['P_step']);
	            else if (time === 'deep') enable(['P_theory', 'P_api_reference', 'P_best_practice']);

	            const style = getValue('pref-style');
	            if (style === 'snippets') enable(['P_code', 'P_minimal']);
	            else if (style === 'templates') enable(['P_code', 'P_step']);
	            else if (style === 'longform') enable(['P_theory', 'P_api_reference']);

	            const help = getValue('pref-help');
	            if (help === 'tutorial-first') enable(['P_step']);
	            else if (help === 'search-first') enable(['P_troubleshoot']);
	            else if (help === 'source-first') enable(['P_theory', 'P_api_reference', 'P_best_practice']);

	            const goal = getValue('pref-goal');
	            if (goal === 'first-mod') enable(['P_step', 'P_code', 'P_minimal']);
	            else if (goal === 'systematic') enable(['P_theory', 'P_api_reference', 'P_best_practice']);
	            else if (goal === 'problem-driven') enable(['P_troubleshoot', 'P_api_reference']);

	            const focus = getValue('pref-focus');
	            if (focus === 'env') enable(['P_troubleshoot', 'P_step']);
	            else if (focus === 'timing') enable(['P_troubleshoot', 'P_theory']);
	            else if (focus === 'perf-net') enable(['P_performance', 'P_best_practice', 'P_troubleshoot']);

	            const output = getValue('pref-output');
	            if (output === 'new-content') enable(['P_code']);
	            else if (output === 'new-system') enable(['P_theory', 'P_best_practice']);
	            else if (output === 'fx') enable(['P_rendering', 'P_visual']);

	            const tml = getValue('pref-tml');
	            if (tml === 'systems') enable(['P_theory', 'P_best_practice']);
	            else if (tml === 'advanced') enable(['P_api_reference', 'P_best_practice', 'P_performance']);

	            const csharp = getValue('pref-csharp');
	            if (csharp === 'csharp-first') enable(['P_theory', 'P_best_practice']);
	            else if (csharp === 'learn-as-you-go') enable(['P_troubleshoot']);
	            else if (csharp === 'results-first') enable(['P_minimal', 'P_code']);

	            return flags;
	        }

	        function clampLearningLevel(value) {
	            const n = Number.parseInt(value, 10);
	            if (!Number.isFinite(n)) return 0;
	            return Math.max(0, Math.min(2, n));
	        }

	        function getLearningConditionContext() {
	            try {
	                const raw = window.localStorage.getItem('learningProfile');
	                if (!raw) return { C: 0, T: 0 };
	                const parsed = JSON.parse(raw);
	                if (!parsed || typeof parsed !== 'object') return { C: 0, T: 0 };
	                return {
	                    C: clampLearningLevel(parsed.c),
	                    T: clampLearningLevel(parsed.t)
	                };
	            } catch (e) {
	                return { C: 0, T: 0 };
	            }
	        }

	        function getLearningRenderContext() {
	            const base = getLearningConditionContext();
	            const quizPrefs = readLearningQuizPreferences();
	            const overrides = readLearningPreferenceOverrides();
	            const autoFlags = derivePreferenceFlagsFromQuiz(quizPrefs);
	            const authorMode = isLearningAuthorModeEnabled();

	            const ctx = {
	                C: base.C,
	                T: base.T,
	                AUTHOR: authorMode ? 1 : 0
	            };

	            LEARNING_PREF_KEYS.forEach(function (p) {
	                const key = p.key;
	                const tri = normalizeTriState(overrides[key]);
	                const auto = Number(autoFlags[key] || 0) ? 1 : 0;
	                const final = tri === 'on' ? 1 : (tri === 'off' ? 0 : auto);

	                ctx[key] = final;
	                ctx[key.toUpperCase()] = final;
	            });

	            return {
	                ctx: ctx,
	                quizPrefs: quizPrefs,
	                overrides: overrides,
	                autoFlags: autoFlags,
	                authorMode: authorMode
	            };
	        }

	        function getOnboardingUrlFromViewer() {
	            return '../onboarding.html';
	        }

		        function renderLearningHintsBanner(model) {
		            const container = document.getElementById('learning-hints');
		            const hints = document.getElementById('learning-hint-prefs') || container;
		            if (!container || !hints) return;

	            const hasQuizPrefs = model && model.quizPrefs && Object.keys(model.quizPrefs).length > 0;
	            const hasOverrides = model && hasAnyNonAutoOverrides(model.overrides);
	            const dismissed = getSessionNoPrefsHintDismissed();

	            if (hasQuizPrefs || hasOverrides || dismissed) {
	                hints.innerHTML = '';
	                updateLearningHintsVisibility();
	                return;
	            }

		            hints.innerHTML = [
		                '<div class="learning-hint-card">',
		                '<div class="learning-hint-title">å°šæœªå®Œæˆæµ‹è¯„</div>',
		                '<div class="learning-hint-text">ä½ å°šæœªå®Œæˆå…¥ç«™æµ‹è¯„ï¼Œä¸”æœªæ‰‹åŠ¨è®¾ç½®åˆ†æµåå¥½ã€‚å†…å®¹ä»å¯æ­£å¸¸é˜…è¯»ï¼Œä½†åˆ†æµæç¤º/æ¨èå¯èƒ½ä¸å¤Ÿè´´åˆã€‚</div>',
		                '<div class="learning-hint-actions">',
		                '<button type="button" class="btn btn-small btn-primary" data-action="open-prefs">æ‰“å¼€åå¥½è®¾ç½®</button>',
		                '<a class="btn btn-small btn-outline" href="' + getOnboardingUrlFromViewer() + '">å»åšå…¥ç«™æµ‹è¯„</a>',
		                '<button type="button" class="btn btn-small btn-secondary" data-action="dismiss-session">æœ¬æ¬¡ä¸å†æç¤º</button>',
		                '</div>',
		                '</div>'
		            ].join('');

	            const openBtn = hints.querySelector('[data-action="open-prefs"]');
			            if (openBtn) {
			                openBtn.addEventListener('click', function () {
			                    const trigger = document.getElementById('learning-settings-toggle');
			                    if (trigger) trigger.click();
			                });
			            }

	            const dismissBtn = hints.querySelector('[data-action="dismiss-session"]');
	            if (dismissBtn) {
	                dismissBtn.addEventListener('click', function () {
	                    setSessionNoPrefsHintDismissed();
	                    renderLearningHintsBanner(model);
	                });
	            }

		            updateLearningHintsVisibility();
		        }

                function renderLearningTopBanner(model) {
                    const banner = document.getElementById('learn-top-banner');
                    const bannerText = document.getElementById('learn-top-banner-text');
                    const closeBtn = document.getElementById('learn-top-banner-close');
                    if (!banner || !bannerText) return;

                    const hasQuizPrefs = model && model.quizPrefs && Object.keys(model.quizPrefs).length > 0;
                    const hasOverrides = model && hasAnyNonAutoOverrides(model.overrides);
                    const dismissed = getSessionNoPrefsHintDismissed();

                    if (hasQuizPrefs || hasOverrides || dismissed) {
                        banner.style.display = 'none';
                        banner.setAttribute('aria-hidden', 'true');
                        return;
                    }

                    bannerText.textContent = 'ä½ å°šæœªå®Œæˆå…¥ç«™æµ‹è¯„ï¼Œå½“å‰ä¸ºé»˜è®¤æ˜¾ç¤ºï¼ˆä¸å½±å“é˜…è¯»ï¼‰ã€‚';
                    banner.style.display = 'block';
                    banner.setAttribute('aria-hidden', 'false');

                    if (closeBtn && !closeBtn.__LEARN_BOUND) {
                        closeBtn.__LEARN_BOUND = true;
                        closeBtn.addEventListener('click', function () {
                            setSessionNoPrefsHintDismissed();
                            renderLearningTopBanner(model);
                            renderLearningHintsBanner(model);
                        });
                    }
                }

                function initializeViewerFocusMode() {
                    const btn = document.getElementById('focus-mode-toggle');
                    if (!btn) return;
                    const key = 'viewer_focus_mode';

                    function apply(enabled) {
                        document.body.classList.toggle('focus-mode', !!enabled);
                        btn.setAttribute('aria-pressed', enabled ? 'true' : 'false');
                        btn.textContent = enabled ? 'é€€å‡ºç„¦ç‚¹' : 'ç„¦ç‚¹æ¨¡å¼';
                    }

                    try {
                        const stored = window.localStorage ? window.localStorage.getItem(key) : null;
                        apply(stored === '1');
                    } catch (e) {
                        apply(false);
                    }

                    btn.addEventListener('click', function () {
                        const enabled = !document.body.classList.contains('focus-mode');
                        apply(enabled);
                        try {
                            if (window.localStorage) window.localStorage.setItem(key, enabled ? '1' : '0');
                        } catch (e) {}
                    });
                }

	                function initializeSidebarQuickSearch() {
	                    const input = document.getElementById('sidebar-quick-search');
	                    const root = document.getElementById('category-sidebar');
	                    if (!input || !root) return;

	                    function normalize(s) {
	                        return String(s || '').trim().toLowerCase();
	                    }

	                    function setCollapsed(folderEl, collapsed) {
	                        if (!folderEl) return;
	                        folderEl.dataset.collapsed = collapsed ? '1' : '0';
	                        const toggleBtn = folderEl.querySelector(':scope > .learn-tree-row .learn-tree-toggle');
	                        if (toggleBtn) toggleBtn.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
	                    }

	                    function getCollapsedStateOrNull(type, key) {
	                        try {
	                            const storageKey = `docsViewerSidebar${type.charAt(0).toUpperCase() + type.slice(1)}${key.charAt(0).toUpperCase() + key.slice(1)}`;
	                            const state = localStorage.getItem(storageKey);
	                            if (state === null) return null;
	                            return state === 'true';
	                        } catch (error) {
	                            return null;
	                        }
	                    }

	                    function apply() {
	                        const q = normalize(input.value);
	                        const folderEls = Array.from(root.querySelectorAll('.learn-tree-folder'));
	                        const fileEls = Array.from(root.querySelectorAll('.learn-tree-file'));

	                        if (!q) {
	                            fileEls.forEach(function (li) { li.style.display = ''; });
	                            folderEls.forEach(function (folder) {
	                                folder.style.display = '';
	                                const key = folder.dataset.folderKey || '';
	                                const storedCollapsed = key ? getCollapsedStateOrNull('folder', key) : null;
	                                const defaultCollapsed = Number(folder.dataset.depth || 0) >= 1;
	                                const forceOpen = !!folder.querySelector('.learn-tree-link.active');
	                                setCollapsed(folder, (storedCollapsed === null ? defaultCollapsed : storedCollapsed) && !forceOpen);
	                            });
	                            return;
	                        }

	                        fileEls.forEach(function (li) {
	                            const link = li.querySelector('.learn-tree-link');
	                            const text = normalize(link ? link.textContent : '');
	                            const hit = !!text && text.indexOf(q) !== -1;
	                            li.style.display = hit ? '' : 'none';
	                            li.dataset.match = hit ? '1' : '0';
	                        });

	                        // ç”±æ·±åˆ°æµ…ï¼Œç¡®ä¿çˆ¶èŠ‚ç‚¹æ ¹æ®å­èŠ‚ç‚¹æ˜¾éšæ›´æ–°
	                        folderEls.sort(function (a, b) {
	                            return Number(b.dataset.depth || 0) - Number(a.dataset.depth || 0);
	                        });

	                        folderEls.forEach(function (folder) {
	                            const label = folder.querySelector(':scope > .learn-tree-row .learn-tree-label');
	                            const labelText = normalize(label ? label.textContent : '');
	                            const selfMatch = !!labelText && labelText.indexOf(q) !== -1;

	                            if (selfMatch) {
	                                folder.style.display = '';
	                                folder.querySelectorAll('.learn-tree-folder, .learn-tree-file').forEach(function (n) {
	                                    n.style.display = '';
	                                });
	                                setCollapsed(folder, false);
	                                return;
	                            }

	                            const directChildren = Array.from(folder.querySelectorAll(':scope > .learn-tree-children > li'));
	                            const hasVisibleChild = directChildren.some(function (li) { return li.style.display !== 'none'; });
	                            folder.style.display = hasVisibleChild ? '' : 'none';
	                            if (hasVisibleChild) setCollapsed(folder, false);
	                        });
	                    }

	                    input.addEventListener('input', apply);
	                    input.addEventListener('search', apply);
	                }

	        function updateLearningHintsVisibility() {
	            const container = document.getElementById('learning-hints');
	            if (!container) return;
	            const nodes = [
	                document.getElementById('learning-hint-recommendation'),
	                document.getElementById('learning-hint-prefs'),
	                document.getElementById('learning-hint-author')
	            ].filter(Boolean);
	            const hasAny = nodes.some(function (n) { return n.innerHTML && String(n.innerHTML).trim(); });
	            container.style.display = hasAny ? 'block' : 'none';
	        }

	        function renderLearningRecommendationHint(metadata, model) {
	            const node = document.getElementById('learning-hint-recommendation');
	            if (!node) return;

	            const minC = (metadata && typeof metadata.min_c === 'number') ? metadata.min_c : null;
	            const minT = (metadata && typeof metadata.min_t === 'number') ? metadata.min_t : null;

	            if (minC == null && minT == null) {
	                node.innerHTML = '';
	                updateLearningHintsVisibility();
	                return;
	            }

	            const ctx = (model && model.ctx) ? model.ctx : getLearningConditionContext();
	            const parts = [];
	            if (minC != null) parts.push('Câ‰¥' + String(minC));
	            if (minT != null) parts.push('Tâ‰¥' + String(minT));

	            const current = 'å½“å‰ï¼šC' + Number(ctx.C || 0) + '/T' + Number(ctx.T || 0);
	            const below =
	                (minC != null && Number(ctx.C || 0) < Number(minC)) ||
	                (minT != null && Number(ctx.T || 0) < Number(minT));

	            node.innerHTML = [
	                '<div class="learning-hint-card learning-recommend-card' + (below ? ' low' : '') + '">',
	                '<div class="learning-hint-title">å»ºè®®é˜…è¯»é—¨æ§›</div>',
	                '<div class="learning-hint-text">å»ºè®® ' + parts.join(' Â· ') + 'ã€‚' + current + 'ï¼ˆä¸å½±å“é˜…è¯»ï¼‰</div>',
	                '</div>'
	            ].join('');

	            updateLearningHintsVisibility();
	        }

	        function scanRequiredReferenceHeadings(sourceMarkdown) {
	            const text = String(sourceMarkdown || '');
	            const requiredGroups = [
	                { label: 'æœ¬ç« è¦ç‚¹', options: ['æœ¬ç« è¦ç‚¹', 'å°ç»“'] },
	                { label: 'å¸¸è§å‘', options: ['å¸¸è§å‘', 'å¸¸è§é—®é¢˜'] },
	                { label: 'ä¸‹ä¸€æ­¥', options: ['ä¸‹ä¸€æ­¥'] }
	            ];

	            function escapeRegExp(s) {
	                return String(s || '').replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
	            }

	            const missing = [];
	            requiredGroups.forEach(function (group) {
	                const ok = (group.options || []).some(function (h) {
	                    const re = new RegExp('^##\\s+' + escapeRegExp(h) + '\\s*$', 'm');
	                    return re.test(text);
	                });
	                if (!ok) missing.push(group.label);
	            });
	            return missing;
	        }

	        function collectAuthorDiagnostics(diag, rawMetadata, metadata, filePath, rawContent) {
	            if (!diag) return;

	            const originalTitle = rawMetadata && rawMetadata.title ? String(rawMetadata.title).trim() : '';
	            if (!originalTitle) {
	                diag.metadata.warnings.push('ç¼ºå°‘ YAML å…ƒæ•°æ®å­—æ®µï¼štitle');
	            }

	            const hasMinC = rawMetadata && typeof rawMetadata.min_c === 'number';
	            const hasMinT = rawMetadata && typeof rawMetadata.min_t === 'number';
	            if (!hasMinC && !hasMinT) {
	                diag.metadata.warnings.push('æœªæ ‡æ³¨å»ºè®®é—¨æ§›ï¼šmin_c / min_tï¼ˆè½¯å»ºè®®ï¼Œä¸å½±å“é˜…è¯»ï¼‰');
	            }

	            const missingHeadings = scanRequiredReferenceHeadings(rawContent);
	            if (missingHeadings.length) {
	                diag.structure.warnings.push('ç¼ºå°‘ç¡¬è§„èŒƒæ ‡é¢˜ï¼š' + missingHeadings.join(' / '));
	            }

	            const prev = metadata && metadata.prev_chapter ? String(metadata.prev_chapter) : '';
	            const next = metadata && metadata.next_chapter ? String(metadata.next_chapter) : '';
	            if (prev) {
	                const resolvedPrev = resolveDocLinkPath(prev, filePath) || resolveRelativeHref(prev, filePath);
	                if (!isIndexedDocPath(resolvedPrev, filePath)) {
	                    diag.metadata.warnings.push('prev_chapter æ— æ³•è§£æåˆ°ç´¢å¼•å†…æ–‡æ¡£ï¼š' + prev);
	                }
	            }
	            if (next) {
	                const resolvedNext = resolveDocLinkPath(next, filePath) || resolveRelativeHref(next, filePath);
	                if (!isIndexedDocPath(resolvedNext, filePath)) {
	                    diag.metadata.warnings.push('next_chapter æ— æ³•è§£æåˆ°ç´¢å¼•å†…æ–‡æ¡£ï¼š' + next);
	                }
	            }
	        }

	        function renderLearningAuthorHeaderHint(diag) {
	            const node = document.getElementById('learning-hint-author');
	            if (!node) return;
	            if (!isLearningAuthorModeEnabled() || !diag) {
	                node.innerHTML = '';
	                updateLearningHintsVisibility();
	                return;
	            }

	            const warnCount =
	                (diag.metadata.warnings || []).length +
	                (diag.structure.warnings || []).length +
	                (diag.transclusion.errors || []).length +
	                (diag.condition.errors || []).length;

	            if (warnCount <= 0) {
	                node.innerHTML = '';
	                updateLearningHintsVisibility();
	                return;
	            }

	            const top = []
	                .concat(diag.metadata.warnings || [])
	                .concat(diag.structure.warnings || [])
	                .slice(0, 2)
	                .map(escapeHtmlAttribute);

	            node.innerHTML = [
	                '<div class="learning-hint-card learning-author-hint">',
	                '<div class="learning-hint-title">ä½œè€…æ¨¡å¼æç¤º</div>',
	                '<div class="learning-hint-text">æœ¬é¡µæ£€æµ‹åˆ° ' + warnCount + ' æ¡è¯Šæ–­ä¿¡æ¯ï¼š' + (top.length ? top.join('ï¼›') : '') + '</div>',
	                '</div>'
	            ].join('');
	            updateLearningHintsVisibility();
	        }

	        function scanDocLinksFromDom(container, currentDocPath) {
	            const errors = [];
	            if (!container) return errors;

	            const anchors = Array.from(container.querySelectorAll('a[href]')).slice(0, 200);
	            anchors.forEach(function (a) {
	                const href = String(a.getAttribute('href') || '');
	                if (!href) return;
	                if (href.startsWith('#')) return;
	                if (/^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(href)) return;

	                try {
	                    if (href.includes('viewer.html') && href.includes('file=')) {
	                        const u = new URL(href, window.location.href);
	                        const file = u.searchParams.get('file');
	                        if (!file) return;
	                        let decoded = file;
	                        try { decoded = decodeURIComponent(file); } catch { decoded = file; }
	                        decoded = decoded.replace(/^\.?\//, '').replace(/^docs\//, '');
	                        if (!isIndexedDocPath(decoded, currentDocPath)) {
	                            errors.push({ href, message: 'é“¾æ¥æŒ‡å‘çš„æ–‡æ¡£æœªè¢«ç´¢å¼•: ' + decoded });
	                        }
	                        return;
	                    }

	                    if (href.endsWith('.md') || href.includes('.md#')) {
	                        const base = splitHash(href).base || href;
	                        const resolved = resolveDocLinkPath(base, currentDocPath) || resolveRelativeHref(base, currentDocPath);
	                        if (!isIndexedDocPath(resolved, currentDocPath)) {
	                            errors.push({ href, message: 'Markdown é“¾æ¥æ— æ³•è§£æåˆ°ç´¢å¼•å†…æ–‡æ¡£: ' + href });
	                        }
	                    }
	                } catch (e) {
	                    errors.push({ href, message: 'é“¾æ¥è§£æå¤±è´¥: ' + String(e && e.message ? e.message : e) });
	                }
	            });

	            return errors;
	        }

	        async function scanImagesFromDom(container) {
	            const errors = [];
	            if (!container) return errors;

	            const imgs = Array.from(container.querySelectorAll('img[src]')).slice(0, 25);
	            for (const img of imgs) {
	                const srcRaw = String(img.getAttribute('src') || '').trim();
	                if (!srcRaw) continue;
	                if (srcRaw.startsWith('data:')) continue;
	                if (/^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(srcRaw)) continue;

	                try {
	                    const url = new URL(srcRaw, window.location.href).toString();
	                    const resp = await fetch(url, { cache: 'no-cache' });
	                    if (!resp.ok) {
	                        errors.push({ src: srcRaw, status: resp.status, message: 'å›¾ç‰‡è¯·æ±‚å¤±è´¥: ' + resp.status });
	                    }
	                } catch (e) {
	                    errors.push({ src: srcRaw, status: 0, message: 'å›¾ç‰‡è¯·æ±‚å¼‚å¸¸: ' + String(e && e.message ? e.message : e) });
	                }
	            }

	            return errors;
	        }

		        function renderLearningAuthorPanel(diag, container, currentDocPath) {
		            const section = document.getElementById('learning-author-diagnostics');
		            const panel = document.getElementById('learning-author-panel');
		            if (!panel) return;

		            if (!diag) {
		                panel.innerHTML = '';
		                if (section) section.style.display = 'none';
		                return;
		            }

		            if (section) section.style.display = 'block';

	            if (!isLearningAuthorModeEnabled() || !diag) {
	                panel.innerHTML = '';
	                panel.style.display = 'none';
	                return;
	            }

	            panel.style.display = 'block';

	            const warnings = []
	                .concat(diag.metadata.warnings || [])
	                .concat(diag.structure.warnings || []);

	            const errorCount = (diag.transclusion.errors || []).length + (diag.condition.errors || []).length + (diag.links.mdLinkErrors || []).length + (diag.links.imageErrors || []).length;
	            const warnCount = warnings.length;

	            function listItems(items, mapper) {
	                const arr = Array.isArray(items) ? items : [];
	                if (!arr.length) return '<div class="learning-diag-empty">æ— </div>';
	                return '<ul class="learning-diag-list">' + arr.slice(0, 50).map(function (x) {
	                    return '<li>' + escapeHtmlAttribute(mapper ? mapper(x) : x) + '</li>';
	                }).join('') + '</ul>';
	            }

	            panel.innerHTML = [
	                '<div class="learning-diag-summary">',
	                '<div class="learning-diag-kv"><span>è­¦å‘Š</span><span>' + warnCount + '</span></div>',
	                '<div class="learning-diag-kv"><span>é”™è¯¯</span><span>' + errorCount + '</span></div>',
	                '</div>',

	                '<details class="learning-diag-block" open>',
	                '<summary>å…ƒæ•°æ® / ç»“æ„</summary>',
	                listItems(warnings),
	                '</details>',

	                '<details class="learning-diag-block">',
	                '<summary>å¼•ç”¨å±•å¼€</summary>',
	                listItems(diag.transclusion.errors, function (e) { return (e.from ? '[' + e.from + '] ' : '') + (e.target ? e.target + 'ï¼š' : '') + e.message; }),
	                '</details>',

	                '<details class="learning-diag-block">',
	                '<summary>æ¡ä»¶åˆ†æµç»Ÿè®¡</summary>',
	                '<div class="learning-diag-mono">blocks=' + Number(diag.condition.blocks || 0) +
	                    ' Â· if=' + Number(diag.condition.directives.if || 0) +
	                    ' Â· elseif=' + Number(diag.condition.directives.elseif || 0) +
	                    ' Â· else=' + Number(diag.condition.directives.else || 0) +
	                    ' Â· end=' + Number(diag.condition.directives.end || 0) +
	                    ' Â· removedLines=' + Number(diag.condition.removedLines || 0) + '</div>',
	                listItems(diag.condition.errors, function (e) { return (e.expr ? e.expr + 'ï¼š' : '') + e.message; }),
	                '</details>',

	                '<details class="learning-diag-block">',
	                '<summary>é“¾æ¥ / èµ„æº</summary>',
	                '<div class="learning-diag-actions">',
	                '<button type="button" class="btn btn-small btn-outline" data-action="scan-links">æ‰«æé“¾æ¥</button>',
	                '<button type="button" class="btn btn-small btn-outline" data-action="scan-images">æ‰«æå›¾ç‰‡ï¼ˆå‘è¯·æ±‚ï¼‰</button>',
	                '</div>',
	                '<div class="learning-diag-mono">' + (diag.links.scannedAt ? ('ä¸Šæ¬¡æ‰«æï¼š' + escapeHtmlAttribute(diag.links.scannedAt)) : 'å°šæœªæ‰«æ') + '</div>',
	                '<div class="learning-diag-subtitle">æ–‡æ¡£é“¾æ¥</div>',
	                listItems(diag.links.mdLinkErrors, function (e) { return e.message; }),
	                '<div class="learning-diag-subtitle">å›¾ç‰‡</div>',
	                listItems(diag.links.imageErrors, function (e) { return (e.src ? e.src + 'ï¼š' : '') + e.message; }),
	                '</details>'
	            ].join('');

	            const scanLinks = panel.querySelector('[data-action="scan-links"]');
	            if (scanLinks) {
	                scanLinks.addEventListener('click', function () {
	                    diag.links.mdLinkErrors = scanDocLinksFromDom(container, currentDocPath);
	                    diag.links.scannedAt = new Date().toISOString();
	                    renderLearningAuthorPanel(diag, container, currentDocPath);
	                });
	            }

	            const scanImagesBtn = panel.querySelector('[data-action="scan-images"]');
	            if (scanImagesBtn) {
	                scanImagesBtn.addEventListener('click', async function () {
	                    scanImagesBtn.disabled = true;
	                    scanImagesBtn.textContent = 'æ‰«æä¸­...';
	                    try {
	                        diag.links.imageErrors = await scanImagesFromDom(container);
	                        diag.links.scannedAt = new Date().toISOString();
	                    } finally {
	                        scanImagesBtn.disabled = false;
	                        scanImagesBtn.textContent = 'æ‰«æå›¾ç‰‡ï¼ˆå‘è¯·æ±‚ï¼‰';
	                        renderLearningAuthorPanel(diag, container, currentDocPath);
	                    }
	                });
	            }
	        }

		        function renderLearningSidebarPanel(model) {
		            const root = document.getElementById('learning-sidebar-panel');
		            if (!root) return;

	            const ctx = model && model.ctx ? model.ctx : {};
	            const overrides = model && model.overrides ? model.overrides : {};
	            const autoFlags = model && model.autoFlags ? model.autoFlags : {};
	            const authorMode = Boolean(model && model.authorMode);

	            function escapeHtml(s) {
	                return String(s || '')
	                    .replace(/&/g, '&amp;')
	                    .replace(/</g, '&lt;')
	                    .replace(/>/g, '&gt;')
	                    .replace(/"/g, '&quot;')
	                    .replace(/'/g, '&#039;');
	            }

	            const rows = LEARNING_PREF_KEYS.map(function (p) {
	                const key = p.key;
	                const tri = normalizeTriState(overrides[key]);
	                const final = Number(ctx[key] || 0) ? 1 : 0;
	                const auto = Number(autoFlags[key] || 0) ? 1 : 0;
	                const source = tri === 'auto' ? ('è‡ªåŠ¨ï¼š' + (auto ? 'å¼€' : 'å…³')) : ('æ‰‹åŠ¨ï¼š' + (tri === 'on' ? 'å¼€' : 'å…³'));
	                return [
	                    '<div class="learning-pref-row">',
	                    '<div class="learning-pref-main">',
	                    '<div class="learning-pref-name" title="' + escapeHtml(p.description) + '">' + escapeHtml(p.label) + '</div>',
	                    '<div class="learning-pref-meta">' + escapeHtml(key) + ' Â· ' + escapeHtml(source) + '</div>',
	                    '</div>',
	                    '<div class="learning-pref-control">',
	                    '<select class="learning-pref-select" data-pref-key="' + escapeHtml(key) + '">',
	                    '<option value="auto"' + (tri === 'auto' ? ' selected' : '') + '>è‡ªåŠ¨</option>',
	                    '<option value="on"' + (tri === 'on' ? ' selected' : '') + '>å¼ºåˆ¶å¼€</option>',
	                    '<option value="off"' + (tri === 'off' ? ' selected' : '') + '>å¼ºåˆ¶å…³</option>',
	                    '</select>',
	                    '<span class="learning-pref-badge ' + (final ? 'on' : 'off') + '">' + (final ? 'å¼€' : 'å…³') + '</span>',
	                    '</div>',
	                    '</div>'
	                ].join('');
	            }).join('');

		            root.innerHTML = [
		                '<div class="learning-ct">',
		                '<div class="learning-ct-title">å½“å‰æ¡£ä½</div>',
		                '<div class="learning-ct-value">C' + Number(ctx.C || 0) + ' / T' + Number(ctx.T || 0) + '</div>',
		                '<div class="learning-ct-actions">',
		                '<a class="btn btn-small btn-outline" href="' + getOnboardingUrlFromViewer() + '">é‡æ–°æµ‹è¯„</a>',
		                '<button type="button" class="btn btn-small btn-secondary" data-action="reset-prefs">åå¥½å…¨è®¾ä¸ºè‡ªåŠ¨</button>',
		                '</div>',
		                '</div>',
		                '<div class="learning-pref-list">',
		                rows,
		                '</div>'
		            ].join('');

	            const resetBtn = root.querySelector('[data-action="reset-prefs"]');
	            if (resetBtn) {
	                resetBtn.addEventListener('click', function () {
	                    const next = readLearningPreferenceOverrides();
	                    LEARNING_PREF_KEYS.forEach(function (p) { next[p.key] = 'auto'; });
	                    writeLearningPreferenceOverrides(next);
	                    rerenderCurrentDocPreserveScroll();
	                });
	            }

	            root.querySelectorAll('select[data-pref-key]').forEach(function (sel) {
	                sel.addEventListener('change', function () {
	                    const k = String(sel.getAttribute('data-pref-key') || '');
	                    const v = normalizeTriState(sel.value);
	                    const next = readLearningPreferenceOverrides();
	                    next[k] = v;
	                    writeLearningPreferenceOverrides(next);
	                    rerenderCurrentDocPreserveScroll();
	                });
	            });

		            renderLearningAuthorToolbar();
		        }

		        function renderLearningAuthorToolbar() {
		            const btn = document.getElementById('author-mode-toggle');
		            if (!btn) return;
		            const enabled = isLearningAuthorModeEnabled();
		            btn.setAttribute('aria-pressed', enabled ? 'true' : 'false');
		            btn.textContent = enabled ? 'ä½œè€…æ¨¡å¼ï¼šå¼€' : 'ä½œè€…æ¨¡å¼ï¼šå…³';
		        }

	        function rerenderCurrentDocPreserveScroll() {
	            const file = CURRENT_DOC_PATH || (new URL(window.location.href)).searchParams.get('file');
	            if (!file || typeof loadMarkdownDirectly !== 'function') return;
	            const y = window.scrollY || 0;
	            loadMarkdownDirectly(file);
	            const restore = function () {
	                window.scrollTo(0, y);
	                document.removeEventListener('viewer:content-ready', restore);
	            };
	            document.addEventListener('viewer:content-ready', restore);
	        }

	        function tokenizeLearningCondition(expr) {
	            const s = String(expr || '');
	            const tokens = [];
	            let i = 0;

	            function isWs(ch) {
	                return ch === ' ' || ch === '\t' || ch === '\n' || ch === '\r';
	            }

	            while (i < s.length) {
	                const ch = s[i];
	                if (isWs(ch)) {
	                    i += 1;
	                    continue;
	                }

	                const two = s.slice(i, i + 2);
	                if (two === '&&' || two === '||' || two === '>=' || two === '<=' || two === '==' || two === '!=') {
	                    tokens.push({ type: 'op', value: two });
	                    i += 2;
	                    continue;
	                }

	                if (ch === '>' || ch === '<' || ch === '!' || ch === '(' || ch === ')') {
	                    if (ch === '(' || ch === ')') {
	                        tokens.push({ type: 'paren', value: ch });
	                    } else {
	                        tokens.push({ type: 'op', value: ch });
	                    }
	                    i += 1;
	                    continue;
	                }

	                if (ch >= '0' && ch <= '9') {
	                    let j = i + 1;
	                    while (j < s.length && s[j] >= '0' && s[j] <= '9') j += 1;
	                    tokens.push({ type: 'num', value: Number.parseInt(s.slice(i, j), 10) });
	                    i = j;
	                    continue;
	                }

	                if ((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || ch === '_') {
	                    let j = i + 1;
	                    while (j < s.length) {
	                        const cj = s[j];
	                        const ok =
	                            (cj >= 'A' && cj <= 'Z') ||
	                            (cj >= 'a' && cj <= 'z') ||
	                            (cj >= '0' && cj <= '9') ||
	                            cj === '_';
	                        if (!ok) break;
	                        j += 1;
	                    }
	                    const ident = s.slice(i, j);
	                    tokens.push({ type: 'id', value: ident });
	                    i = j;
	                    continue;
	                }

	                throw new Error('æ— æ³•è¯†åˆ«çš„å­—ç¬¦: ' + ch);
	            }

	            return tokens;
	        }

	        function evaluateLearningCondition(expr, ctx) {
	            const tokens = tokenizeLearningCondition(expr);
	            const output = [];
	            const ops = [];

	            function precedence(op) {
	                if (op === '!') return 4;
	                if (op === '>' || op === '<' || op === '>=' || op === '<=' || op === '==' || op === '!=') return 3;
	                if (op === '&&') return 2;
	                if (op === '||') return 1;
	                return 0;
	            }

	            function isRightAssociative(op) {
	                return op === '!';
	            }

	            tokens.forEach(function (t) {
	                if (t.type === 'num' || t.type === 'id') {
	                    output.push(t);
	                    return;
	                }
	                if (t.type === 'paren') {
	                    if (t.value === '(') {
	                        ops.push(t);
	                        return;
	                    }
	                    while (ops.length && ops[ops.length - 1].type !== 'paren') {
	                        output.push(ops.pop());
	                    }
	                    if (!ops.length) throw new Error('æ‹¬å·ä¸åŒ¹é…');
	                    ops.pop();
	                    return;
	                }
	                if (t.type === 'op') {
	                    while (ops.length) {
	                        const top = ops[ops.length - 1];
	                        if (top.type !== 'op') break;
	                        const p1 = precedence(t.value);
	                        const p2 = precedence(top.value);
	                        const shouldPop = isRightAssociative(t.value) ? (p1 < p2) : (p1 <= p2);
	                        if (!shouldPop) break;
	                        output.push(ops.pop());
	                    }
	                    ops.push(t);
	                    return;
	                }
	            });

	            while (ops.length) {
	                const op = ops.pop();
	                if (op.type === 'paren') throw new Error('æ‹¬å·ä¸åŒ¹é…');
	                output.push(op);
	            }

	            const stack = [];
	            function toBool(v) { return Boolean(v); }
	            function toNum(v) { return typeof v === 'number' ? v : (toBool(v) ? 1 : 0); }

	            output.forEach(function (t) {
	                if (t.type === 'num') {
	                    stack.push(t.value);
	                    return;
	                }
	                if (t.type === 'id') {
	                    const rawId = String(t.value || '').trim();
	                    const id = rawId.toUpperCase();
	                    if (id === 'C') stack.push(Number(ctx && ctx.C != null ? ctx.C : 0));
	                    else if (id === 'T') stack.push(Number(ctx && ctx.T != null ? ctx.T : 0));
	                    else if (id === 'AUTHOR') stack.push(Number(ctx && ctx.AUTHOR != null ? ctx.AUTHOR : 0));
	                    else if (id.startsWith('P_')) {
	                        const v =
	                            (ctx && ctx[id] != null ? ctx[id] : undefined) ??
	                            (ctx && ctx[rawId] != null ? ctx[rawId] : undefined);
	                        stack.push(Number(v || 0));
	                    } else {
	                        throw new Error('æœªçŸ¥å˜é‡: ' + t.value);
	                    }
	                    return;
	                }
	                if (t.type === 'op') {
	                    const op = t.value;
	                    if (op === '!') {
	                        if (stack.length < 1) throw new Error('è¡¨è¾¾å¼ç¼ºå°‘æ“ä½œæ•°');
	                        const a = stack.pop();
	                        stack.push(!toBool(a));
	                        return;
	                    }
	                    if (stack.length < 2) throw new Error('è¡¨è¾¾å¼ç¼ºå°‘æ“ä½œæ•°');
	                    const b = stack.pop();
	                    const a = stack.pop();
	                    if (op === '&&') stack.push(toBool(a) && toBool(b));
	                    else if (op === '||') stack.push(toBool(a) || toBool(b));
	                    else if (op === '>') stack.push(toNum(a) > toNum(b));
	                    else if (op === '<') stack.push(toNum(a) < toNum(b));
	                    else if (op === '>=') stack.push(toNum(a) >= toNum(b));
	                    else if (op === '<=') stack.push(toNum(a) <= toNum(b));
	                    else if (op === '==') stack.push(toNum(a) === toNum(b));
	                    else if (op === '!=') stack.push(toNum(a) !== toNum(b));
	                    else throw new Error('æœªçŸ¥æ“ä½œç¬¦: ' + op);
	                    return;
	                }
	            });

	            if (stack.length !== 1) throw new Error('è¡¨è¾¾å¼è§£æå¤±è´¥');
	            return Boolean(stack[0]);
	        }

	        function applyLearningConditionBlocks(markdown, ctx) {
	            const diag = getCurrentLearningDiagnostics();
	            const lines = String(markdown || '').split('\n');
	            const out = [];
	            const stack = [];
	            const IF_RE = /^\s*\{if\s+(.+?)\}\s*$/;
	            const ELSEIF_RE = /^\s*\{else\s+if\s+(.+?)\}\s*$/;
	            const ELSE_RE = /^\s*\{else\}\s*$/;
	            const END_RE = /^\s*\{end\}\s*$/;

	            let inFence = false;
	            let fenceChar = '';

	            function currentActive() {
	                if (!stack.length) return true;
	                return Boolean(stack[stack.length - 1].active);
	            }

	            if (diag && diag.condition) {
	                diag.condition.blocks += 1;
	                diag.condition.inputLines += lines.length;
	            }

	            for (let i = 0; i < lines.length; i++) {
	                const line = lines[i];
	                const fenceMatch = line.match(/^\s*(```+|~~~+)\s*/);
	                if (fenceMatch) {
	                    const currentFence = fenceMatch[1][0];
	                    if (!inFence) {
	                        inFence = true;
	                        fenceChar = currentFence;
	                    } else if (fenceChar === currentFence) {
	                        inFence = false;
	                        fenceChar = '';
	                    }
	                    if (currentActive()) out.push(line);
	                    continue;
	                }

	                if (inFence) {
	                    if (currentActive()) out.push(line);
	                    continue;
	                }

	                const ifMatch = line.match(IF_RE);
	                if (ifMatch) {
	                    if (diag && diag.condition) diag.condition.directives.if += 1;
	                    const parentActive = currentActive();
	                    let ok = false;
	                    if (parentActive) {
	                        try {
	                            ok = evaluateLearningCondition(ifMatch[1], ctx);
	                        } catch (e) {
	                            console.warn('æ¡ä»¶è¡¨è¾¾å¼è§£æå¤±è´¥:', ifMatch[1], e);
	                            if (diag && diag.condition) {
	                                diag.condition.errors.push({
	                                    expr: ifMatch[1],
	                                    message: String(e && e.message ? e.message : e)
	                                });
	                            }
	                            ok = false;
	                        }
	                    }
	                    stack.push({
	                        parentActive: parentActive,
	                        branchTaken: ok,
	                        inElse: false,
	                        active: parentActive && ok
	                    });
	                    continue;
	                }

	                const elseifMatch = line.match(ELSEIF_RE);
	                if (elseifMatch) {
	                    if (diag && diag.condition) diag.condition.directives.elseif += 1;
	                    if (!stack.length) {
	                        if (currentActive()) out.push(line);
	                        continue;
	                    }
	                    const top = stack[stack.length - 1];
	                    if (top.inElse) {
	                        top.active = false;
	                        continue;
	                    }
	                    if (!top.parentActive || top.branchTaken) {
	                        top.active = false;
	                        continue;
	                    }
	                    let ok = false;
	                    try {
	                        ok = evaluateLearningCondition(elseifMatch[1], ctx);
	                    } catch (e) {
	                        console.warn('æ¡ä»¶è¡¨è¾¾å¼è§£æå¤±è´¥:', elseifMatch[1], e);
	                        if (diag && diag.condition) {
	                            diag.condition.errors.push({
	                                expr: elseifMatch[1],
	                                message: String(e && e.message ? e.message : e)
	                            });
	                        }
	                        ok = false;
	                    }
	                    top.branchTaken = Boolean(top.branchTaken || ok);
	                    top.active = top.parentActive && ok;
	                    continue;
	                }

	                if (line.match(ELSE_RE)) {
	                    if (diag && diag.condition) diag.condition.directives.else += 1;
	                    if (!stack.length) {
	                        if (currentActive()) out.push(line);
	                        continue;
	                    }
	                    const top = stack[stack.length - 1];
	                    if (top.inElse) {
	                        top.active = false;
	                        continue;
	                    }
	                    top.inElse = true;
	                    top.active = top.parentActive && !top.branchTaken;
	                    top.branchTaken = true;
	                    continue;
	                }

	                if (line.match(END_RE)) {
	                    if (diag && diag.condition) diag.condition.directives.end += 1;
	                    if (!stack.length) {
	                        if (currentActive()) out.push(line);
	                        continue;
	                    }
	                    stack.pop();
	                    continue;
	                }

	                if (currentActive()) out.push(line);
	            }

	            if (diag && diag.condition) {
	                diag.condition.outputLines += out.length;
	                diag.condition.removedLines += Math.max(0, lines.length - out.length);
	            }

	            return out.join('\n');
	        }

		        function isUnsafeTransclusionTarget(target) {
		            const value = String(target || '');
		            return (
		                !value ||
		                value.includes('\0') ||
		                value.includes('\\') ||
		                value.startsWith('/') ||
		                /^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(value)
		            );
		        }

	        function splitHash(href) {
	            const raw = String(href || '');
	            const hashIndex = raw.indexOf('#');
	            if (hashIndex < 0) return { base: raw, hash: '' };
	            return { base: raw.slice(0, hashIndex), hash: raw.slice(hashIndex) };
	        }

	        function normalizeHeadingForMatch(text) {
	            let t = String(text || '').trim();
	            if (!t) return '';
	            t = t
	                .replace(/!\[([^\]]*)\]\([^)]+\)/g, '$1')
	                .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
	                .replace(/[`*_~]/g, '')
	                .replace(/\s+/g, ' ')
	                .trim()
	                .toLowerCase();
	            return t;
	        }

	        function extractMarkdownSectionByHeading(markdown, selector) {
	            const selRaw = String(selector || '').trim();
	            if (!selRaw) return null;
	            const sel = normalizeHeadingForMatch(selRaw);
	            if (!sel) return null;

	            const lines = String(markdown || '').split('\n');
	            let inFence = false;
	            let fenceChar = '';

	            let startIndex = -1;
	            let startLevel = 0;

	            for (let i = 0; i < lines.length; i++) {
	                const line = lines[i];
	                const fenceMatch = line.match(/^\s*(```+|~~~+)\s*/);
	                if (fenceMatch) {
	                    const currentFence = fenceMatch[1][0];
	                    if (!inFence) {
	                        inFence = true;
	                        fenceChar = currentFence;
	                    } else if (fenceChar === currentFence) {
	                        inFence = false;
	                        fenceChar = '';
	                    }
	                    continue;
	                }
	                if (inFence) continue;

	                const headingMatch = line.match(/^(#{1,6})\s+(.*)$/);
	                if (!headingMatch) continue;

	                const level = headingMatch[1].length;
	                const rawText = String(headingMatch[2] || '').trim().replace(/\s+#*$/, '').trim();
	                const normalized = normalizeHeadingForMatch(rawText);
	                if (!normalized) continue;

	                if (startIndex < 0) {
	                    if (normalized === sel) {
	                        startIndex = i + 1; // exclude the heading line itself
	                        startLevel = level;
	                    }
	                    continue;
	                }

	                if (level <= startLevel) {
	                    const chunk = lines.slice(startIndex, i).join('\n');
	                    return chunk.replace(/^\s*\n+/, '').replace(/\n+\s*$/, '');
	                }
	            }

	            if (startIndex >= 0) {
	                const chunk = lines.slice(startIndex).join('\n');
	                return chunk.replace(/^\s*\n+/, '').replace(/\n+\s*$/, '');
	            }

	            return null;
	        }

	        function stripLeadingTitleHeading(markdown, titles) {
	            const titleSet = new Set(
	                (titles || [])
	                    .map(t => String(t || '').trim())
	                    .filter(Boolean)
	                    .map(t => t.toLowerCase())
	            );
	            if (!titleSet.size) return markdown;

	            const lines = String(markdown || '').split('\n');
	            let i = 0;
	            while (i < lines.length && !lines[i].trim()) i++;
	            if (i >= lines.length) return markdown;

	            const m = lines[i].match(/^#\s+(.*)$/);
	            if (!m) return markdown;

	            const headingText = String(m[1] || '').trim().toLowerCase();
	            if (!titleSet.has(headingText)) return markdown;

	            lines.splice(i, 1);
	            while (i < lines.length && !lines[i].trim()) lines.splice(i, 1);
	            return lines.join('\n');
	        }

	        function shiftMarkdownHeadings(markdown, shift) {
	            const delta = Number.isFinite(shift) ? shift : 0;
	            if (delta <= 0) return markdown;

	            const lines = String(markdown || '').split('\n');
	            let inFence = false;
	            let fenceChar = '';

	            for (let i = 0; i < lines.length; i++) {
	                const line = lines[i];
	                const fenceMatch = line.match(/^\s*(```+|~~~+)\s*/);
	                if (fenceMatch) {
	                    const currentFence = fenceMatch[1][0];
	                    if (!inFence) {
	                        inFence = true;
	                        fenceChar = currentFence;
	                    } else if (fenceChar === currentFence) {
	                        inFence = false;
	                        fenceChar = '';
	                    }
	                    continue;
	                }

	                if (inFence) continue;
	                const headingMatch = line.match(/^(#{1,6})(\s+.*)$/);
	                if (!headingMatch) continue;

	                const current = headingMatch[1].length;
	                const next = Math.min(6, current + delta);
	                lines[i] = `${'#'.repeat(next)}${headingMatch[2]}`;
	            }

	            return lines.join('\n');
	        }

	        function getMarkdownMinHeadingLevel(markdown) {
	            const lines = String(markdown || '').split('\n');
	            let inFence = false;
	            let fenceChar = '';
	            let minLevel = 0;

	            for (let i = 0; i < lines.length; i++) {
	                const line = lines[i];
	                const fenceMatch = line.match(/^\s*(```+|~~~+)\s*/);
	                if (fenceMatch) {
	                    const currentFence = fenceMatch[1][0];
	                    if (!inFence) {
	                        inFence = true;
	                        fenceChar = currentFence;
	                    } else if (fenceChar === currentFence) {
	                        inFence = false;
	                        fenceChar = '';
	                    }
	                    continue;
	                }
	                if (inFence) continue;

	                const headingMatch = line.match(/^(#{1,6})\s+.*$/);
	                if (!headingMatch) continue;
	                const level = headingMatch[1].length;
	                if (!minLevel || level < minLevel) minLevel = level;
	                if (minLevel === 1) return 1;
	            }

	            return minLevel;
	        }

	        function demoteMarkdownHeadingsToBold(markdown) {
	            const lines = String(markdown || '').split('\n');
	            let inFence = false;
	            let fenceChar = '';

	            for (let i = 0; i < lines.length; i++) {
	                const line = lines[i];
	                const fenceMatch = line.match(/^\s*(```+|~~~+)\s*/);
	                if (fenceMatch) {
	                    const currentFence = fenceMatch[1][0];
	                    if (!inFence) {
	                        inFence = true;
	                        fenceChar = currentFence;
	                    } else if (fenceChar === currentFence) {
	                        inFence = false;
	                        fenceChar = '';
	                    }
	                    continue;
	                }
	                if (inFence) continue;

	                const headingMatch = line.match(/^(#{1,6})\s+(.*)$/);
	                if (!headingMatch) continue;
	                const text = String(headingMatch[2] || '').trim().replace(/\s+#*$/, '').trim();
	                if (!text) continue;
	                lines[i] = `**${text}**`;
	            }

	            return lines.join('\n');
	        }

	        function rewriteTranscludedLinksAndImages(markdown, includeDocPath) {
	            const lines = String(markdown || '').split('\n');
	            let inFence = false;
	            let fenceChar = '';

	            function resolveImageAbsolute(src) {
	                if (!src) return src;
	                const raw = String(src);
	                if (
	                    raw.startsWith('#') ||
	                    raw.startsWith('/') ||
	                    /^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(raw)
	                ) return raw;

	                const resolved = resolveRelativeHref(raw, includeDocPath);
	                if (!resolved) return raw;

	                const cleaned = String(resolved).replace(/^\.?\//, '');
	                if (cleaned.startsWith('assets/')) return `/${cleaned}`;
	                return `/docs/${cleaned}`;
	            }

	            function rewriteInlineLink(line) {
	                // å›¾ç‰‡ï¼š![alt](src "title")
	                line = line.replace(/!\[([^\]]*)\]\(([^)\s]+)(\s+\"[^\"]*\")?\)/g, (m, alt, href, title) => {
	                    const fixed = resolveImageAbsolute(href);
	                    return `![${alt}](${fixed}${title || ''})`;
	                });

	                // é“¾æ¥ï¼š[text](href "title")
	                line = line.replace(/(^|[^!])\[([^\]]+)\]\(([^)\s]+)(\s+\"[^\"]*\")?\)/g, (m, prefix, text, href, title) => {
	                    const hrefStr = String(href || '');
	                    const { base, hash } = splitHash(hrefStr);
	                    const resolved = resolveDocLinkPath(base, includeDocPath);
	                    if (!resolved) return m;
	                    return `${prefix}[${text}](${resolved}${hash}${title || ''})`;
	                });

	                return line;
	            }

	            for (let i = 0; i < lines.length; i++) {
	                const line = lines[i];
	                const fenceMatch = line.match(/^\s*(```+|~~~+)\s*/);
	                if (fenceMatch) {
	                    const currentFence = fenceMatch[1][0];
	                    if (!inFence) {
	                        inFence = true;
	                        fenceChar = currentFence;
	                    } else if (fenceChar === currentFence) {
	                        inFence = false;
	                        fenceChar = '';
	                    }
	                    continue;
	                }

	                if (inFence) continue;
	                lines[i] = rewriteInlineLink(line);
	            }

	            return lines.join('\n');
	        }

	        async function fetchMarkdownDocText(docPath) {
	            const key = String(docPath || '');
	            if (!key) throw new Error('ç©ºçš„æ–‡æ¡£è·¯å¾„');

	            if (!TRANSCLUSION_CACHE.has(key)) {
	                const fetchUrl = `./${key.replace(/^\.?\//, '').replace(/^docs\//, '')}`;
	                const p = fetch(encodeURI(fetchUrl), { cache: 'no-store' }).then(async response => {
	                    if (!response.ok) {
	                        throw new Error(`HTTP ${response.status} ${response.statusText}`);
	                    }
	                    return await response.text();
	                });
	                TRANSCLUSION_CACHE.set(key, p);
	            }
	            return await TRANSCLUSION_CACHE.get(key);
	        }

		        async function expandMarkdownTransclusions(markdown, currentDocPath, depth = 0, stack = [], ctx) {
	            const diag = getCurrentLearningDiagnostics();
	            if (!markdown) return markdown;
	            if (depth > TRANSCLUSION_MAX_DEPTH) return markdown;

	            const lines = String(markdown).split('\n');
	            const matches = [];
	            let inFence = false;
	            let fenceChar = '';
	            let currentHeadingLevel = 1;

	            for (let i = 0; i < lines.length; i++) {
	                const line = lines[i];
	                const fenceMatch = line.match(/^\s*(```+|~~~+)\s*/);
	                if (fenceMatch) {
	                    const currentFence = fenceMatch[1][0];
	                    if (!inFence) {
	                        inFence = true;
	                        fenceChar = currentFence;
	                    } else if (fenceChar === currentFence) {
	                        inFence = false;
	                        fenceChar = '';
	                    }
	                    continue;
	                }

	                if (inFence) continue;
	                const headingMatch = line.match(/^(#{1,6})\s+.*$/);
	                if (headingMatch) {
	                    currentHeadingLevel = headingMatch[1].length;
	                    continue;
	                }
	                const m = line.match(TRANSCLUSION_LINE_RE);
	                if (!m) continue;
	                matches.push({
	                    lineIndex: i,
	                    target: String(m[1] || '').trim(),
	                    title: String(m[2] || '').trim(),
	                    wrapperLevel: Math.min(6, currentHeadingLevel + 1)
	                });
	                if (matches.length >= TRANSCLUSION_MAX_FILES) break;
	            }

	            if (diag && diag.transclusion) {
	                diag.transclusion.matchedLines += matches.length;
	                if (matches.length >= TRANSCLUSION_MAX_FILES) {
	                    diag.transclusion.errors.push({
	                        from: String(currentDocPath || ''),
	                        target: '',
	                        message: 'å¼•ç”¨è¡Œæ•°è¶…è¿‡ä¸Šé™ï¼ˆä»…å¤„ç†å‰ ' + TRANSCLUSION_MAX_FILES + ' ä¸ªï¼‰'
	                    });
	                }
	            }

		            if (!matches.length) return markdown;

		            function resolveTransclusionDocPath(rawBase) {
		                if (!rawBase) return null;
		                let resolved = resolveDocLinkPath(rawBase, currentDocPath);
		                if (!resolved) {
		                    const rel = resolveRelativeHref(rawBase, currentDocPath);
		                    resolved = String(rel || '');
		                }

		                resolved = normalizePath(String(resolved || '').replace(/^\.?\//, '').replace(/^docs\//, ''));
		                if (!resolved) return null;

		                if (!resolved.endsWith('.md')) resolved += '.md';

		                if (
		                    resolved.includes('\0') ||
		                    resolved.includes('\\') ||
		                    /(^|\/)\.\.(\/|$)/.test(resolved)
		                ) {
		                    return null;
		                }

		                if (!isIndexedDocPath(resolved, currentDocPath)) return null;
		                return resolved;
		            }

		            const replacements = await Promise.all(matches.map(async (m) => {
		                if (isUnsafeTransclusionTarget(m.target)) {
		                    if (diag && diag.transclusion) {
		                        diag.transclusion.errors.push({
	                            from: String(currentDocPath || ''),
	                            target: String(m.target || ''),
		                            message: 'éæ³•è·¯å¾„'
		                        });
		                    }
		                    return `\n\n> æ— æ³•è½½å…¥å¼•ç”¨ï¼šéæ³•è·¯å¾„ \`${m.target}\`\n\n`;
		                }

		                const { base, hash } = splitHash(m.target);
		                let sectionSelector = '';
	                if (hash && hash.startsWith('#')) {
	                    sectionSelector = hash.slice(1);
	                    try {
	                        sectionSelector = decodeURIComponent(sectionSelector);
	                    } catch (e) {
	                        sectionSelector = hash.slice(1);
		                    }
		                    sectionSelector = String(sectionSelector || '').trim();
		                }
		                const resolvedDoc = resolveTransclusionDocPath(base);
		                if (!resolvedDoc) {
		                    if (diag && diag.transclusion) {
		                        diag.transclusion.errors.push({
		                            from: String(currentDocPath || ''),
		                            target: String(m.target || ''),
		                            message: 'æ‰¾ä¸åˆ°æ–‡æ¡£'
		                        });
		                    }
		                    return `\n\n> æ— æ³•è½½å…¥å¼•ç”¨ï¼šæ‰¾ä¸åˆ°æ–‡æ¡£ \`${m.target}\`\n\n`;
		                }

		                if (stack.includes(resolvedDoc)) {
		                    if (diag && diag.transclusion) {
		                        diag.transclusion.errors.push({
	                            from: String(currentDocPath || ''),
	                            target: String(resolvedDoc || ''),
	                            message: 'æ£€æµ‹åˆ°å¾ªç¯å¼•ç”¨'
	                        });
	                    }
	                    return `\n\n> æ— æ³•è½½å…¥å¼•ç”¨ï¼šæ£€æµ‹åˆ°å¾ªç¯å¼•ç”¨ \`${resolvedDoc}\`\n\n`;
	                }

	                try {
	                    const rawText = await fetchMarkdownDocText(resolvedDoc);
	                    if (diag && diag.transclusion) {
	                        diag.transclusion.expandedCount += 1;
	                        diag.transclusion.includedDocs.push({
	                            from: String(currentDocPath || ''),
	                            doc: String(resolvedDoc || ''),
	                            selector: sectionSelector || ''
	                        });
	                    }
	                    const fm = parseFrontMatter(rawText);
	                    let body = fm.content || '';
	                    body = stripLeadingTitleHeading(body, [m.title, fm.metadata && fm.metadata.title]);
	                    body = applyLearningConditionBlocks(body, ctx);
	                    if (sectionSelector) {
	                        const extracted = extractMarkdownSectionByHeading(body, sectionSelector);
	                        if (extracted == null) {
	                            if (diag && diag.transclusion) {
	                                diag.transclusion.errors.push({
	                                    from: String(currentDocPath || ''),
	                                    target: String(resolvedDoc || ''),
	                                    message: 'æ‰¾ä¸åˆ°æ ‡é¢˜ï¼š' + String(sectionSelector || '')
	                                });
	                            }
	                            return `\n\n> æ— æ³•è½½å…¥å¼•ç”¨ï¼šåœ¨ \`${resolvedDoc}\` ä¸­æ‰¾ä¸åˆ°æ ‡é¢˜ \`${sectionSelector}\`\n\n`;
	                        }
	                        body = extracted;
	                    }
	                    body = rewriteTranscludedLinksAndImages(body, resolvedDoc);
	                    body = await expandMarkdownTransclusions(body, resolvedDoc, depth + 1, stack.concat(resolvedDoc), ctx);
	                    const rawTitle = String(m.title || '').trim();
	                    if (rawTitle.startsWith('!')) {
	                        const inlineTitle = rawTitle.slice(1).trim() || 'å¼•ç”¨å†…å®¹';
	                        if (!sectionSelector) {
	                            body = demoteMarkdownHeadingsToBold(body);
	                        }
	                        return `\n\n**${inlineTitle}**\n\n${body}\n\n`;
	                    }

	                    const wrapperLevel = Math.max(2, Math.min(6, Number(m.wrapperLevel) || 2));
	                    const wrapperHash = '#'.repeat(wrapperLevel);
	                    const minLevel = getMarkdownMinHeadingLevel(body);
	                    if (minLevel) {
	                        const desiredMin = Math.min(6, wrapperLevel + 1);
	                        const shift = Math.max(0, desiredMin - minLevel);
	                        body = shiftMarkdownHeadings(body, shift);
	                    }
	                    return `\n\n${wrapperHash} ${rawTitle}\n\n${body}\n\n`;
	                } catch (err) {
	                    if (diag && diag.transclusion) {
	                        diag.transclusion.errors.push({
	                            from: String(currentDocPath || ''),
	                            target: String(resolvedDoc || ''),
	                            message: String(err && err.message ? err.message : err)
	                        });
	                    }
	                    return `\n\n> æ— æ³•è½½å…¥å¼•ç”¨ï¼š\`${resolvedDoc}${hash || ''}\`ï¼ˆ${String(err && err.message ? err.message : err)}ï¼‰\n\n`;
	                }
	            }));

	            const byLine = new Map();
	            for (let i = 0; i < matches.length; i++) {
	                byLine.set(matches[i].lineIndex, replacements[i]);
	            }

	            const out = [];
	            for (let i = 0; i < lines.length; i++) {
	                if (byLine.has(i)) {
	                    out.push(byLine.get(i));
	                } else {
	                    out.push(lines[i]);
	                }
	            }
	            return out.join('\n');
	        }

        // ä½¿ç”¨æ–‡æ¡£ä¿¡æ¯æ›´æ–°é…ç½®
        function updateConfigWithDocument(docInfo) {
            const { category, topic } = docInfo;

            // ç¡®ä¿åˆ†ç±»å­˜åœ¨
            if (!VIEWER_DOC_CONFIG.categories[category]) {
                VIEWER_DOC_CONFIG.categories[category] = {
                    title: category,
                    description: `${category}ç›¸å…³æ–‡æ¡£`,
                    topics: {}
                };
            }

            // ç¡®ä¿ä¸»é¢˜å­˜åœ¨
            if (!VIEWER_DOC_CONFIG.categories[category].topics[topic]) {
                VIEWER_DOC_CONFIG.categories[category].topics[topic] = {
                    title: TOPIC_AREAS[topic]?.title || topic,
                    description: TOPIC_AREAS[topic]?.description || '',
                    files: []
                };
            }

            // æ·»åŠ æ–‡ä»¶åˆ°å¯¹åº”ä¸»é¢˜
            DOC_CONFIG.categories[category].topics[topic].files.push(docInfo);

            // æ›´æ–°ä½œè€…ä¿¡æ¯
            if (!VIEWER_DOC_CONFIG.authors[docInfo.author]) {
                VIEWER_DOC_CONFIG.authors[docInfo.author] = {
                    name: docInfo.author,
                    files: []
                };
            }
            VIEWER_DOC_CONFIG.authors[docInfo.author].files.push(docInfo.filename);

            // æ·»åŠ åˆ°æ‰€æœ‰æ–‡ä»¶åˆ—è¡¨
            VIEWER_DOC_CONFIG.all_files.push(docInfo);
        }
        // ç›´æ¥åŠ è½½Markdownå†…å®¹çš„å¤‡ç”¨å‡½æ•°
	        function loadMarkdownDirectly(filePath) {
	            const loadingIndicator = document.getElementById('loading-indicator');
	            const errorMessage = document.getElementById('error-message');
	            const markdownContent = document.getElementById('markdown-content');

                if (window.KnowledgeCards && typeof window.KnowledgeCards.reset === 'function') {
                    window.KnowledgeCards.reset();
                }

                if (loadingIndicator) {
                    loadingIndicator.style.display = 'block';
                    loadingIndicator.setAttribute('aria-busy', 'true');
                }
                if (errorMessage) {
                    errorMessage.style.display = 'none';
                    errorMessage.setAttribute('aria-hidden', 'true');
                }
                if (markdownContent) {
                    markdownContent.style.display = 'none';
                }

            console.log(`=== loadMarkdownDirectly() è¯Šæ–­å¼€å§‹ ===`);
            console.log(`docs/viewer.html: åŸå§‹æ–‡ä»¶è·¯å¾„: ${filePath}`);
            console.log('å½“å‰é¡µé¢ä½ç½®:', window.location.href);

	            try {
	                // å¢å¼ºçš„è·¯å¾„æ¸…ç†é€»è¾‘ï¼ˆä»…å…è®¸åŠ è½½ config.json åˆ—å‡ºçš„æ–‡æ¡£ï¼Œé¿å…è·¯å¾„ç©¿è¶Šï¼‰
	                let fetchPath = filePath;
	                console.log(`docs/viewer.html: åˆå§‹fetchPath: ${fetchPath}`);

	                // 1. URLè§£ç 
	                fetchPath = decodeURIComponent(fetchPath);
	                console.log(`docs/viewer.html: URLè§£ç å: ${fetchPath}`);

	                // 1.1 åŸºç¡€å®‰å…¨æ ¡éªŒï¼šæ‹’ç»è·¯å¾„ç©¿è¶Š/åæ–œæ /ç©ºå­—èŠ‚
	                if (/(^|\/|\\)\.\.(\/|\\|$)/.test(fetchPath) || fetchPath.includes('\\') || fetchPath.includes('\0')) {
	                    throw new Error('éæ³•è·¯å¾„å‚æ•°');
	                }

	                // 1.2 æ—§è·¯å¾„å…¼å®¹ï¼šModderå…¥é—¨/0-æŒ‡å— â†’ Modderå…¥é—¨/æŒ‡å—
	                if (fetchPath.startsWith('Modderå…¥é—¨/0-æŒ‡å—/')) {
	                    const candidate = fetchPath.replace(/^Modderå…¥é—¨\/0-æŒ‡å—\//, 'Modderå…¥é—¨/æŒ‡å—/');
	                    if (isIndexedDocPath(candidate)) {
	                        fetchPath = candidate;
	                        console.log(`docs/viewer.html: æ—§è·¯å¾„å…¼å®¹é‡å†™: ${fetchPath}`);
	                    }
	                }

	            // 2. å°è¯•é€šè¿‡ç´¢å¼•æ˜ å°„è§£æåˆ°çœŸå®è·¯å¾„ï¼ˆå…¼å®¹æ—§é“¾æ¥/ç§»åŠ¨æ–‡ä»¶ï¼‰
	            if (ALL_DOCS.length > 0) {
	                const candidates = [
	                    fetchPath,
	                    fetchPath.replace(/^\.?\//, ''),
	                    fetchPath.replace(/^docs\//, ''),
	                    fetchPath.replace(/^\.?\//, '').replace(/^docs\//, '')
	                ].filter(Boolean);

	                let resolved = null;
	                if (DOC_LOOKUP_MAP) {
	                    for (const c of candidates) {
	                        resolved = DOC_LOOKUP_MAP.get(c) || DOC_LOOKUP_MAP.get(String(c).toLowerCase());
	                        if (resolved) break;
	                        const noExt = String(c).replace(/\.md$/i, '');
	                        resolved = DOC_LOOKUP_MAP.get(noExt) || DOC_LOOKUP_MAP.get(noExt.toLowerCase());
	                        if (resolved) break;
	                    }
	                }

	                // fallback: category/filename å½¢å¼çš„æ—§é“¾æ¥ï¼ˆä¾‹å¦‚ Modderå…¥é—¨/<filename>.mdï¼‰
	                if (!resolved) {
	                    const tail = String(fetchPath).split('/').pop();
	                    if (tail && tail !== fetchPath) {
	                        const matches = ALL_DOCS.filter(d => d && d.filename === tail);
	                        if (matches.length === 1 && matches[0].path) {
	                            resolved = matches[0].path;
	                        }
	                    }
	                }

	                if (resolved) {
	                    fetchPath = resolved;
	                    console.log(`docs/viewer.html: é€šè¿‡ç´¢å¼•æ˜ å°„è§£æåˆ°çœŸå®è·¯å¾„: ${fetchPath}`);
	                }
	            }

            // 3. ç§»é™¤å¼€å¤´çš„docs/å‰ç¼€ï¼ˆå› ä¸ºviewer.htmlå·²ç»åœ¨docsç›®å½•ä¸­ï¼‰
            if (fetchPath.startsWith('docs/')) {
                fetchPath = fetchPath.substring(5);
                console.log(`docs/viewer.html: ç§»é™¤docså‰ç¼€: ${fetchPath}`);
            }

            // 4. ç§»é™¤å¼€å¤´çš„æ–œæ 
            if (fetchPath.startsWith('/')) {
                fetchPath = fetchPath.substring(1);
                console.log(`docs/viewer.html: ç§»é™¤å¼€å¤´æ–œæ : ${fetchPath}`);
            }

            // 4. æ£€æŸ¥æ˜¯å¦æ˜¯æ—§è·¯å¾„æ ¼å¼ï¼Œè¿›è¡Œé‡å®šå‘
            if (VIEWER_PATH_REDIRECTS[fetchPath]) {
                fetchPath = VIEWER_PATH_REDIRECTS[fetchPath];
                console.log(`docs/viewer.html: æ—§è·¯å¾„é‡å®šå‘: ${fetchPath}`);
            }

	            // 5. æ£€æŸ¥æ˜¯å¦æ˜¯å·²çŸ¥çš„åˆ†ç±»åæˆ–ç‰¹æ®Šæ–‡ä»¶
	            const knownCategories = ['01-å…¥é—¨æŒ‡å—', '02-åŸºç¡€æ¦‚å¿µ', '03-å†…å®¹åˆ›å»º', '04-é«˜çº§å¼€å‘', '05-ä¸“é¢˜ä¸»é¢˜', '06-èµ„æºå‚è€ƒ'];
	            const rootFiles = []; // ä½äºdocsæ ¹ç›®å½•çš„ç‰¹æ®Šæ–‡ä»¶åˆ—è¡¨ï¼ˆå¦‚æœ‰éœ€è¦å¯æ·»åŠ ï¼‰
	            const defaultDocPath = (ALL_DOCS && ALL_DOCS.length > 0) ? (ALL_DOCS[0].path || ALL_DOCS[0].filename) : null;

            if (knownCategories.includes(fetchPath) || fetchPath.match(/^\d+-[^\/]+$/)) {
                // å¦‚æœæ˜¯åˆ†ç±»åï¼Œå°è¯•é‡å®šå‘åˆ°å¯¹åº”çš„æ–‡æ¡£
                console.log(`docs/viewer.html: è¯†åˆ«ä¸ºæ—§åˆ†ç±»åï¼Œå°è¯•é‡å®šå‘`);
                // å°è¯•æ‰¾åˆ°è¯¥åˆ†ç±»ä¸‹çš„ç¬¬ä¸€ä¸ªæ–‡æ¡£
	                const firstDoc = ALL_DOCS.find(doc => doc.category === getCategoryFromOldPath(fetchPath));
	                if (firstDoc) {
	                    fetchPath = firstDoc.path || firstDoc.filename;
	                    console.log(`docs/viewer.html: é‡å®šå‘åˆ°æ–‡æ¡£: ${fetchPath}`);
	                } else {
	                    if (!defaultDocPath) throw new Error('æœªæ‰¾åˆ°å¯ç”¨æ–‡æ¡£');
	                    fetchPath = defaultDocPath;
	                    console.log(`docs/viewer.html: æœªæ‰¾åˆ°å¯¹åº”æ–‡æ¡£ï¼Œä½¿ç”¨é»˜è®¤: ${fetchPath}`);
	                }
	            } else if (rootFiles.includes(fetchPath)) {
                // å¦‚æœæ˜¯æ ¹ç›®å½•ä¸‹çš„ç‰¹æ®Šæ–‡ä»¶ï¼Œç›´æ¥ä½¿ç”¨
                console.log(`docs/viewer.html: è¯†åˆ«ä¸ºæ ¹ç›®å½•æ–‡ä»¶: ${fetchPath}`);
            } else if (fetchPath.includes('/')) {
                // è·¯å¾„å·²ç»åŒ…å«ç›®å½•ï¼Œæ£€æŸ¥æ˜¯å¦æ˜¯æ—§æ ¼å¼
                if (fetchPath.match(/^\d+-[^\/]+\/.*/)) {
                    // æ—§æ ¼å¼è·¯å¾„ï¼Œå°è¯•é‡å®šå‘
                    console.log(`docs/viewer.html: è¯†åˆ«ä¸ºæ—§æ ¼å¼è·¯å¾„ï¼Œå°è¯•é‡å®šå‘`);
                    const filename = fetchPath.split('/').pop();
	                    const doc = ALL_DOCS.find(d => d.filename === filename || d.filename.endsWith(filename));
	                    if (doc) {
	                        fetchPath = doc.path || doc.filename;
	                        console.log(`docs/viewer.html: é‡å®šå‘åˆ°æ–‡æ¡£: ${fetchPath}`);
	                    } else {
	                        if (!defaultDocPath) throw new Error('æœªæ‰¾åˆ°å¯ç”¨æ–‡æ¡£');
	                        fetchPath = defaultDocPath;
	                        console.log(`docs/viewer.html: æœªæ‰¾åˆ°å¯¹åº”æ–‡æ¡£ï¼Œä½¿ç”¨é»˜è®¤: ${fetchPath}`);
	                    }
	                } else {
                    // è·¯å¾„å·²ç»åŒ…å«ç›®å½•ï¼Œç›´æ¥ä½¿ç”¨
                    console.log(`docs/viewer.html: ä½¿ç”¨å®Œæ•´è·¯å¾„: ${fetchPath}`);
                }
            } else {
                // å¦‚æœåªæ˜¯æ–‡ä»¶åï¼Œæ£€æŸ¥æ˜¯å¦å­˜åœ¨äºæ–‡æ¡£åˆ—è¡¨ä¸­
	                const doc = ALL_DOCS.find(d => d.filename === fetchPath || d.path === fetchPath || d.filename === `${fetchPath}.md`);
	                if (doc) {
	                    fetchPath = doc.path || doc.filename;
	                    console.log(`docs/viewer.html: æ‰¾åˆ°åŒ¹é…æ–‡æ¡£: ${fetchPath}`);
	                } else {
	                    if (!defaultDocPath) throw new Error('æœªæ‰¾åˆ°å¯ç”¨æ–‡æ¡£');
	                    fetchPath = defaultDocPath;
	                    console.log(`docs/viewer.html: æœªæ‰¾åˆ°åŒ¹é…æ–‡æ¡£ï¼Œä½¿ç”¨é»˜è®¤: ${fetchPath}`);
	                }
	            }

	            // 6. æœ€ç»ˆç™½åå•æ ¡éªŒï¼šå¿…é¡»å­˜åœ¨äº ALL_DOCS ä¸­
	            if (ALL_DOCS && ALL_DOCS.length > 0) {
	                const matches = ALL_DOCS.filter(d => d.path === fetchPath || d.filename === fetchPath);
	                if (matches.length === 1) {
	                    fetchPath = matches[0].path || matches[0].filename;
	                } else if (matches.length === 0) {
	                    throw new Error('æ–‡æ¡£ä¸å­˜åœ¨æˆ–æœªè¢«ç´¢å¼•ï¼ˆè¯·ä½¿ç”¨ docs/config.json ä¸­çš„è·¯å¾„ï¼‰');
	                } else {
	                    throw new Error('æ–‡æ¡£åç§°ä¸å”¯ä¸€ï¼Œè¯·ä½¿ç”¨å®Œæ•´è·¯å¾„');
	                }
	            }

	            // 7. ç¡®ä¿æ–‡ä»¶ä»¥.mdç»“å°¾
	            if (!fetchPath.endsWith('.md')) {
	                fetchPath += '.md';
	                console.log(`docs/viewer.html: æ·»åŠ .mdæ‰©å±•å: ${fetchPath}`);
	            }

		            console.log(`docs/viewer.html: æœ€ç»ˆä½¿ç”¨è·¯å¾„: ${fetchPath}`);
		            CURRENT_DOC_PATH = fetchPath;
		            if (typeof window.updateGiscusForDoc === 'function') {
		                window.updateGiscusForDoc(fetchPath);
		            }
		
		            // ç¡®ä¿è·¯å¾„ç›¸å¯¹äºå½“å‰é¡µé¢ï¼ˆdocsç›®å½•ï¼‰
		            let fetchUrl = fetchPath.startsWith('./') ? fetchPath : `./${fetchPath}`;

            // é¿å…é‡å¤çš„docsè·¯å¾„
            if (fetchUrl.startsWith('./docs/')) {
                fetchUrl = fetchUrl.substring(6); // ç§»é™¤ './docs/'
                if (!fetchUrl.startsWith('./')) {
                    fetchUrl = `./${fetchUrl}`;
                }
            }

            console.log(`docs/viewer.html: å®é™…fetch URL: ${fetchUrl}`);
            console.log(`å®Œæ•´è¯·æ±‚URLå°†æ˜¯: ${window.location.origin}${window.location.pathname.replace(/\/[^\/]*$/, '/')}${fetchUrl}`);

	            fetch(encodeURI(fetchUrl), { cache: 'no-store' })
	                .then(response => {
                    console.log(`è·å–å“åº”çŠ¶æ€: ${response.status} ${response.statusText}`);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status} ${response.statusText}`);
                    }
                    return response.text();
                })
                .then(async markdownText => {
                    console.log(`docs/viewer.html: æˆåŠŸè·å–Markdownå†…å®¹ï¼Œé•¿åº¦: ${markdownText.length}`);

                    if (typeof marked !== 'undefined') {
                        console.log('marked.jså·²åŠ è½½ï¼Œå¼€å§‹æ¸²æŸ“');

	                        // è§£æFront Matterï¼ˆæ–‡æ¡£å…ƒæ•°æ®ï¼‰
	                        const frontMatter = parseFrontMatter(markdownText);
	                        let content = frontMatter.content;
	                        const metadata = frontMatter.metadata;
	                        const rawMetadata = { ...(metadata || {}) };
	                        const rawSourceContent = String(content || '');

                        // è¡¥é½ç¼ºå¤±çš„å…ƒæ•°æ®ï¼šä¼˜å…ˆä½¿ç”¨ config.json ä¸­çš„ç´¢å¼•ä¿¡æ¯ï¼ˆä¸ä¿®æ”¹ Markdown åŸæ–‡ï¼‰
                        const docFromConfig = ALL_DOCS.find(d => {
                            const p = d.path || d.filename;
                            return p === fetchPath || d.filename === fetchPath || d.path === fetchPath;
                        });
	                        if (docFromConfig) {
	                            if (!metadata.title && docFromConfig.title) metadata.title = docFromConfig.title;
	                            if (!metadata.author && docFromConfig.author) metadata.author = docFromConfig.author;
	                            if (!metadata.description && docFromConfig.description) metadata.description = docFromConfig.description;
	                            if (!metadata.category && docFromConfig.category) metadata.category = docFromConfig.category;
	                            if (!metadata.topic && docFromConfig.topic) metadata.topic = docFromConfig.topic;
	                            if (!metadata.difficulty && docFromConfig.difficulty) metadata.difficulty = docFromConfig.difficulty;
	                            if (!metadata.time && docFromConfig.time) metadata.time = docFromConfig.time;
	                            if (!metadata.last_updated && docFromConfig.last_updated) metadata.last_updated = docFromConfig.last_updated;
	                            if (!metadata.prev_chapter && docFromConfig.prev_chapter) metadata.prev_chapter = docFromConfig.prev_chapter;
	                            if (!metadata.next_chapter && docFromConfig.next_chapter) metadata.next_chapter = docFromConfig.next_chapter;
	                            if (!metadata.colors && docFromConfig.colors) metadata.colors = docFromConfig.colors;
	                            if (!metadata.colorChange && docFromConfig.colorChange) metadata.colorChange = docFromConfig.colorChange;
	                        }

                        console.log('è§£æçš„å…ƒæ•°æ®:', metadata);

	                        // æ›´æ–°é¡µé¢å…ƒæ•°æ®ï¼ˆæ ‡é¢˜ã€éš¾åº¦ã€ä½œè€…ç­‰ï¼‰
	                        updatePageMetadata(metadata, fetchPath);

	                        // æ›´æ–°å½“å‰åˆ†ç±»çš„æ–‡æ¡£åˆ—è¡¨
	                        updateCurrentCategoryDocs(fetchPath);

	                        // æ¸…ç†ä¸Šä¸€æ¬¡çš„ä½œè€…æ¨¡å¼è¯Šæ–­çŠ¶æ€ï¼ˆé¿å…è·¨æ–‡æ¡£ä¸²è”ï¼‰
	                        setCurrentLearningDiagnostics(null);
	                        renderLearningAuthorHeaderHint(null);

	                        try {
	                            const learningModel = getLearningRenderContext();
	                            window.CURRENT_LEARNING_MODEL = learningModel;
	                            const diag = learningModel.authorMode ? createLearningDiagnostics(fetchPath) : null;
	                            setCurrentLearningDiagnostics(diag);
	                            if (diag) {
	                                collectAuthorDiagnostics(diag, rawMetadata, metadata, fetchPath, rawSourceContent);
	                            }
		                            renderLearningSidebarPanel(learningModel);
		                            renderLearningAuthorToolbar();
		                            renderLearningRecommendationHint(metadata, learningModel);
		                            renderLearningHintsBanner(learningModel);
		                            renderLearningTopBanner(learningModel);
		                            renderLearningAuthorHeaderHint(diag);

	                            content = applyLearningConditionBlocks(content, learningModel.ctx);
	                            content = await expandMarkdownTransclusions(content, fetchPath, 0, [], learningModel.ctx);
	                        } catch (err) {
	                            console.warn('å±•å¼€å¼•ç”¨å†…å®¹å¤±è´¥ï¼Œç»§ç»­æ¸²æŸ“åŸå§‹æ–‡æ¡£:', err);
	                        }

	                        const renderedHTML = marked.parse(content);
	                        console.log('Markdownæ¸²æŸ“å®Œæˆï¼ŒHTMLé•¿åº¦:', renderedHTML.length);
	                        markdownContent.innerHTML = renderedHTML;

	                        // ç§»é™¤æ­£æ–‡å†…é‡å¤çš„â€œç« èŠ‚è¿›åº¦â€å¯¼èˆªï¼ˆç»Ÿä¸€ä½¿ç”¨é¡µè„šå¯¼èˆªï¼‰
	                        removeDuplicateChapterProgress(markdownContent);

	                        // æ¸²æŸ“é¢˜ç›®ç»„ä»¶ï¼ˆquizï¼‰
	                        if (window.SiteQuiz && typeof window.SiteQuiz.renderQuizzes === 'function') {
	                            window.SiteQuiz.renderQuizzes(markdownContent);
	                        }

	                        // ä¸º Mermaid æµ‹é‡æä¾›å¯å¸ƒå±€çš„å®¹å™¨ï¼ˆdisplay:none ä¼šå¯¼è‡´å°ºå¯¸è®¡ç®—é”™è¯¯/æ–‡å­—æˆªæ–­ï¼‰
	                        markdownContent.style.display = 'block';
	                        markdownContent.style.visibility = 'hidden';
	                        markdownContent.style.pointerEvents = 'none';

	                        // æ¸²æŸ“æµç¨‹å›¾ï¼ˆMermaidï¼‰
	                        await renderMermaidFlowcharts(markdownContent);

	                        // åº”ç”¨ä»£ç è¯­æ³•é«˜äº®
	                        if (typeof Prism !== 'undefined') {
	                            console.log('åº”ç”¨ä»£ç é«˜äº®');
	                            Prism.highlightAllUnder(markdownContent);
                                document.dispatchEvent(new CustomEvent('viewer:content-ready', {
                                    detail: { container: markdownContent }
                                }));
                        } else {
                            console.warn('Prism.jsæœªåŠ è½½ï¼Œè·³è¿‡ä»£ç é«˜äº®');
                            document.dispatchEvent(new CustomEvent('viewer:content-ready', {
                                detail: { container: markdownContent }
                            }));
                        }

	                        // è‡ªåŠ¨ç”Ÿæˆæ–‡æ¡£ç›®å½•
	                        generateTableOfContents(markdownContent);

		                        // ä½œè€…æ¨¡å¼è¯Šæ–­é¢æ¿ï¼ˆä¸å½±å“è¯»è€…ï¼‰
		                        renderLearningAuthorPanel(getCurrentLearningDiagnostics(), markdownContent, fetchPath);
		                        renderLearningAuthorToolbar();

                        // æ˜¾ç¤ºå†…å®¹ï¼Œéšè—åŠ è½½æŒ‡ç¤ºå™¨
                        if (loadingIndicator) {
                            loadingIndicator.style.display = 'none';
                            loadingIndicator.setAttribute('aria-busy', 'false');
                        }
                        markdownContent.style.display = 'block';
                        markdownContent.style.visibility = 'visible';
                        markdownContent.style.pointerEvents = '';
                        document.getElementById('table-of-contents').style.display = 'block';
                        if (errorMessage) errorMessage.setAttribute('aria-hidden', 'true');

                        // åˆå§‹åŒ–å›¾ç‰‡ç¼©æ”¾
                        initImageZoom();

                    } else {
                        throw new Error('marked.jsæœªåŠ è½½');
                    }
                })
	                .catch(error => {
                    console.error('docs/viewer.html: åŠ è½½Markdownå¤±è´¥:', error);
                    if (loadingIndicator) {
                        loadingIndicator.style.display = 'none';
                        loadingIndicator.setAttribute('aria-busy', 'false');
                    }
                    if (errorMessage) {
                        errorMessage.style.display = 'block';
                        errorMessage.setAttribute('aria-hidden', 'false');
                        document.getElementById('error-text').textContent = `æ— æ³•åŠ è½½æ–‡ä»¶ "${fetchPath}": ${error.message}`;
                    }
	                });
	            } catch (error) {
	                console.error('docs/viewer.html: æ— æ³•è§£æ/åŠ è½½æ–‡æ¡£:', error);
	                if (loadingIndicator) {
	                    loadingIndicator.style.display = 'none';
                        loadingIndicator.setAttribute('aria-busy', 'false');
	                }
	                if (errorMessage) {
	                    errorMessage.style.display = 'block';
                        errorMessage.setAttribute('aria-hidden', 'false');
	                    document.getElementById('error-text').textContent = `æ— æ³•åŠ è½½æ–‡ä»¶ "${filePath}": ${error.message}`;
	                }
	            }
	        }

        // åˆ†ç±»æ˜ å°„å‡½æ•°ï¼šå°†æ—§åˆ†ç±»ç³»ç»Ÿæ˜ å°„åˆ°æ–°åˆ†ç±»ç³»ç»Ÿ
        function mapCategoryToNewSystem(oldCategory) {
            console.log(`æ˜ å°„åˆ†ç±»: ${oldCategory}`);

            // å¦‚æœåˆ†ç±»å·²ç»å­˜åœ¨äºæ–°ç³»ç»Ÿä¸­ï¼Œç›´æ¥è¿”å›
            if (MAIN_CATEGORIES[oldCategory]) {
                console.log(`åˆ†ç±» ${oldCategory} å·²å­˜åœ¨äºæ–°ç³»ç»Ÿä¸­`);
                return oldCategory;
            }

            // å¦‚æœé…ç½®æ–‡ä»¶ä¸­æœ‰åˆ†ç±»æ˜ å°„ï¼Œä½¿ç”¨æ˜ å°„
            if (VIEWER_DOC_CONFIG && VIEWER_DOC_CONFIG.categoryMappings && VIEWER_DOC_CONFIG.categoryMappings[oldCategory]) {
                const newCategory = VIEWER_DOC_CONFIG.categoryMappings[oldCategory];
                console.log(`åˆ†ç±» ${oldCategory} æ˜ å°„åˆ° ${newCategory}`);
                return newCategory;
            }

            // å°è¯•ä»æ—§è·¯å¾„ä¸­æå–åˆ†ç±»
            const pathMap = {
                '00-æµ‹è¯•æ–‡æ¡£': 'å…¥é—¨',
                '01-å…¥é—¨æŒ‡å—': 'å…¥é—¨',
                '02-åŸºç¡€æ¦‚å¿µ': 'å…¥é—¨',
                '03-å†…å®¹åˆ›å»º': 'è¿›é˜¶',
                '04-é«˜çº§å¼€å‘': 'é«˜çº§',
                '05-ä¸“é¢˜ä¸»é¢˜': 'é«˜çº§',
                '06-èµ„æºå‚è€ƒ': 'ä¸ªäººåˆ†äº«',
                '0-å¼€å§‹': 'å…¥é—¨',
                '1-åŸºç¡€': 'å…¥é—¨',
                '2-ä¸­é˜¶': 'è¿›é˜¶',
                '3-é«˜é˜¶': 'é«˜çº§',
                '4-ä¸“å®¶': 'é«˜çº§'
            };

            const mappedCategory = pathMap[oldCategory] || 'å…¥é—¨';
            console.log(`é€šè¿‡è·¯å¾„æ˜ å°„ï¼Œåˆ†ç±» ${oldCategory} æ˜ å°„åˆ° ${mappedCategory}`);
            return mappedCategory;
        }

        // ä»æ—§è·¯å¾„è·å–å¯¹åº”çš„åˆ†ç±»
	        function getCategoryFromOldPath(oldPath) {
	            console.log(`ä»æ—§è·¯å¾„è·å–åˆ†ç±»: ${oldPath}`);
	            const category = mapCategoryToNewSystem(oldPath);
	            console.log(`æ˜ å°„ç»“æœ: ${category}`);
	            return category;
	        }

	        function parseOrder(value, fallback = 999) {
	            const parsed = Number.parseInt(value, 10);
	            return Number.isFinite(parsed) ? parsed : fallback;
	        }

	        // è§£æFront Matterï¼ˆæ–‡æ¡£å¼€å¤´çš„å…ƒæ•°æ®éƒ¨åˆ†ï¼‰
	        function parseFrontMatter(text) {
            const frontMatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/;
            const match = text.match(frontMatterRegex);

            if (match) {
                const yamlText = match[1];
                const content = match[2];

                // æ›´å¼ºå¤§çš„YAMLè§£æå™¨
                const metadata = parseYaml(yamlText);

                return {
                    metadata: metadata,
                    content: content
                };
            }

            return {
                metadata: {},
                content: text
            };
        }

        // ç®€å•çš„YAMLè§£æå™¨ï¼Œæ”¯æŒåµŒå¥—å¯¹è±¡å’Œæ•°ç»„
        function parseYaml(yamlText) {
            // ç§»é™¤å¼€å¤´å’Œç»“å°¾çš„ç©ºç™½è¡Œ
            const lines = yamlText.trim().split('\n');
            const result = {};

            // ç®€å•çš„æ ˆç»“æ„è·Ÿè¸ªå½“å‰å¯¹è±¡å’Œç¼©è¿›çº§åˆ«
            const stack = [{ obj: result, indent: -1 }];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (!line.trim()) continue;

                // è®¡ç®—å®é™…ç¼©è¿›ï¼ˆç©ºæ ¼æ•°ï¼‰
                const indent = line.search(/\S/);
                const trimmedLine = line.trim();

                // ç§»é™¤æ¯”å½“å‰ç¼©è¿›çº§åˆ«æ›´æ·±çš„æ‰€æœ‰å¯¹è±¡
                while (stack.length > 1 && stack[stack.length - 1].indent >= indent) {
                    stack.pop();
                }

                const current = stack[stack.length - 1];
                const currentObj = current.obj;

                // å¤„ç†æ•°ç»„é¡¹ï¼ˆä»¥-å¼€å¤´ï¼‰
                if (trimmedLine.startsWith('-')) {
                    const content = trimmedLine.substring(1).trim();

                    // æ£€æŸ¥æ˜¯å¦æ˜¯é”®å€¼å¯¹å½¢å¼ (- key: value)
                    if (content.includes(':')) {
                        const colonIndex = content.indexOf(':');
                        const key = content.substring(0, colonIndex).trim();
                        const value = content.substring(colonIndex + 1).trim();

                        // å¤„ç†å¸¦å¼•å·çš„å­—ç¬¦ä¸²
                        let finalValue = value;
                        if ((value.startsWith('"') && value.endsWith('"')) ||
                            (value.startsWith("'") && value.endsWith("'"))) {
                            finalValue = value.substring(1, value.length - 1);
                        }

                        // å¦‚æœå½“å‰å¯¹è±¡æ˜¯æ•°ç»„ï¼Œåˆ™æ¨å…¥æ–°å¯¹è±¡
                        if (Array.isArray(currentObj)) {
                            const newObj = {};
                            newObj[key] = finalValue;
                            currentObj.push(newObj);
                        } else {
                            // å¦åˆ™åˆ›å»ºæ•°ç»„å¹¶æ·»åŠ ç¬¬ä¸€ä¸ªå…ƒç´ 
                            const arrayKey = Object.keys(currentObj).pop();
                            if (!Array.isArray(currentObj[arrayKey])) {
                                currentObj[arrayKey] = [];
                            }
                            const newObj = {};
                            newObj[key] = finalValue;
                            currentObj[arrayKey].push(newObj);
                        }
                    } else {
                        // ç®€å•å€¼å½¢å¼ (- value)
                        let finalValue = content;
                        if ((content.startsWith('"') && content.endsWith('"')) ||
                            (content.startsWith("'") && content.endsWith("'"))) {
                            finalValue = content.substring(1, content.length - 1);
                        }

                        // ç¡®ä¿å½“å‰ä¸Šä¸‹æ–‡æ˜¯æ•°ç»„
                        const parent = stack[stack.length - 2];
                        if (parent) {
                            const parentObj = parent.obj;
                            const arrayKey = Object.keys(parentObj).pop();

                            if (!Array.isArray(parentObj[arrayKey])) {
                                parentObj[arrayKey] = [];
                            }
                            parentObj[arrayKey].push(finalValue);
                        }
                    }
                }
                // å¤„ç†é”®å€¼å¯¹ (key: value)
                else if (trimmedLine.includes(':')) {
                    const colonIndex = trimmedLine.indexOf(':');
                    const key = trimmedLine.substring(0, colonIndex).trim();
                    const value = trimmedLine.substring(colonIndex + 1).trim();

                    // å¦‚æœå€¼ä¸ºç©ºï¼Œè¿™æ˜¯ä¸€ä¸ªåµŒå¥—å¯¹è±¡
                    if (!value) {
                        const newObj = {};
                        currentObj[key] = newObj;
                        stack.push({ obj: newObj, indent: indent });
                    }
                    // å¦‚æœå€¼ä¸ä¸ºç©ºï¼Œæ˜¯ç®€å•é”®å€¼å¯¹
                    else {
                        // å¤„ç†å¸¦å¼•å·çš„å­—ç¬¦ä¸²
                        let finalValue = value;
                        if ((value.startsWith('"') && value.endsWith('"')) ||
                            (value.startsWith("'") && value.endsWith("'"))) {
                            finalValue = value.substring(1, value.length - 1);
                        }
                        // å¤„ç†é¢œè‰²å€¼ç­‰ç‰¹æ®Šæ ¼å¼
                        else if (value.startsWith('#')) {
                            finalValue = value;
                        }
                        // å°è¯•è½¬æ¢æ•°å­—
                        else if (!isNaN(value) && !isNaN(parseFloat(value))) {
                            finalValue = parseFloat(value);
                        }
                        // å¤„ç†å¸ƒå°”å€¼
                        else if (value.toLowerCase() === 'true') {
                            finalValue = true;
                        }
                        else if (value.toLowerCase() === 'false') {
                            finalValue = false;
                        }

                        currentObj[key] = finalValue;
                    }
                }
                // å¤„ç†æ•°ç»„å¼€å§‹çš„æƒ…å†µ ([key]:)
                else if (trimmedLine.endsWith(':')) {
                    const key = trimmedLine.slice(0, -1).trim();
                    const newArray = [];
                    currentObj[key] = newArray;
                    stack.push({ obj: newArray, indent: indent });
                }
            }

            return result;
        }

	        // æ›´æ–°é¡µé¢å…ƒæ•°æ®ï¼ˆæ ‡é¢˜ã€éš¾åº¦ã€æ—¶é—´ã€ä½œè€…ã€æ—¥æœŸï¼‰
	        function updatePageMetadata(metadata, filePath) {
	            const title = metadata.title || filePath.replace('.md', '');
	            const difficulty = metadata.difficulty || 'beginner';
	            const time = metadata.time || 'æœªçŸ¥';
	            const author = metadata.author || 'æœªçŸ¥';
	            const last_updated = metadata.last_updated || 'æœªçŸ¥';
	            const prevChapter = metadata.prev_chapter || null;
	            const nextChapter = metadata.next_chapter || null;
		            const colors = metadata.colors || metadata.colorLD || null;
		            const colorChange = metadata.colorChange || null;
		
		            console.log('æ›´æ–°é¡µé¢å…ƒæ•°æ®:', { title, difficulty, time, author, last_updated, prevChapter, nextChapter, colors, colorChange });

	            document.title = `${title} - æ³°æ‹‰ç‘äºšModåˆ¶ä½œæ•™ç¨‹`;

	            const currentNameEl = document.getElementById('current-doc-name');
	            if (currentNameEl) currentNameEl.textContent = title;

	            const titleEl = document.getElementById('doc-title');
	            if (titleEl) titleEl.textContent = title;

	            const difficultyEl = document.getElementById('doc-difficulty');
	            if (difficultyEl) {
	                difficultyEl.textContent = getDifficultyText(difficulty);
	                difficultyEl.className = `difficulty-badge ${difficulty}`;
	            }

	            const timeEl = document.getElementById('doc-time');
	            if (timeEl) timeEl.textContent = time;

	            const authorEl = document.getElementById('doc-author');
	            if (authorEl) authorEl.textContent = author;

	            const dateEl = document.getElementById('doc-date');
	            if (dateEl) dateEl.textContent = last_updated;

	            // æ›´æ–°ç‰¹æ®Šé¢œè‰²
		            updateColorStyle(colors, colorChange);

            // æ›´æ–°é¢åŒ…å±‘å¯¼èˆª
            updateBreadcrumbNavigation(metadata, filePath);

            // æ›´æ–°å¯¼èˆªæŒ‰é’®
	            updateNavigationButtons(prevChapter, nextChapter, filePath);

            // æ›´æ–° SEO å…ƒæ ‡ç­¾ï¼ˆcanonical/OG/Twitter/descriptionï¼‰
            updateSeoMeta({
                title,
                description: metadata.description || metadata.summary || '',
                filePath
            });
        }

        function setMetaContent(selector, content) {
            const el = document.querySelector(selector);
            if (el && content) el.setAttribute('content', content);
        }

        function setCanonical(href) {
            let link = document.querySelector('link[rel="canonical"]');
            if (!link) {
                link = document.createElement('link');
                link.setAttribute('rel', 'canonical');
                document.head.appendChild(link);
            }
            link.setAttribute('href', href);
        }

        function updateSeoMeta({ title, description, filePath }) {
            const baseUrl = 'https://dpapyru.github.io/docs/viewer.html';
            const url = filePath ? `${baseUrl}?file=${encodeURIComponent(filePath)}` : baseUrl;

            const safeTitle = title ? `${title} - æ³°æ‹‰ç‘äºšModåˆ¶ä½œæ•™ç¨‹` : 'æ–‡æ¡£æŸ¥çœ‹å™¨ - æ³°æ‹‰ç‘äºšModåˆ¶ä½œæ•™ç¨‹';
            const safeDescription = (description && String(description).trim())
                ? String(description).trim()
                : 'æ³°æ‹‰ç‘äºšModåˆ¶ä½œæ•™ç¨‹æ–‡æ¡£é˜…è¯»é¡µé¢ï¼Œæ”¯æŒç›®å½•ã€ä»£ç é«˜äº®ä¸åˆ†ç±»å¯¼èˆªã€‚';

            setCanonical(url);
            setMetaContent('meta[name="description"]', safeDescription);
            setMetaContent('meta[property="og:title"]', safeTitle);
            setMetaContent('meta[property="og:description"]', safeDescription);
            setMetaContent('meta[property="og:url"]', url);
            setMetaContent('meta[name="twitter:title"]', safeTitle);
            setMetaContent('meta[name="twitter:description"]', safeDescription);
        }

	        function updateColorStyle(colorsConfig, colorChangeConfig) {
	            const existing = document.getElementById('dynamic-color-style');
	            if (existing) existing.remove();

	            const style = document.createElement('style');
	            style.id = 'dynamic-color-style';

	            // æ–‡å­—é¢œè‰²å˜é‡ï¼ˆå•è‰²ï¼‰
	            let colors = '';
	            if (!colorsConfig) {
	                console.warn('æ²¡æœ‰è®¾ç½®æ–‡å­—é¢œè‰²å˜é‡!è·³è¿‡æ–‡å­—é¢œè‰²çš„è®¾ç½®!');
	            } else {
	                colors = colorStyle(colorsConfig);
	            }

	            // é¢œè‰²åŠ¨ç”»
	            let colorChange = '';
	            if (!colorChangeConfig) {
	                console.warn('æ²¡æœ‰è®¾ç½®é¢œè‰²è½¬æ¢å˜é‡!è·³è¿‡é¢œè‰²è½¬æ¢å˜é‡çš„è®¾ç½®!');
	            } else {
	                colorChange = colorChangeStyle(colorChangeConfig) || '';
	            }

	            style.textContent = `
	                        ${colorChange}
	                        :root{
	                            ${colors}
	                        }
	                    `;
	            document.head.appendChild(style);
	        }

	        function colorStyle(colorsConfig) {
	            try {
	                if (!colorsConfig) {
	                    console.error('ç‰¹æ®Šå­—ä½“é¢œè‰²é…ç½®å¤±æ•ˆï¼');
	                    return '';
	                }

	                let styleText = '';
	                Object.entries(colorsConfig).forEach(([name, value]) => {
	                    let resolved = '';
	                    if (Array.isArray(value)) {
	                        resolved = (value.length > 1 ? value[1] : value[0]) || '';
	                    } else if (typeof value === 'string') {
	                        resolved = value;
	                    }

	                    if (!resolved) return;
	                    styleText = styleText.concat(`
	                            --marked-text-color-${name}:${resolved};
	                        `).trim();
	                });

	                return styleText;
	            } catch (error) {
	                console.error('åˆ›å»ºcssæ—¶å€™å‡ºç°ä¸¥é‡é—®é¢˜!é—®é¢˜:', error);
	            }
	        }

        /**
         * æ ¹æ®é¢œè‰²å˜åŒ–æ•°ç»„ç”ŸæˆCSSåŠ¨ç”»æ ·å¼
         * @param {Array} colorChangeArray - é¢œè‰²å˜åŒ–é…ç½®æ•°ç»„ï¼Œæ¯ä¸ªå…ƒç´ åŒ…å«åŠ¨ç”»åç§°å’Œé¢œè‰²å€¼æ•°ç»„
         * @returns {void}
         */
        function colorChangeStyle(colorChangeArray) {
            try {
                const forEach_color = colorChangeArray; // é¢œè‰²åŠ¨ç”»çš„æ•°ç»„
                let style_text = ''; // è¾“å‡ºçš„å†…å®¹
                if (forEach_color) { // å¦‚æœæœ‰é¢œè‰²æ•°ç»„
                    // éå†é¢œè‰²æ”¹å˜æ•°ç»„
                    Object.entries(forEach_color).forEach(colorName => {
                        // colorName0æ˜¯åå­—
                        // colorName1æ˜¯é¢œè‰²æ•°ç»„

                        const colorArray = [];
                        // éå†æ¯ä¸ªå˜é‡å
                        colorName[1].forEach(color => {
                            colorArray.push(color);
                        });
                        const colorLength = colorArray.length;
                        let useColor = '';
                        // æ„å»ºå…³é”®å¸§åŠ¨ç”»çš„é¢œè‰²å˜åŒ–éƒ¨åˆ†
                        for (let i = 0; i < colorLength; i++) {
                            const colorPercent = (i / colorLength) * 100;
                            useColor = useColor.concat(`${colorPercent.toFixed(0)}% {color:${colorArray[i]};}\n`);
                        }
                        useColor = useColor.concat(`100% {color:${colorArray[0]};}\n`);
                        // æ·»åŠ æ ·å¼
                        style_text = style_text.concat(`
                            @keyframes colorChange-${colorName[0]}{
                                ${useColor}
                            }
                        `);
                    });
                    return style_text;
                }
                else {
                    console.error('ç‰¹æ®Šå­—ä½“é¢œè‰²é…ç½®å¤±æ•ˆï¼');
                }
            } catch (error) {
                console.error('åˆ›å»ºcssæ—¶å€™å‡ºç°ä¸¥é‡é—®é¢˜!é—®é¢˜:', error);
            }
        }

        // æ›´æ–°é¢åŒ…å±‘å¯¼èˆª
        function updateBreadcrumbNavigation(metadata, filePath) {
            const breadcrumb = document.querySelector('.breadcrumb');
            if (!breadcrumb) return;

            // æŸ¥æ‰¾å½“å‰æ–‡æ¡£ä¿¡æ¯
            const currentDoc = ALL_DOCS.find(doc => doc.filename === filePath || doc.path === filePath);

            // æ¸…ç©ºç°æœ‰é¢åŒ…å±‘
            breadcrumb.innerHTML = '';

            // æ·»åŠ é¦–é¡µé“¾æ¥
            const homeLink = document.createElement('a');
            homeLink.href = '../index.html';
            homeLink.textContent = 'é¦–é¡µ';
            breadcrumb.appendChild(homeLink);

            // æ·»åŠ åˆ†éš”ç¬¦
            const separator1 = document.createElement('span');
            separator1.className = 'breadcrumb-separator';
            separator1.textContent = ' > ';
            breadcrumb.appendChild(separator1);

            // æ·»åŠ æ–‡æ¡£åˆ—è¡¨é“¾æ¥
            const docsLink = document.createElement('a');
            docsLink.href = 'index.html';
            docsLink.textContent = 'æ–‡æ¡£';
            breadcrumb.appendChild(docsLink);

            // å¦‚æœæ‰¾åˆ°å½“å‰æ–‡æ¡£ä¿¡æ¯ï¼Œæ·»åŠ åˆ†ç±»å’Œä¸»é¢˜è·¯å¾„
            if (currentDoc) {
                // æ·»åŠ åˆ†éš”ç¬¦
                const separator2 = document.createElement('span');
                separator2.className = 'breadcrumb-separator';
                separator2.textContent = ' > ';
                breadcrumb.appendChild(separator2);

                // æ·»åŠ åˆ†ç±»é“¾æ¥
                const category = MAIN_CATEGORIES[currentDoc.category];
                if (category) {
                    const categoryLink = document.createElement('a');
                    categoryLink.href = `folder.html?path=${encodeURIComponent(currentDoc.category)}`;
                    categoryLink.textContent = category.title;
                    breadcrumb.appendChild(categoryLink);

                    // ä¸»é¢˜ä¿¡æ¯ä»…å±•ç¤ºä¸ºæ–‡æœ¬ï¼ˆå½“å‰ç«™ç‚¹ä¸æ”¯æŒæŒ‰ topic è¿‡æ»¤è·³è½¬ï¼‰
                    if (currentDoc.topic && VIEWER_DOC_CONFIG && VIEWER_DOC_CONFIG.topics && VIEWER_DOC_CONFIG.topics[currentDoc.topic]) {
                        const separator3 = document.createElement('span');
                        separator3.className = 'breadcrumb-separator';
                        separator3.textContent = ' > ';
                        breadcrumb.appendChild(separator3);

                        const topicSpan = document.createElement('span');
                        topicSpan.className = 'breadcrumb-topic';
                        topicSpan.textContent = VIEWER_DOC_CONFIG.topics[currentDoc.topic].title;
                        breadcrumb.appendChild(topicSpan);

                        const separator4 = document.createElement('span');
                        separator4.className = 'breadcrumb-separator';
                        separator4.textContent = ' > ';
                        breadcrumb.appendChild(separator4);
                    }
                }
            }

            // æ·»åŠ å½“å‰æ–‡æ¡£æ ‡é¢˜
            const currentSpan = document.createElement('span');
            currentSpan.className = 'current';
            currentSpan.textContent = metadata.title || filePath.replace('.md', '');
            breadcrumb.appendChild(currentSpan);
        }

	        // æ›´æ–°å¯¼èˆªæŒ‰é’®
		        function updateNavigationButtons(prevChapter, nextChapter, currentDocPath) {
	            const navigationContainer = document.querySelector('.tutorial-navigation');
	            if (!navigationContainer) {
	                console.warn('æ‰¾ä¸åˆ°å¯¼èˆªå®¹å™¨');
	                return;
	            }

            // æ¸…ç©ºç°æœ‰å¯¼èˆªå†…å®¹
            navigationContainer.innerHTML = '';

	            // æ·»åŠ è¿”å›æ–‡æ¡£åˆ—è¡¨æŒ‰é’®
	            const backToListBtn = document.createElement('a');
	            backToListBtn.href = 'index.html';
	            backToListBtn.className = 'btn btn-outline prev-tutorial';
		            backToListBtn.textContent = 'â† è¿”å›æ–‡æ¡£åˆ—è¡¨';
		            navigationContainer.appendChild(backToListBtn);

	            function findDocByPath(docPath) {
	                const p = String(docPath || '');
	                if (!p || !Array.isArray(ALL_DOCS)) return null;
	                return ALL_DOCS.find(d => d && (d.path === p || d.filename === p)) || null;
	            }

	            function getDocTitle(docPath) {
	                const doc = findDocByPath(docPath);
	                if (doc && doc.title) return String(doc.title);
	                const tail = String(docPath || '').split('/').pop() || '';
	                return tail.replace(/\.md$/i, '') || String(docPath || '');
	            }

	            function resolveNavPath(raw) {
	                if (!raw) return null;
	                const href = String(raw).trim();
	                if (!href) return null;
	                const resolved = resolveDocLinkPath(href, currentDocPath || CURRENT_DOC_PATH);
	                if (resolved) return resolved;
	                const fallback = resolveRelativeHref(href, currentDocPath || CURRENT_DOC_PATH);
	                if (!fallback) return href;
	                return String(fallback).replace(/^\.?\//, '').replace(/^docs\//, '');
	            }

	            function appendNavButton(kind, resolvedPath) {
	                const title = getDocTitle(resolvedPath);
	                const btn = document.createElement('a');
	                btn.href = `?file=${encodeURIComponent(resolvedPath)}`;
	                btn.className = kind === 'prev'
	                    ? 'btn btn-secondary prev-tutorial'
	                    : 'btn btn-primary next-tutorial';

	                const label = document.createElement('span');
	                label.className = 'tutorial-nav-label';
	                label.textContent = kind === 'prev' ? 'â† ä¸Šä¸€ç« ' : 'ä¸‹ä¸€ç«  â†’';

	                const sep = document.createElement('span');
	                sep.className = 'tutorial-nav-sep';
	                sep.textContent = 'ï¼š';

	                const t = document.createElement('span');
	                t.className = 'tutorial-nav-title';
	                t.textContent = title;

	                if (kind === 'prev') {
	                    btn.appendChild(label);
	                    btn.appendChild(sep);
	                    btn.appendChild(t);
	                } else {
	                    const arrow = document.createElement('span');
	                    arrow.className = 'tutorial-nav-arrow';
	                    arrow.textContent = 'â†’';
	                    label.textContent = 'ä¸‹ä¸€ç« ';
	                    btn.appendChild(label);
	                    btn.appendChild(sep);
	                    btn.appendChild(t);
	                    btn.appendChild(document.createTextNode(' '));
	                    btn.appendChild(arrow);
	                }

	                navigationContainer.appendChild(btn);
	            }

	            // æ·»åŠ ä¸Šä¸€ç« æŒ‰é’®ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
		            if (prevChapter) {
		                const resolvedPrev = resolveNavPath(prevChapter);
		                if (resolvedPrev) appendNavButton('prev', resolvedPrev);
		            }

	            // æ·»åŠ ä¸‹ä¸€ç« æŒ‰é’®ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
		            if (nextChapter) {
		                const resolvedNext = resolveNavPath(nextChapter);
		                if (resolvedNext) appendNavButton('next', resolvedNext);
		            }

	            console.log('å¯¼èˆªæŒ‰é’®å·²æ›´æ–°:', { prevChapter, nextChapter });
	        }

	        function removeDuplicateChapterProgress(container) {
	            const root = container || document.getElementById('markdown-content');
	            if (!root) return;
	            const blockquotes = root.querySelectorAll('blockquote');
	            blockquotes.forEach(function (bq) {
	                const text = String(bq.textContent || '').replace(/\s+/g, ' ').trim();
	                if (!text) return;
	                if (!text.includes('ç« èŠ‚è¿›åº¦')) return;
	                if (!(text.includes('ä¸Šä¸€ç« ') && text.includes('ä¸‹ä¸€ç« '))) return;
	                bq.remove();
	            });
	        }

        // å°†éš¾åº¦ä»£ç è½¬æ¢ä¸ºä¸­æ–‡æ–‡æœ¬
        function getDifficultyText(difficulty) {
            // é¦–å…ˆå°è¯•ä»é…ç½®æ–‡ä»¶ä¸­è·å–éš¾åº¦æ˜ å°„
            if (VIEWER_DOC_CONFIG && VIEWER_DOC_CONFIG.extensions && VIEWER_DOC_CONFIG.extensions.customFields &&
                VIEWER_DOC_CONFIG.extensions.customFields.difficulty && VIEWER_DOC_CONFIG.extensions.customFields.difficulty.options) {
                const difficultyOptions = VIEWER_DOC_CONFIG.extensions.customFields.difficulty.options;
                const difficultyMap = {
                    'beginner': 'åˆçº§',
                    'intermediate': 'ä¸­çº§',
                    'advanced': 'é«˜çº§'
                };
                
                // å¦‚æœé…ç½®ä¸­æœ‰è‡ªå®šä¹‰æ˜ å°„ï¼Œä½¿ç”¨é…ç½®ä¸­çš„æ˜ å°„
                if (difficultyOptions.includes(difficulty)) {
                    return difficultyMap[difficulty] || difficulty;
                }
            }
            
            // é»˜è®¤éš¾åº¦æ˜ å°„
            const defaultDifficultyMap = {
                'beginner': 'åˆçº§',
                'intermediate': 'ä¸­çº§',
                'advanced': 'é«˜çº§'
            };
            return defaultDifficultyMap[difficulty] || difficulty;
        }

        // ç”Ÿæˆæ–‡æ¡£ç›®å½•ï¼ˆåŸºäºæ ‡é¢˜h1-h6ï¼‰
        function generateTableOfContents(contentElement) {
            const tableOfContents = document.getElementById('table-of-contents');
            const tocList = document.getElementById('toc-list');

            if (!tableOfContents || !tocList || !contentElement) {
                return;
            }

            const headings = contentElement.querySelectorAll('h1, h2, h3, h4, h5, h6');
            console.log(`æ‰¾åˆ° ${headings.length} ä¸ªæ ‡é¢˜ç”¨äºç”Ÿæˆç›®å½•`);

            if (headings.length === 0) {
                tableOfContents.style.display = 'none';
                return;
            }

            tocList.innerHTML = '';

            headings.forEach((heading, index) => {
                // ä¸ºæ²¡æœ‰IDçš„æ ‡é¢˜è‡ªåŠ¨ç”ŸæˆID
                if (!heading.id) {
                    heading.id = `heading-${index}`;
                }

                // åˆ›å»ºç›®å½•é¡¹
                const li = document.createElement('li');
                const a = document.createElement('a');
                a.href = `#${heading.id}`;
                a.textContent = heading.textContent;

                // æ ¹æ®æ ‡é¢˜çº§åˆ«è®¾ç½®ç¼©è¿›
                const level = parseInt(heading.tagName.substring(1));
                a.style.paddingLeft = `${(level - 1) * 15}px`;

                li.appendChild(a);
                tocList.appendChild(li);

                // æ·»åŠ å¹³æ»‘æ»šåŠ¨æ•ˆæœ
                a.addEventListener('click', function (e) {
                    e.preventDefault();
                    const targetElement = document.getElementById(heading.id);
                    if (targetElement) {
                        // è®¡ç®—æ»šåŠ¨ä½ç½®ï¼Œè€ƒè™‘å›ºå®šå¤´éƒ¨é«˜åº¦
                        const headerHeight = document.querySelector('.site-header').offsetHeight;
                        const targetPosition = targetElement.offsetTop - headerHeight - 20;

                        window.scrollTo({
                            top: targetPosition,
                            behavior: 'smooth'
                        });
                    }
                });
            });

            tableOfContents.style.display = 'block';
            console.log('ç›®å½•ç”Ÿæˆå®Œæˆ');
        }

        // æ£€æŸ¥åˆ†ç±»æ˜¯å¦æœ‰æ–‡æ¡£
	        function categoryHasDocuments(categoryKey) {
	            console.log(`æ£€æŸ¥åˆ†ç±» ${categoryKey} æ˜¯å¦æœ‰æ–‡æ¡£`);

            // é¦–å…ˆæ£€æŸ¥ALL_DOCSä¸­æ˜¯å¦æœ‰è¯¥åˆ†ç±»çš„æ–‡æ¡£
            if (ALL_DOCS && ALL_DOCS.length > 0) {
                const docsInCategory = ALL_DOCS.filter(doc => doc.category === categoryKey);
                if (docsInCategory.length > 0) {
                    console.log(`åœ¨ALL_DOCSä¸­æ‰¾åˆ° ${docsInCategory.length} ä¸ª ${categoryKey} åˆ†ç±»çš„æ–‡æ¡£`);
                    return true;
                }
            }

            // å¦‚æœALL_DOCSä¸­æ²¡æœ‰ï¼Œæ£€æŸ¥é…ç½®æ–‡ä»¶
            if (!VIEWER_DOC_CONFIG || !VIEWER_DOC_CONFIG.categories || !VIEWER_DOC_CONFIG.categories[categoryKey]) {
                console.log(`é…ç½®æ–‡ä»¶ä¸­æ²¡æœ‰æ‰¾åˆ°åˆ†ç±» ${categoryKey}`);
                return false;
            }

            const categoryTopics = VIEWER_DOC_CONFIG.categories[categoryKey].topics || {};
            console.log(`åˆ†ç±» ${categoryKey} ä¸‹çš„ä¸»é¢˜:`, Object.keys(categoryTopics));

            // æ£€æŸ¥è¯¥åˆ†ç±»ä¸‹æ˜¯å¦æœ‰ä»»ä½•ä¸»é¢˜åŒ…å«æ–‡æ¡£
            for (const topicKey in categoryTopics) {
                const topic = categoryTopics[topicKey];
                if (topic.files && topic.files.length > 0) {
                    console.log(`ä¸»é¢˜ ${topicKey} ä¸‹æœ‰ ${topic.files.length} ä¸ªæ–‡æ¡£`);
                    return true;
                }
            }

	            console.log(`åˆ†ç±» ${categoryKey} æ²¡æœ‰æ‰¾åˆ°ä»»ä½•æ–‡æ¡£`);
	            return false;
	        }

	        // Learn é£æ ¼ï¼šæŒ‰ docs/ æ–‡ä»¶å¤¹ç»“æ„ç”Ÿæˆæ ‘å½¢å¯¼èˆªï¼ˆæ¡Œé¢ä¾§è¾¹æ  + ç§»åŠ¨ç«¯å¯¼èˆªå…±ç”¨ï¼‰
	        function renderLearnFolderTreeNavigation(rootUl, options) {
	            const opts = options || {};
	            const docs = Array.isArray(opts.docs) ? opts.docs : ALL_DOCS;
	            const onLinkClick = typeof opts.onLinkClick === 'function' ? opts.onLinkClick : null;
	            const defaultCollapseDepth = Number.isFinite(opts.defaultCollapseDepth) ? opts.defaultCollapseDepth : 1;

	            if (!rootUl) return;
	            rootUl.innerHTML = '';
	            rootUl.classList.add('learn-tree-root');

	            function normalizePath(p) {
	                return String(p || '')
	                    .replace(/\\/g, '/')
	                    .replace(/^\.\//, '')
	                    .replace(/^\/+/, '')
	                    .trim();
	            }

	            function compareName(a, b) {
	                try {
	                    return String(a).localeCompare(String(b), 'zh-Hans-CN', { numeric: true, sensitivity: 'base' });
	                } catch (e) {
	                    return String(a).localeCompare(String(b));
	                }
	            }

	            function getCurrentFileParam() {
	                try {
	                    const url = new URL(window.location.href);
	                    const raw = url.searchParams.get('file') || '';
	                    return normalizePath(decodeURIComponent(raw));
	                } catch (e) {
	                    return '';
	                }
	            }

	            function getCollapsedStateOrNull(type, key) {
	                try {
	                    const storageKey = `docsViewerSidebar${type.charAt(0).toUpperCase() + type.slice(1)}${key.charAt(0).toUpperCase() + key.slice(1)}`;
	                    const state = localStorage.getItem(storageKey);
	                    if (state === null) return null;
	                    return state === 'true';
	                } catch (error) {
	                    return null;
	                }
	            }

	            const currentFilePath = normalizePath(opts.currentFilePath || getCurrentFileParam());
	            const activeAncestors = new Set();
	            if (currentFilePath) {
	                const parts = currentFilePath.split('/').filter(Boolean);
	                if (parts.length > 1) {
	                    let acc = '';
	                    for (let i = 0; i < parts.length - 1; i++) {
	                        acc = acc ? (acc + '/' + parts[i]) : parts[i];
	                        activeAncestors.add(acc);
	                    }
	                }
	            }

	            function createTreeNode(name, type) {
	                return {
	                    name: name,
	                    type: type,
	                    children: Object.create(null),
	                    doc: null
	                };
	            }

	            function buildFolderTree(list) {
	                const root = createTreeNode('', 'root');
	                (list || []).forEach(function (doc) {
	                    const rawPath = normalizePath((doc && (doc.path || doc.filename)) || '');
	                    if (!rawPath) return;
	                    const parts = rawPath.split('/').filter(Boolean);
	                    if (parts.length === 0) return;

	                    let node = root;
	                    for (let i = 0; i < parts.length; i++) {
	                        const part = parts[i];
	                        const isLeaf = i === parts.length - 1;
	                        if (isLeaf) {
	                            const fileNode = createTreeNode(part, 'file');
	                            fileNode.doc = doc;
	                            if (fileNode.doc) fileNode.doc.__normalizedPath = rawPath;
	                            node.children[part] = fileNode;
	                        } else {
	                            if (!node.children[part]) {
	                                node.children[part] = createTreeNode(part, 'folder');
	                            }
	                            node = node.children[part];
	                        }
	                    }
	                });
	                return root;
	            }

	            function setFolderCollapsedDom(folderLi, collapsed, persist) {
	                folderLi.dataset.collapsed = collapsed ? '1' : '0';
	                const toggleBtn = folderLi.querySelector(':scope > .learn-tree-row .learn-tree-toggle');
	                if (toggleBtn) toggleBtn.setAttribute('aria-expanded', collapsed ? 'false' : 'true');

	                if (persist) {
	                    const folderKey = folderLi.dataset.folderKey || '';
	                    if (folderKey) setCollapsedState('folder', folderKey, collapsed);
	                }
	            }

	            function appendTreeGuides(container, ancestorLast, isLast, depth) {
	                if (!container || !depth) return;
	                var ancestor = Array.isArray(ancestorLast) ? ancestorLast : [];
	                var ancestorCols = Math.max(depth - 1, 0);

	                for (var i = 0; i < ancestorCols; i++) {
	                    var col = document.createElement('span');
	                    col.className = 'learn-tree-guide' + (ancestor[i] ? '' : ' has-vertical');
	                    container.appendChild(col);
	                }

	                var current = document.createElement('span');
	                current.className = 'learn-tree-guide current has-vertical' + (isLast ? ' is-last' : '');
	                container.appendChild(current);
	            }

	            function renderTree(parentUl, treeNode, parentPath, depth, ancestorLast) {
	                var ancestor = Array.isArray(ancestorLast) ? ancestorLast : [];
	                const names = Object.keys(treeNode.children || {}).sort(compareName);
	                const folderNames = names.filter(function (n) { return treeNode.children[n].type === 'folder'; });
	                const fileNames = names.filter(function (n) { return treeNode.children[n].type === 'file'; });

	                folderNames.forEach(function (folderName) {
	                    var isLast = (folderName === folderNames[folderNames.length - 1]) && fileNames.length === 0;
	                    const folderNode = treeNode.children[folderName];
	                    const folderPath = parentPath ? (parentPath + '/' + folderName) : folderName;
	                    const folderKey = encodeURIComponent(folderPath);

	                    const li = document.createElement('li');
	                    li.className = 'learn-tree-folder';
	                    li.dataset.folderPath = folderPath;
	                    li.dataset.folderKey = folderKey;
	                    li.dataset.depth = String(depth);

	                    const row = document.createElement('div');
	                    row.className = 'learn-tree-row learn-tree-folder-row';

	                    const label = document.createElement('span');
	                    label.className = 'learn-tree-label';
	                    label.textContent = folderName;

	                    const guides = document.createElement('span');
	                    guides.className = 'learn-tree-guides';
	                    guides.setAttribute('aria-hidden', 'true');
	                    appendTreeGuides(guides, ancestor, isLast, depth);

	                    const toggle = document.createElement('button');
	                    toggle.type = 'button';
	                    toggle.className = 'learn-tree-toggle';
	                    toggle.setAttribute('aria-label', 'å±•å¼€/æ”¶èµ·');
	                    toggle.textContent = 'â–¾';

	                    const item = document.createElement('span');
	                    item.className = 'learn-tree-item';
	                    item.appendChild(toggle);
	                    item.appendChild(label);

	                    row.appendChild(guides);
	                    row.appendChild(item);
	                    li.appendChild(row);

	                    const childrenUl = document.createElement('ul');
	                    childrenUl.className = 'learn-tree-children';
	                    li.appendChild(childrenUl);

	                    renderTree(childrenUl, folderNode, folderPath, depth + 1, ancestor.concat([isLast]));

	                    const storedCollapsed = getCollapsedStateOrNull('folder', folderKey);
	                    const collapsed = (storedCollapsed === null ? depth >= defaultCollapseDepth : storedCollapsed) && !activeAncestors.has(folderPath);
	                    setFolderCollapsedDom(li, collapsed, false);

	                    function onToggle(e) {
	                        if (e) e.stopPropagation();
	                        const nowCollapsed = li.dataset.collapsed !== '1';
	                        setFolderCollapsedDom(li, nowCollapsed, true);
	                    }

	                    row.addEventListener('click', onToggle);
	                    toggle.addEventListener('click', onToggle);

	                    parentUl.appendChild(li);
	                });

	                fileNames.forEach(function (fileName) {
	                    var isLast = fileName === fileNames[fileNames.length - 1];
	                    const fileNode = treeNode.children[fileName];
	                    const doc = (fileNode && fileNode.doc) || {};
	                    const docPath = normalizePath(doc.__normalizedPath || doc.path || doc.filename);
	                    if (!docPath) return;

	                    const li = document.createElement('li');
	                    li.className = 'learn-tree-file';
	                    li.dataset.depth = String(depth);

	                    const link = document.createElement('a');
	                    link.className = 'learn-tree-link';
	                    link.href = `?file=${encodeURIComponent(docPath)}`;

	                    const guides = document.createElement('span');
	                    guides.className = 'learn-tree-guides';
	                    guides.setAttribute('aria-hidden', 'true');
	                    appendTreeGuides(guides, ancestor, isLast, depth);

	                    const label = document.createElement('span');
	                    label.className = 'learn-tree-link-label';
	                    label.textContent = doc.title || fileName.replace(/\.md$/i, '');

	                    const spacer = document.createElement('span');
	                    spacer.className = 'learn-tree-toggle-spacer';
	                    spacer.setAttribute('aria-hidden', 'true');

	                    const item = document.createElement('span');
	                    item.className = 'learn-tree-item';
	                    item.appendChild(spacer);
	                    item.appendChild(label);

	                    link.appendChild(guides);
	                    link.appendChild(item);

	                    link.title = `${doc.author || 'æœªçŸ¥ä½œè€…'} - ${doc.description || doc.title || link.textContent}`;

	                    if (currentFilePath && normalizePath(docPath) === currentFilePath) {
	                        link.classList.add('active');
	                    }

	                    if (onLinkClick) {
	                        link.addEventListener('click', function () {
	                            onLinkClick();
	                        });
	                    }

	                    li.appendChild(link);
	                    parentUl.appendChild(li);
	                });
	            }

	            const tree = buildFolderTree(docs);
	            renderTree(rootUl, tree, '', 0);
	        }

	        // åˆå§‹åŒ–åˆ†ç±»å¯¼èˆª
	        function initializeCategoryNavigation() {
	            console.log('=== initializeCategoryNavigation() å¼€å§‹ ===');
	            const categorySidebar = document.getElementById('category-sidebar');

            if (!categorySidebar) {
                console.error('æ‰¾ä¸åˆ°åˆ†ç±»ä¾§è¾¹æ å…ƒç´ ');
                return;
            }

            // æ¸…ç©ºç°æœ‰å¯¼èˆª
            categorySidebar.innerHTML = '';

	            // ç­‰å¾…é…ç½®åŠ è½½å®Œæˆ
	            if (!VIEWER_DOC_CONFIG || !ALL_DOCS || ALL_DOCS.length === 0) {
	                console.warn('æ–‡æ¡£é…ç½®å°šæœªåŠ è½½ï¼Œç¨åé‡è¯•');
	                setTimeout(initializeCategoryNavigation, 100);
	                return;
	            }

		            // Learn é£æ ¼ï¼šæŒ‰ docs/ æ–‡ä»¶å¤¹ç»“æ„ç”Ÿæˆæ ‘å½¢å¯¼èˆª
		            renderLearnFolderTreeNavigation(categorySidebar, { docs: ALL_DOCS, defaultCollapseDepth: 1 });
		            return;

            console.log('DOC_CONFIGå·²åŠ è½½ï¼Œå¼€å§‹ç”Ÿæˆåˆ†ç±»å¯¼èˆª');
            console.log('ALL_DOCSæ•°é‡:', ALL_DOCS.length);
            console.log('å¯ç”¨åˆ†ç±»:', Object.keys(MAIN_CATEGORIES));

            // æ·»åŠ åˆ†å‰²çº¿
            const divider = document.createElement('div');
            divider.className = 'sidebar-divider';
            categorySidebar.appendChild(divider);

            // ç”Ÿæˆåˆ†ç±»å¯¼èˆª
            let visibleCategories = 0;
            Object.keys(MAIN_CATEGORIES).forEach(categoryKey => {
                const category = MAIN_CATEGORIES[categoryKey];
                console.log(`å¤„ç†åˆ†ç±»: ${categoryKey} (${category.title})`);

                // æ£€æŸ¥è¯¥åˆ†ç±»æ˜¯å¦æœ‰æ–‡æ¡£ï¼Œå¦‚æœæ²¡æœ‰åˆ™è·³è¿‡
                if (!categoryHasDocuments(categoryKey)) {
                    console.log(`è·³è¿‡ç©ºåˆ†ç±»: ${categoryKey}`);
                    return; // è·³è¿‡ç©ºåˆ†ç±»
                }

                visibleCategories++;
                console.log(`æ˜¾ç¤ºåˆ†ç±»: ${categoryKey}`);

                // åˆ›å»ºåˆ†ç±»å¯¼èˆªé¡¹
                const categoryItem = document.createElement('li');
                categoryItem.className = 'category-item';

                // åˆ›å»ºåˆ†ç±»æ ‡é¢˜
                const categoryHeader = document.createElement('h4');
                categoryHeader.className = 'category-header';

                // æ·»åŠ åˆ†ç±»æ ‡é¢˜æ–‡æœ¬
                const titleSpan = document.createElement('span');
                titleSpan.className = 'category-title-text';
                titleSpan.textContent = category.title;
                categoryHeader.appendChild(titleSpan);

                // æ·»åŠ å±•å¼€/æ”¶èµ·æŒ‰é’®
                const toggleBtn = document.createElement('button');
                toggleBtn.className = 'category-toggle';
                toggleBtn.setAttribute('aria-label', 'å±•å¼€/æ”¶èµ·åˆ†ç±»');
                toggleBtn.innerHTML = 'â–¼';
                categoryHeader.appendChild(toggleBtn);

                categoryItem.appendChild(categoryHeader);

                // åˆ›å»ºä¸»é¢˜å­èœå•
                const topicList = document.createElement('ul');
                topicList.className = 'topic-list';

                // è·å–è¯¥åˆ†ç±»ä¸‹çš„æ‰€æœ‰ä¸»é¢˜
                const categoryTopics = VIEWER_DOC_CONFIG.categories[categoryKey]?.topics || {};

                if (Object.keys(categoryTopics).length > 0) {
                    Object.keys(categoryTopics).forEach(topicKey => {
                        const topic = categoryTopics[topicKey];

                        // æ£€æŸ¥ä¸»é¢˜æ˜¯å¦æœ‰æ–‡æ¡£ï¼Œå¦‚æœæ²¡æœ‰åˆ™è·³è¿‡
                        if (!topic.files || topic.files.length === 0) {
                            return; // è·³è¿‡ç©ºä¸»é¢˜
                        }

                        // åˆ›å»ºä¸»é¢˜æ ‡é¢˜
                        const topicHeader = document.createElement('h5');
                        topicHeader.className = 'topic-header';

                        // æ·»åŠ ä¸»é¢˜æ ‡é¢˜æ–‡æœ¬
                        const topicTitleSpan = document.createElement('span');
                        topicTitleSpan.className = 'topic-title-text';
                        topicTitleSpan.textContent = topic.title;
                        topicHeader.appendChild(topicTitleSpan);

                        // æ·»åŠ å±•å¼€/æ”¶èµ·æŒ‰é’®
                        const topicToggleBtn = document.createElement('button');
                        topicToggleBtn.className = 'topic-toggle';
                        topicToggleBtn.setAttribute('aria-label', 'å±•å¼€/æ”¶èµ·ä¸»é¢˜');
                        topicToggleBtn.innerHTML = 'â–¼';
                        topicHeader.appendChild(topicToggleBtn);

                        // ä¸ºä¸»é¢˜æ ‡é¢˜æ·»åŠ ç‚¹å‡»äº‹ä»¶
                        topicHeader.addEventListener('click', function () {
                            toggleTopic(categoryKey, topicKey, topicHeader, topicHeader.nextElementSibling);
                        });

                        // ä¸ºä¸»é¢˜æ ‡é¢˜çš„æŒ‰é’®æ·»åŠ ç‚¹å‡»äº‹ä»¶
                        topicToggleBtn.addEventListener('click', function (e) {
                            e.stopPropagation();
                            toggleTopic(categoryKey, topicKey, topicHeader, topicHeader.nextElementSibling);
                        });

                        topicList.appendChild(topicHeader);

                        // åˆ›å»ºæ–‡æ¡£åˆ—è¡¨
                        const fileList = document.createElement('ul');
                        fileList.className = 'file-list';

                        // ç¡®ä¿topic.fileså­˜åœ¨ä¸”æ˜¯æ•°ç»„
                        const files = topic.files || [];
                        files.forEach(file => {
                            const fileItem = document.createElement('li');
                            fileItem.className = 'file-item';

	                            const fileLink = document.createElement('a');
	                            fileLink.href = `?file=${encodeURIComponent(file.path || file.filename)}`;
	                            fileLink.textContent = file.title;
	                            fileLink.title = `${file.author || 'æœªçŸ¥'} - ${file.description || file.title}`;

                            fileItem.appendChild(fileLink);
                            fileList.appendChild(fileItem);
                        });

                        topicList.appendChild(fileList);
                    });
                }

                categoryItem.appendChild(topicList);
                categorySidebar.appendChild(categoryItem);

                // ä¸ºåˆ†ç±»æ ‡é¢˜æ·»åŠ ç‚¹å‡»äº‹ä»¶
                categoryHeader.addEventListener('click', function () {
                    toggleCategory(categoryKey, categoryHeader, topicList);
                });

                // ä¸ºåˆ†ç±»æ ‡é¢˜çš„æŒ‰é’®æ·»åŠ ç‚¹å‡»äº‹ä»¶
                toggleBtn.addEventListener('click', function (e) {
                    e.stopPropagation();
                    toggleCategory(categoryKey, categoryHeader, topicList);
                });

                // æ¢å¤åˆ†ç±»çš„å±•å¼€/æ”¶èµ·çŠ¶æ€
                const isCollapsed = getCollapsedState('category', categoryKey);
                if (isCollapsed) {
                    topicList.classList.add('collapsed');
                    toggleBtn.classList.add('collapsed');
                    // toggleBtn.innerHTML = 'â–¶';
                } else {
                    toggleBtn.innerHTML = 'â–¼';
                }
            });

            // æ·»åŠ åˆ†å‰²çº¿
            const allDocsDivider = document.createElement('div');
            allDocsDivider.className = 'sidebar-divider';
            categorySidebar.appendChild(allDocsDivider);

            // æ·»åŠ "æ‰€æœ‰æ–‡æ¡£"éƒ¨åˆ†
            const allDocsItem = document.createElement('li');
            allDocsItem.className = 'category-item all-docs';

            const allDocsHeader = document.createElement('h4');
            allDocsHeader.className = 'category-header';

            // æ·»åŠ "æ‰€æœ‰æ–‡æ¡£"æ ‡é¢˜æ–‡æœ¬
            const allDocsTitleSpan = document.createElement('span');
            allDocsTitleSpan.className = 'category-title-text';
            allDocsTitleSpan.textContent = 'æ‰€æœ‰æ–‡æ¡£';
            allDocsHeader.appendChild(allDocsTitleSpan);

            // æ·»åŠ å±•å¼€/æ”¶èµ·æŒ‰é’®
            const allDocsToggleBtn = document.createElement('button');
            allDocsToggleBtn.className = 'category-toggle';
            allDocsToggleBtn.setAttribute('aria-label', 'å±•å¼€/æ”¶èµ·æ‰€æœ‰æ–‡æ¡£');
            allDocsToggleBtn.innerHTML = 'â–¼';
            allDocsHeader.appendChild(allDocsToggleBtn);

            allDocsItem.appendChild(allDocsHeader);

            const allDocsList = document.createElement('ul');
            allDocsList.className = 'file-list';

            // ç¡®ä¿ALL_DOCSå­˜åœ¨ä¸”æ˜¯æ•°ç»„
            const allDocs = ALL_DOCS || [];
            if (allDocs.length === 0) {
                // å¦‚æœæ²¡æœ‰æ–‡æ¡£ï¼Œæ˜¾ç¤ºæç¤ºä¿¡æ¯
                const noDocsItem = document.createElement('li');
                noDocsItem.className = 'no-docs';
                noDocsItem.textContent = 'æœªæ‰¾åˆ°ä»»ä½•æ–‡æ¡£';
                allDocsList.appendChild(noDocsItem);
            } else {
                // æŒ‰åˆ†ç±»å’Œæ’åºç»„ç»‡æ–‡æ¡£
                const sortedDocs = [...allDocs].sort((a, b) => {
                    // å…ˆæŒ‰åˆ†ç±»æ’åº
                    const categoryOrderA = MAIN_CATEGORIES[a.category]?.order ?? 999;
                    const categoryOrderB = MAIN_CATEGORIES[b.category]?.order ?? 999;
                    if (categoryOrderA !== categoryOrderB) {
                        return categoryOrderA - categoryOrderB;
                    }
                    // åŒä¸€åˆ†ç±»å†…æŒ‰æ’åºå€¼æ’åº
                    return (a.order ?? 999) - (b.order ?? 999);
                });

                sortedDocs.forEach(doc => {
                    const docItem = document.createElement('li');
                    docItem.className = 'file-item';

	                    const docLink = document.createElement('a');
	                    docLink.href = `?file=${encodeURIComponent(doc.path || doc.filename)}`;
	                    docLink.textContent = doc.title;

                    // æ·»åŠ æ›´è¯¦ç»†çš„æ ‡é¢˜ä¿¡æ¯
                    const categoryTitle = MAIN_CATEGORIES[doc.category]?.title || doc.category;
                    const topicTitle = VIEWER_DOC_CONFIG.topics[doc.topic]?.title || doc.topic;
                    const pathInfo = doc.path && doc.path !== doc.filename ? ` [è·¯å¾„: ${doc.path}]` : '';
                    docLink.title = `${doc.author || 'æœªçŸ¥ä½œè€…'} - ${doc.description || doc.title} [${categoryTitle} - ${topicTitle}]${pathInfo}`;

                    docItem.appendChild(docLink);
                    allDocsList.appendChild(docItem);
                });
            }

            allDocsItem.appendChild(allDocsList);
            categorySidebar.appendChild(allDocsItem);

            // ä¸º"æ‰€æœ‰æ–‡æ¡£"æ ‡é¢˜æ·»åŠ ç‚¹å‡»äº‹ä»¶
            allDocsHeader.addEventListener('click', function () {
                toggleAllDocs(allDocsHeader, allDocsList);
            });

            // ä¸º"æ‰€æœ‰æ–‡æ¡£"æ ‡é¢˜çš„æŒ‰é’®æ·»åŠ ç‚¹å‡»äº‹ä»¶
            allDocsToggleBtn.addEventListener('click', function (e) {
                e.stopPropagation();
                toggleAllDocs(allDocsHeader, allDocsList);
            });

            // æ¢å¤"æ‰€æœ‰æ–‡æ¡£"çš„å±•å¼€/æ”¶èµ·çŠ¶æ€
            const isAllDocsCollapsed = getCollapsedState('all-docs', 'all-docs');
            if (isAllDocsCollapsed) {
                allDocsList.classList.add('collapsed');
                allDocsToggleBtn.classList.add('collapsed');
                // allDocsToggleBtn.innerHTML = 'â–¶';
            } else {
                allDocsToggleBtn.innerHTML = 'â–¼';
            }
        }

        // å±•å¼€/æ”¶èµ·åˆ†ç±»
        function toggleCategory(categoryKey, categoryHeader, topicList) {
            const isCollapsed = topicList.classList.contains('collapsed');
            const toggleBtn = categoryHeader.querySelector('.category-toggle');

            if (isCollapsed) {
                // å±•å¼€
                topicList.classList.remove('collapsed');
                toggleBtn.classList.remove('collapsed');
                toggleBtn.innerHTML = 'â–¼';
                setCollapsedState('category', categoryKey, false);
            } else {
                // æ”¶èµ·
                topicList.classList.add('collapsed');
                toggleBtn.classList.add('collapsed');
                // toggleBtn.innerHTML = 'â–¶';
                setCollapsedState('category', categoryKey, true);
            }
        }

        // å±•å¼€/æ”¶èµ·ä¸»é¢˜
        function toggleTopic(categoryKey, topicKey, topicHeader, fileList) {
            const isCollapsed = fileList.classList.contains('collapsed');
            const toggleBtnArray = topicHeader.querySelectorAll('.topic-toggle');

            for (let i = 0; i < toggleBtnArray.length; i++) {
                const toggleBtn = toggleBtnArray[i];
                if (isCollapsed) {
                    // å±•å¼€
                    fileList.classList.remove('collapsed');
                    toggleBtn.classList.remove('collapsed');
                    toggleBtn.innerHTML = 'â–¼';  // æ·»åŠ è¿™è¡Œ
                    setCollapsedState('topic', `${categoryKey}-${topicKey}`, false);
                } else {
                    // æ”¶èµ·
                    fileList.classList.add('collapsed');
                    toggleBtn.classList.add('collapsed');
                    // toggleBtn.innerHTML = 'â–¶';  // æ·»åŠ è¿™è¡Œ
                    setCollapsedState('topic', `${categoryKey}-${topicKey}`, true);
                }
            }
        }

        // å±•å¼€/æ”¶èµ·"æ‰€æœ‰æ–‡æ¡£"
        function toggleAllDocs(allDocsHeader, allDocsList) {
            const isCollapsed = allDocsList.classList.contains('collapsed');
            const toggleBtn = allDocsHeader.querySelector('.category-toggle');

            if (isCollapsed) {
                // å±•å¼€
                allDocsList.classList.remove('collapsed');
                toggleBtn.classList.remove('collapsed');
                toggleBtn.innerHTML = 'â–¼';  // æ·»åŠ è¿™è¡Œ
                setCollapsedState('all-docs', 'all-docs', false);
            } else {
                // æ”¶èµ·
                allDocsList.classList.add('collapsed');
                toggleBtn.classList.add('collapsed');
                // toggleBtn.innerHTML = 'â–¶';  // æ·»åŠ è¿™è¡Œ
                setCollapsedState('all-docs', 'all-docs', true);
            }
        }



        // ä»localStorageè·å–å±•å¼€/æ”¶èµ·çŠ¶æ€
        function getCollapsedState(type, key) {
            try {
                const storageKey = `docsViewerSidebar${type.charAt(0).toUpperCase() + type.slice(1)}${key.charAt(0).toUpperCase() + key.slice(1)}`;
                const state = localStorage.getItem(storageKey);
                return state === 'true';
            } catch (error) {
                console.warn('æ— æ³•ä»localStorageè·å–å±•å¼€/æ”¶èµ·çŠ¶æ€:', error);
                return false;
            }
        }

        // ä¿å­˜å±•å¼€/æ”¶èµ·çŠ¶æ€åˆ°localStorage
        function setCollapsedState(type, key, isCollapsed) {
            try {
                const storageKey = `docsViewerSidebar${type.charAt(0).toUpperCase() + type.slice(1)}${key.charAt(0).toUpperCase() + key.slice(1)}`;
                localStorage.setItem(storageKey, isCollapsed.toString());
            } catch (error) {
                console.warn('æ— æ³•ä¿å­˜å±•å¼€/æ”¶èµ·çŠ¶æ€åˆ°localStorage:', error);
            }
        }

        // åˆå§‹åŒ–ä¸‹æ‹‰èœå•
        function initializeDropdownMenu() {
            const dropdownToggle = document.querySelector('.dropdown-toggle');
            const dropdownMenu = document.querySelector('.dropdown-menu');

            if (!dropdownToggle || !dropdownMenu) return;

            // ç‚¹å‡»åˆ‡æ¢ä¸‹æ‹‰èœå•
            dropdownToggle.addEventListener('click', function (e) {
                e.preventDefault();
                dropdownMenu.classList.toggle('show');
            });

            // ç‚¹å‡»å…¶ä»–åœ°æ–¹å…³é—­ä¸‹æ‹‰èœå•
            document.addEventListener('click', function (e) {
                if (!dropdownToggle.contains(e.target) && !dropdownMenu.contains(e.target)) {
                    dropdownMenu.classList.remove('show');
                }
            });
        }

        // æ›´æ–°å½“å‰åˆ†ç±»çš„æ–‡æ¡£åˆ—è¡¨
	        function updateCurrentCategoryDocs(filePath) {
	            const currentCategoryTitle = document.getElementById('current-category-title');
	            const currentCategoryDocs = document.getElementById('current-category-docs');

            if (!currentCategoryTitle || !currentCategoryDocs) return;

            // ç­‰å¾…é…ç½®åŠ è½½å®Œæˆ
            if (!VIEWER_DOC_CONFIG || !ALL_DOCS || ALL_DOCS.length === 0) {
                console.warn('æ–‡æ¡£é…ç½®å°šæœªåŠ è½½ï¼Œç¨åé‡è¯•');
                setTimeout(() => updateCurrentCategoryDocs(filePath), 100);
                return;
            }

	            function normalizePath(p) {
	                return String(p || '')
	                    .replace(/\\/g, '/')
	                    .replace(/^\.\//, '')
	                    .replace(/^\/+/, '')
	                    .trim();
	            }

	            function getFolderOfPath(p) {
	                const parts = normalizePath(p).split('/').filter(Boolean);
	                if (parts.length <= 1) return '';
	                return parts.slice(0, -1).join('/');
	            }

	            function compareName(a, b) {
	                try {
	                    return String(a).localeCompare(String(b), 'zh-Hans-CN', { numeric: true, sensitivity: 'base' });
	                } catch (e) {
	                    return String(a).localeCompare(String(b));
	                }
	            }

	            const normalizedFilePath = normalizePath(filePath);

		            // æŸ¥æ‰¾å½“å‰æ–‡æ¡£ä¿¡æ¯ï¼ˆæ”¯æŒ filename æˆ– pathï¼‰
		            const currentDoc = ALL_DOCS.find(doc => {
		                const p = normalizePath(doc.path || doc.filename);
		                return p === normalizedFilePath;
		            });

	            if (!currentDoc) {
	                // å¦‚æœæ‰¾ä¸åˆ°æ–‡æ¡£ï¼Œæ˜¾ç¤ºæ‰€æœ‰æ–‡æ¡£
	                currentCategoryTitle.textContent = 'æ‰€æœ‰æ–‡æ¡£';
	                currentCategoryDocs.innerHTML = '';

	                // æŒ‰è·¯å¾„ + æ ‡é¢˜ç»„ç»‡æ–‡æ¡£ï¼ˆä¸æ–‡ä»¶å¤¹æ ‘ä¸€è‡´ï¼‰
	                const sortedDocs = [...ALL_DOCS].sort((a, b) => {
	                    const ap = normalizePath(a.path || a.filename);
	                    const bp = normalizePath(b.path || b.filename);
	                    if (ap !== bp) return compareName(ap, bp);
	                    return compareName(a.title || '', b.title || '');
	                });

	                sortedDocs.forEach(doc => {
	                    const li = document.createElement('li');
	                    const link = document.createElement('a');
		                    link.href = `?file=${encodeURIComponent(normalizePath(doc.path || doc.filename))}`;
		                    link.textContent = doc.title;
		                    link.title = `${doc.author || 'æœªçŸ¥ä½œè€…'} - ${doc.description || doc.title}`;

		                    if (normalizePath(doc.path || doc.filename) === normalizedFilePath) {
		                        link.classList.add('active');
		                    }

	                    li.appendChild(link);
	                    currentCategoryDocs.appendChild(li);
                });

                return;
            }

	            // Learn é£æ ¼ï¼šæ˜¾ç¤ºâ€œå½“å‰æ–‡ä»¶å¤¹â€çš„åŒçº§æ–‡æ¡£
	            const currentDocPath = normalizePath(currentDoc.path || currentDoc.filename);
	            const currentFolder = getFolderOfPath(currentDocPath);
	            const folderLabel = currentFolder ? currentFolder : 'æ ¹ç›®å½•';
	            currentCategoryTitle.textContent = `å½“å‰æ–‡ä»¶å¤¹ï¼š${folderLabel}`;

	            // æ¸…ç©ºç°æœ‰åˆ—è¡¨
	            currentCategoryDocs.innerHTML = '';

	            const siblingDocs = ALL_DOCS.filter(function (doc) {
	                const p = normalizePath(doc.path || doc.filename);
	                return getFolderOfPath(p) === currentFolder;
	            }).sort(function (a, b) {
	                const orderA = a.order ?? 999;
	                const orderB = b.order ?? 999;
	                if (orderA !== orderB) return orderA - orderB;
	                return compareName(a.title || '', b.title || '');
	            });

	            if (siblingDocs.length === 0) {
	                const li = document.createElement('li');
	                li.textContent = 'æœ¬æ–‡ä»¶å¤¹æš‚æ— å…¶å®ƒæ–‡æ¡£';
	                currentCategoryDocs.appendChild(li);
	                return;
	            }

	            siblingDocs.forEach(doc => {
	                const li = document.createElement('li');
	                const link = document.createElement('a');
	                const docPath = normalizePath(doc.path || doc.filename);
	                link.href = `?file=${encodeURIComponent(docPath)}`;
	                link.textContent = doc.title;
	                link.title = `${doc.author || 'æœªçŸ¥ä½œè€…'} - ${doc.description || doc.title}`;

	                if (docPath === normalizedFilePath) {
	                    link.classList.add('active');
	                }

	                li.appendChild(link);
	                currentCategoryDocs.appendChild(li);
	            });
	        }

        // åˆå§‹åŒ–æ‰‹æœºç«¯å¯¼èˆª
	        function initializeMobileNavigation() {
            const mobileNavToggle = document.getElementById('mobile-nav-toggle');
            const mobileNavOverlay = document.getElementById('mobile-nav-overlay');
            const mobileNavClose = document.getElementById('mobile-nav-close');
            const mobileNavBack = document.getElementById('mobile-nav-back');
            const mobileNavSections = document.getElementById('mobile-nav-sections');

            if (!mobileNavToggle || !mobileNavOverlay || !mobileNavClose || !mobileNavBack || !mobileNavSections) {
                return;
            }

            mobileNavToggle.setAttribute('aria-expanded', 'false');
            mobileNavOverlay.setAttribute('aria-hidden', 'true');

	            let lastFocusedElement = null;
	            let previousBodyOverflow = '';
	            let previousHtmlOverflow = '';

            function getFocusableElements(container) {
                const selectors = [
                    'a[href]',
                    'button:not([disabled])',
                    'input:not([disabled])',
                    'select:not([disabled])',
                    'textarea:not([disabled])',
                    '[tabindex]:not([tabindex="-1"])'
                ];
                return Array.from(container.querySelectorAll(selectors.join(','))).filter(el => {
                    return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
                });
            }

            function trapFocus(event) {
                if (!mobileNavOverlay.classList.contains('active')) return;
                if (event.key !== 'Tab') return;

                const focusable = getFocusableElements(mobileNavOverlay);
                if (focusable.length === 0) return;

                const first = focusable[0];
                const last = focusable[focusable.length - 1];
                const active = document.activeElement;

                if (event.shiftKey) {
                    if (active === first || !mobileNavOverlay.contains(active)) {
                        event.preventDefault();
                        last.focus();
                    }
                } else {
                    if (active === last) {
                        event.preventDefault();
                        first.focus();
                    }
                }
            }

            // æ£€æŸ¥æ˜¯å¦ä¸ºç§»åŠ¨è®¾å¤‡
            function isMobileDevice() {
                return window.innerWidth <= 768;
            }

            // è®¾ç½®åˆå§‹æ˜¾ç¤ºçŠ¶æ€
            updateMobileNavVisibility();

            // ç¡®ä¿åœ¨ç§»åŠ¨è®¾å¤‡ä¸Šä¹Ÿèƒ½æ­£å¸¸å·¥ä½œ
            if (isMobileDevice()) {
                console.log('æ£€æµ‹åˆ°ç§»åŠ¨è®¾å¤‡ï¼Œåˆå§‹åŒ–æ‰‹æœºç«¯å¯¼èˆª');
            }

            // ç”Ÿæˆæ‰‹æœºç«¯å¯¼èˆªå†…å®¹
            function generateMobileNavContent() {
                if (!VIEWER_DOC_CONFIG || ALL_DOCS.length === 0) {
                    console.warn('æ–‡æ¡£é…ç½®å°šæœªåŠ è½½ï¼Œç¨åé‡è¯•');
                    setTimeout(generateMobileNavContent, 100);
                    return;
                }

	                mobileNavSections.innerHTML = '';

	                // Learn é£æ ¼ï¼šç§»åŠ¨ç«¯ä¹Ÿä½¿ç”¨æ–‡ä»¶å¤¹æ ‘å¯¼èˆªï¼ˆä¸æ¡Œé¢ä¾§è¾¹æ ä¸€è‡´ï¼‰
	                const treeRoot = document.createElement('ul');
	                mobileNavSections.appendChild(treeRoot);
	                renderLearnFolderTreeNavigation(treeRoot, {
	                    docs: ALL_DOCS,
	                    defaultCollapseDepth: 1,
	                    onLinkClick: closeMobileNav
	                });
	            }

	            // æ‰“å¼€æ‰‹æœºç«¯å¯¼èˆª
		            function openMobileNav() {
		                lastFocusedElement = document.activeElement;
		                previousBodyOverflow = document.body.style.overflow || '';
		                previousHtmlOverflow = document.documentElement.style.overflow || '';
		                mobileNavOverlay.classList.add('active');
		                // é˜²æ­¢èƒŒæ™¯æ»šåŠ¨ï¼ˆç§»åŠ¨ç«¯éœ€è¦åŒæ—¶é”å®š html/body æ‰æ›´ç¨³å®šï¼‰
		                document.body.style.overflow = 'hidden';
		                document.documentElement.style.overflow = 'hidden';
		                generateMobileNavContent();
		                mobileNavToggle.setAttribute('aria-expanded', 'true');
		                mobileNavOverlay.setAttribute('aria-hidden', 'false');
		                mobileNavClose.focus();
		                document.addEventListener('keydown', trapFocus, true);
		            }

	            // å…³é—­æ‰‹æœºç«¯å¯¼èˆª
	            function closeMobileNav() {
	                mobileNavOverlay.classList.remove('active');
	                document.body.style.overflow = previousBodyOverflow; // æ¢å¤æ»šåŠ¨
	                document.documentElement.style.overflow = previousHtmlOverflow;
	                mobileNavToggle.setAttribute('aria-expanded', 'false');
	                mobileNavOverlay.setAttribute('aria-hidden', 'true');
	                document.removeEventListener('keydown', trapFocus, true);
	                if (lastFocusedElement && typeof lastFocusedElement.focus === 'function') {
	                    lastFocusedElement.focus();
                } else {
                    mobileNavToggle.focus();
                }
            }

            // ç»‘å®šäº‹ä»¶ç›‘å¬å™¨
            mobileNavToggle.addEventListener('click', openMobileNav);
            mobileNavClose.addEventListener('click', closeMobileNav);
            mobileNavBack.addEventListener('click', closeMobileNav);

            document.addEventListener('keydown', function (event) {
                if (event.key === 'Escape' && mobileNavOverlay.classList.contains('active')) {
                    closeMobileNav();
                }
            });

            // ç‚¹å‡»è¦†ç›–å±‚èƒŒæ™¯å…³é—­å¯¼èˆªï¼ˆé™¤äº†è¿”å›åŒºåŸŸï¼‰
            mobileNavOverlay.addEventListener('click', function (e) {
                if (e.target === mobileNavOverlay) {
                    closeMobileNav();
                }
            });

            // æ›´æ–°æ‰‹æœºç«¯å¯¼èˆªå¯è§æ€§
            function updateMobileNavVisibility() {
                if (isMobileDevice()) {
                    mobileNavToggle.style.display = 'flex';
                } else {
                    mobileNavToggle.style.display = 'none';
                    closeMobileNav(); // åœ¨éç§»åŠ¨è®¾å¤‡ä¸Šå…³é—­å¯¼èˆª
                }
            }

            // ç›‘å¬çª—å£å¤§å°å˜åŒ–
            window.addEventListener('resize', updateMobileNavVisibility);
        }

        function shouldRenderMobileTopicToggle(categoryKey, topicCount) {
            return topicCount > 1;
        }

        // ç§»åŠ¨ç«¯åˆ†ç±»å±•å¼€/æ”¶èµ·åŠŸèƒ½
        function toggleMobileCategory(categoryKey, categoryDiv, toggleBtn) {
            const isCollapsed = categoryDiv.classList.contains('collapsed');

            if (isCollapsed) {
                // å±•å¼€
                categoryDiv.classList.remove('collapsed');
                toggleBtn.classList.remove('collapsed');
                toggleBtn.innerHTML = 'â–¼';
                setMobileCollapsedState('category', categoryKey, false);
            } else {
                // æ”¶èµ·
                categoryDiv.classList.add('collapsed');
                toggleBtn.classList.add('collapsed');
                // toggleBtn.innerHTML = 'â–¶';
                setMobileCollapsedState('category', categoryKey, true);
            }
        }

        // ç§»åŠ¨ç«¯ä¸»é¢˜å±•å¼€/æ”¶èµ·åŠŸèƒ½
        function toggleMobileTopic(categoryKey, topicKey, topicDiv, toggleBtn) {
            const isCollapsed = topicDiv.classList.contains('collapsed');

            if (isCollapsed) {
                // å±•å¼€
                topicDiv.classList.remove('collapsed');
                if (toggleBtn) {
                    toggleBtn.classList.remove('collapsed');
                    toggleBtn.innerHTML = 'â–¼';
                }
                setMobileCollapsedState('topic', `${categoryKey}-${topicKey}`, false);
            } else {
                // æ”¶èµ·
                topicDiv.classList.add('collapsed');
                if (toggleBtn) {
                    toggleBtn.classList.add('collapsed');
                }
                // toggleBtn.innerHTML = 'â–¶';
                setMobileCollapsedState('topic', `${categoryKey}-${topicKey}`, true);
            }
        }

        // ç§»åŠ¨ç«¯"æ‰€æœ‰æ–‡æ¡£"å±•å¼€/æ”¶èµ·åŠŸèƒ½
        function toggleMobileAllDocs(allDocsDiv, toggleBtn) {
            const isCollapsed = allDocsDiv.classList.contains('collapsed');

            if (isCollapsed) {
                // å±•å¼€
                allDocsDiv.classList.remove('collapsed');
                toggleBtn.classList.remove('collapsed');
                toggleBtn.innerHTML = 'â–¼';
                setMobileCollapsedState('all-docs', 'all-docs', false);
            } else {
                // æ”¶èµ·
                allDocsDiv.classList.add('collapsed');
                toggleBtn.classList.add('collapsed');
                // toggleBtn.innerHTML = 'â–¶';
                setMobileCollapsedState('all-docs', 'all-docs', true);
            }
        }

        // ä»localStorageè·å–ç§»åŠ¨ç«¯å±•å¼€/æ”¶èµ·çŠ¶æ€
        function getMobileCollapsedState(type, key) {
            try {
                const storageKey = `mobileNav${type.charAt(0).toUpperCase() + type.slice(1)}${key.charAt(0).toUpperCase() + key.slice(1)}`;
                const state = localStorage.getItem(storageKey);
                return state === 'true';
            } catch (error) {
                console.warn('æ— æ³•ä»localStorageè·å–ç§»åŠ¨ç«¯å±•å¼€/æ”¶èµ·çŠ¶æ€:', error);
                return false;
            }
        }

        // ä¿å­˜ç§»åŠ¨ç«¯å±•å¼€/æ”¶èµ·çŠ¶æ€åˆ°localStorage
        function setMobileCollapsedState(type, key, isCollapsed) {
            try {
                const storageKey = `mobileNav${type.charAt(0).toUpperCase() + type.slice(1)}${key.charAt(0).toUpperCase() + key.slice(1)}`;
                localStorage.setItem(storageKey, isCollapsed.toString());
            } catch (error) {
                console.warn('æ— æ³•ä¿å­˜ç§»åŠ¨ç«¯å±•å¼€/æ”¶èµ·çŠ¶æ€åˆ°localStorage:', error);
            }
        }

        // åˆå§‹åŒ–ä¾§è¾¹æ æ»šåŠ¨åŠŸèƒ½
        function initializeSidebarScrolling() {
            const sidebar = document.querySelector('.sidebar');
            if (!sidebar) return;

            let isScrolling = false;
            let scrollTimeout;

            // æ»šåŠ¨äº‹ä»¶å¤„ç†
            sidebar.addEventListener('scroll', function () {
                if (!isScrolling) {
                    sidebar.classList.add('scrolling');
                    isScrolling = true;
                }

                // æ¸…é™¤ä¹‹å‰çš„è¶…æ—¶
                clearTimeout(scrollTimeout);

                // è®¾ç½®æ–°çš„è¶…æ—¶ï¼Œåœ¨åœæ­¢æ»šåŠ¨åç§»é™¤ç±»
                scrollTimeout = setTimeout(function () {
                    sidebar.classList.remove('scrolling');
                    isScrolling = false;
                }, 150);
            });

            // ä¸ºä¾§è¾¹æ å†…çš„é“¾æ¥æ·»åŠ å¹³æ»‘æ»šåŠ¨æ•ˆæœ
            const sidebarLinks = sidebar.querySelectorAll('a[href^="#"]');
            sidebarLinks.forEach(link => {
                link.addEventListener('click', function (e) {
                    e.preventDefault();
                    const targetId = this.getAttribute('href').substring(1);
                    const targetElement = document.getElementById(targetId);

                    if (targetElement) {
                        // è®¡ç®—æ»šåŠ¨ä½ç½®ï¼Œè€ƒè™‘å›ºå®šå¤´éƒ¨é«˜åº¦
                        const headerHeight = document.querySelector('.site-header').offsetHeight;
                        const targetPosition = targetElement.offsetTop - headerHeight - 20;

                        window.scrollTo({
                            top: targetPosition,
                            behavior: 'smooth'
                        });
                    }
                });
            });

            // æ·»åŠ é”®ç›˜å¯¼èˆªæ”¯æŒ
            sidebar.addEventListener('keydown', function (e) {
                // ä¸Šä¸‹ç®­å¤´é”®æ»šåŠ¨
                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    sidebar.scrollTop -= 30;
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    sidebar.scrollTop += 30;
                }
                // Homeé”®æ»šåŠ¨åˆ°é¡¶éƒ¨
                else if (e.key === 'Home') {
                    e.preventDefault();
                    sidebar.scrollTop = 0;
                }
                // Endé”®æ»šåŠ¨åˆ°åº•éƒ¨
                else if (e.key === 'End') {
                    e.preventDefault();
                    sidebar.scrollTop = sidebar.scrollHeight;
                }
            });

            // ç¡®ä¿ä¾§è¾¹æ å¯ä»¥è·å¾—ç„¦ç‚¹ä»¥æ”¯æŒé”®ç›˜å¯¼èˆª
            sidebar.setAttribute('tabindex', '0');

            // æ·»åŠ æ»šåŠ¨æŒ‡ç¤ºå™¨ï¼ˆå¯é€‰ï¼‰
            addScrollIndicator(sidebar);
        }

        // æ·»åŠ æ»šåŠ¨æŒ‡ç¤ºå™¨
        function addScrollIndicator(sidebar) {
            // æ£€æŸ¥æ˜¯å¦éœ€è¦æ»šåŠ¨æŒ‡ç¤ºå™¨
            function checkScrollNeeded() {
                const needsScroll = sidebar.scrollHeight > sidebar.clientHeight;

                // å¦‚æœéœ€è¦æ»šåŠ¨ä¸”æ²¡æœ‰æŒ‡ç¤ºå™¨ï¼Œåˆ™æ·»åŠ ä¸€ä¸ª
                if (needsScroll && !sidebar.querySelector('.scroll-indicator')) {
                    const indicator = document.createElement('div');
                    indicator.className = 'scroll-indicator';
                    indicator.innerHTML = 'â†“';
                    indicator.style.cssText = `
                        position: absolute;
                        bottom: 10px;
                        right: 10px;
	                        background: rgba(40, 167, 69, 0.7);
                        color: white;
                        width: 24px;
                        height: 24px;
                        border-radius: 50%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 12px;
                        opacity: 0.7;
                        pointer-events: none;
                        transition: opacity 0.3s ease;
                        z-index: 10;
                    `;

                    // å°†æŒ‡ç¤ºå™¨æ·»åŠ åˆ°ä¾§è¾¹æ å†…å®¹åŒºåŸŸ
                    const sidebarContent = sidebar.querySelector('.sidebar-content');
                    if (sidebarContent) {
                        sidebarContent.style.position = 'relative';
                        sidebarContent.appendChild(indicator);

                        // ç›‘å¬æ»šåŠ¨ï¼Œå½“ç”¨æˆ·å¼€å§‹æ»šåŠ¨æ—¶éšè—æŒ‡ç¤ºå™¨
                        let hideTimeout;
                        sidebar.addEventListener('scroll', function () {
                            indicator.style.opacity = '0';

                            // æ¸…é™¤ä¹‹å‰çš„è¶…æ—¶
                            clearTimeout(hideTimeout);

                            // å¦‚æœæ»šåŠ¨åˆ°é¡¶éƒ¨ï¼Œé‡æ–°æ˜¾ç¤ºæŒ‡ç¤ºå™¨
                            if (sidebar.scrollTop <= 10) {
                                hideTimeout = setTimeout(() => {
                                    indicator.style.opacity = '0.7';
                                }, 1000);
                            }
                        });
                    }
                }
                // å¦‚æœä¸éœ€è¦æ»šåŠ¨ä¸”æœ‰æŒ‡ç¤ºå™¨ï¼Œåˆ™ç§»é™¤å®ƒ
                else if (!needsScroll) {
                    const indicator = sidebar.querySelector('.scroll-indicator');
                    if (indicator) {
                        indicator.remove();
                    }
                }
            }

            // åˆå§‹æ£€æŸ¥
            checkScrollNeeded();

            // çª—å£å¤§å°å˜åŒ–æ—¶é‡æ–°æ£€æŸ¥
            window.addEventListener('resize', checkScrollNeeded);

            // å†…å®¹å˜åŒ–æ—¶é‡æ–°æ£€æŸ¥ï¼ˆä½¿ç”¨MutationObserverï¼‰
            const observer = new MutationObserver(checkScrollNeeded);
            observer.observe(sidebar, { childList: true, subtree: true });
        }
    </script>
</body>

</html>
