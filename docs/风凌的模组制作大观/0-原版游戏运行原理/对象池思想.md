---
title: 对象池思想介绍
author: 风凌
date: 2026-1-16
last_updated: 2026-1-16
difficulty: beginner
time: 5分钟
description: 介绍泰拉瑞亚以及模组制作中的对象池思想
prev_chapter: null
next_chapter: 物品原理.md
topic: mod-basics
order: 5
colors:
  Mad: "#f00"
---

# 内容
本节开始为大家介绍泰拉瑞亚中各种实体运行的基本前提：对象池思想

首先，什么是对象池思想？

AI给出的回答如下：
提前创建一定数量的对象并统一管理，需要时从中取用，用完后标记为空闲而不是销毁。通过复用对象，减少频繁创建和回收带来的性能开销，提高运行效率与稳定

这一句话基本已经说明了对象池的概念

那么在泰拉瑞亚这个游戏中，对象池表现出来的样子就是一堆数组
例如Main.npc;Main.projectile;Main.Item
原版在进行每帧逻辑计算的时候，也是按顺序依次遍历对象池中的对象来计算的
这些数组已经由原版进行管理和维护，你不需要再new Projectile()这样创建新的对象
你所需要的就是调用原版提供的NewXXX()方法来生成实体
例如Projectile.NewProjectile()，那么Main.projectile数组中就会出现你需要的弹幕，这个方法的返回值便是你生成的弹幕在数组中的位置

这里展示下这个方法到底是什么样的
``` csharp
	public static int NewProjectile(IEntitySource spawnSource, float X, float Y, float SpeedX, float SpeedY, int Type, int Damage, float KnockBack, int Owner = -1, float ai0 = 0f, float ai1 = 0f, float ai2 = 0f)
	{
		if (Owner == -1)
			Owner = Main.myPlayer;

		int num = 1000;
		for (int i = 0; i < 1000; i++) {
			if (!Main.projectile[i].active) {
				num = i;
				break;
			}
		}

		if (num == 1000)
			num = FindOldestProjectile();

		Projectile projectile = Main.projectile[num];
		projectile.SetDefaults(Type);
		projectile.position.X = X - (float)projectile.width * 0.5f;
		projectile.position.Y = Y - (float)projectile.height * 0.5f;
		projectile.owner = Owner;
		projectile.velocity.X = SpeedX;
		projectile.velocity.Y = SpeedY;
		projectile.damage = Damage;
		projectile.knockBack = KnockBack;
		projectile.identity = num;
		projectile.gfxOffY = 0f;
		projectile.stepSpeed = 1f;
		projectile.wet = Collision.WetCollision(projectile.position, projectile.width, projectile.height);
		if (projectile.ignoreWater)
			projectile.wet = false;

		projectile.honeyWet = Collision.honey;
		projectile.shimmerWet = Collision.shimmer;
		Main.projectileIdentity[Owner, num] = num;
		FindBannerToAssociateTo(spawnSource, projectile);

		// Added by TML.
		HandlePlayerStatModifiers(spawnSource, projectile);

		if (projectile.aiStyle == 1) {
			while (projectile.velocity.X >= 16f || projectile.velocity.X <= -16f || projectile.velocity.Y >= 16f || projectile.velocity.Y < -16f) {
				projectile.velocity.X *= 0.97f;
				projectile.velocity.Y *= 0.97f;
			}
		}

		if (Owner == Main.myPlayer) {
			switch (Type) {
				case 206:
					projectile.ai[0] = (float)Main.rand.Next(-100, 101) * 0.0005f;
					projectile.ai[1] = (float)Main.rand.Next(-100, 101) * 0.0005f;
					break;
				case 335:
					projectile.ai[1] = Main.rand.Next(4);
					break;
				case 358:
					projectile.ai[1] = (float)Main.rand.Next(10, 31) * 0.1f;
					break;
				case 406:
					projectile.ai[1] = (float)Main.rand.Next(10, 21) * 0.1f;
					break;
				default:
					projectile.ai[0] = ai0;
					projectile.ai[1] = ai1;
					projectile.ai[2] = ai2;
					break;
			}
		}

		if (Type == 434) {
			projectile.ai[0] = projectile.position.X;
			projectile.ai[1] = projectile.position.Y;
		}
		if (Type > 0) {
			if (ProjectileID.Sets.NeedsUUID[Type])
				projectile.projUUID = projectile.identity;

			if (ProjectileID.Sets.StardustDragon[Type]) {
				int num2 = Main.projectile[(int)projectile.ai[0]].projUUID;
				if (num2 >= 0)
					projectile.ai[0] = num2;
			}
		}
		if (Owner == Main.myPlayer) {
			if (ProjectileID.Sets.IsAGolfBall[Type] && Damage <= 0) {
				int num3 = 0;
				int num4 = 0;
				int num5 = 99999999;
				for (int j = 0; j < 1000; j++) {
					if (Main.projectile[j].active && ProjectileID.Sets.IsAGolfBall[Main.projectile[j].type] && Main.projectile[j].owner == Owner && Main.projectile[j].damage <= 0) {
						num3++;
						if (num5 > Main.projectile[j].timeLeft) {
							num4 = j;
							num5 = Main.projectile[j].timeLeft;
						}
					}
				}

				if (num3 > 10)
					Main.projectile[num4].Kill();
			}

			if (Type == 28)
				projectile.timeLeft = 180;

			if (Type == 516)
				projectile.timeLeft = 180;

			if (Type == 519)
				projectile.timeLeft = 180;

			if (Type == 29)
				projectile.timeLeft = 300;

			if (Type == 470)
				projectile.timeLeft = 300;

			if (Type == 637)
				projectile.timeLeft = 300;

			if (Type == 30)
				projectile.timeLeft = 180;

			if (Type == 517)
				projectile.timeLeft = 180;

			if (Type == 37)
				projectile.timeLeft = 180;

			if (Type == 773)
				projectile.timeLeft = 180;

			if (Type == 75)
				projectile.timeLeft = 180;

			if (Type == 133)
				projectile.timeLeft = 180;

			if (Type == 136)
				projectile.timeLeft = 180;

			if (Type == 139)
				projectile.timeLeft = 180;

			if (Type == 142)
				projectile.timeLeft = 180;

			if (Type == 397)
				projectile.timeLeft = 180;

			if (Type == 419)
				projectile.timeLeft = 600;

			if (Type == 420)
				projectile.timeLeft = 600;

			if (Type == 421)
				projectile.timeLeft = 600;

			if (Type == 422)
				projectile.timeLeft = 600;

			if (Type == 588)
				projectile.timeLeft = 180;

			if (Type == 779)
				projectile.timeLeft = 60;

			if (Type == 783)
				projectile.timeLeft = 60;

			if (Type == 862 || Type == 863)
				projectile.timeLeft = 60;

			if (Type == 443)
				projectile.timeLeft = 300;

			if (Type == 681)
				projectile.timeLeft = 600;

			if (Type == 684)
				projectile.timeLeft = 60;

			if (Type == 706)
				projectile.timeLeft = 120;

			if (Type == 680 && Main.player[projectile.owner].setSquireT2)
				projectile.penetrate = 7;

			if (Type == 777 || Type == 781 || Type == 794 || Type == 797 || Type == 800 || Type == 785 || Type == 788 || Type == 791 || Type == 903 || Type == 904 || Type == 905 || Type == 906 || Type == 910 || Type == 911)
				projectile.timeLeft = 180;

			// Copied from 1.3, moved from Shoot context to OnSpawn with matching logic
			if (Main.netMode != NetmodeID.Server) {
				Player throwingPlayer = Main.player[Owner];
				if (throwingPlayer.AnyThrownCostReduction && throwingPlayer.HeldItem.CountsAsClass(DamageClass.Throwing) && spawnSource is EntitySource_ItemUse_WithAmmo)
					projectile.noDropItem = true;
			}
		}

		if (Type == 249)
			projectile.frame = Main.rand.Next(5);

		if (Owner == Main.myPlayer)
			Main.player[Owner].TryUpdateChannel(projectile);

		ProjectileLoader.OnSpawn(projectile, spawnSource);

		if (Main.netMode != 0 && Owner == Main.myPlayer)
			NetMessage.SendData(27, -1, -1, null, num);

		return num;
	}
```
全文没有出现new Projectile,这意味着生成一个新的弹幕的实质就是修改数组中某个废弃弹幕成为这个新弹幕，
全程没有涉及到创建和删除。
这便是泰拉瑞亚的对象池思想。

那为什么可以这么干呢？
很简单，C#中的类是引用类型数据
``` csharp
Projectile projectile1 = Main.projectile[index1];//这是访问对象池里已有的对象
```
这个时候你去操作projectile1的属性字段，实际上就是在操作Main.projectile[index1]的属性字段
请注意，如果你之后这么写
``` csharp
projectile1 = Main.projectile[index2];
```
并不会让 Main.projectile[index1]这个弹幕 也变为 Main.projectile[index2]这个弹幕
仅仅是让projectile1这个玩意代表的弹幕从Main.projectile[index1]变为了Main.projectile[index2]

所以假如你需要找到你之前生成的一个弹幕，你就应该在生成的时候
``` csharp
int index = Projectile.NewProjectile(参数自己填);
//用一个持久存在的字段去保存这个Index 如果你是在弹幕中生成的新弹幕，你可以用Projectile.ai[0]、Projectile.ai[1]
Projectile.ai[0] = index;//保存生成的弹幕的索引
//注意，这里的Projectile是你ModProjectile的弹幕实例，而不是我们说的Projectile类（不懂没关系，之后会具体说明）
//然后你就能在之后的时间里通过Main.projectile[(int)Projectile.ai[0]]来获取这个弹幕
```
