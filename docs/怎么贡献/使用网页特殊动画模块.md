---
title: 使用网页特殊动画模块
author: DPapyru
category: 怎么贡献
topic: article-contribution
last_updated: 2026-01-22
description: 用 TypeScript 编写可视化动画，并在 docs/viewer.html 中嵌入（含：AI 状态机分析、数学渲染、可复用 UI 组件）
difficulty: beginner
time: 10分钟
---

本文介绍站点的 `animts` 网页动画模块：用 TypeScript 编写可视化动画（弹幕、NPC 对话、Boss/NPC 的 AI 分析动画、数学可视化等），并在文章中以“特殊语法”嵌入到 `docs/viewer.html`。

## 你会得到什么

- **文章内嵌动画**：Markdown 中用一个 `animts` 代码块引用 `anims/*.ts`。
- **两种脚本写法**：
  - `run(ctx)`（自由模式：你自己创建 canvas/DOM，适合复杂演示）
  - `updateAI + render`（AI-only 模式：专注 AI 更新与绘制，UI/交互由运行时提供）
- **可复用的共享库（可 import + 补全）**：`@animts/math2d`、`@animts/calc`、`@animts/ui`…（viewer 与 `file://` 本地渲染器均可用）
- **开发渲染器**：双击打开 `docs/anim-renderer.html`，无需静态服务器就能预览/编译 TS。

## 目录

- 基本概念与目录结构
- 在 Markdown 中嵌入动画（`animts` 语法）
- 脚本模式：`run(ctx)` vs `updateAI/render`
- 共享库：数学渲染与 UI 组件
- 开发预览：`docs/anim-renderer.html`（file:// 直开）
- 常见问题与排错（VSCode、构建、路径）

## 基本概念与目录结构

动画相关的核心目录：

- 源码：`docs/anims/**/*.ts`
- 共享库：`docs/anims/_lib/*.ts`（可被动画 `import`）
- 构建产物：`assets/anims/**/*.js`（由构建脚本生成）
- 清单：`assets/anims/manifest.json`（由构建脚本生成）
- 运行时：`assets/js/animts-runtime.js` + `assets/css/animts-runtime.css`

注意：

- 站点部署时只发布 JS，因此 **文章里写的是 TS 路径（`anims/*.ts`）**，运行时会自动映射到对应的 `assets/anims/*.js`。
- 禁止在文章里写 URL 或跳出目录的路径（运行时会拒绝）。

## 快速开始（最短路径）

1. 在 `docs/anims/` 下创建一个 `*.ts` 动画脚本（示例已提供：`docs/anims/demo-eoc-ai.ts`）。
2. 运行构建：`npm run build`（会编译到 `assets/anims/*.js`，并更新 `assets/anims/manifest.json`）。
3. 在 Markdown 里用 `animts` 代码块引入（第一行写 `anims/*.ts` 路径）。

## `animts` 语法

在文章中插入下面这段：

```animts
anims/demo-eoc-ai.ts
```

渲染后会出现一个动画面板，并自动播放。

### 更多可直接嵌入的示例

AI-only（只写 `updateAI` + `render`，运行时提供 UI/交互）：

```animts
anims/demo-eow-ai.ts
```

数学可视化（函数/切线/积分 + 可调参数面板）：

```animts
anims/demo-math-calculus.ts
```

更多数学/线性代数可视化（示例）：

3D 坐标系（等距投影 + 旋转方块）：

```animts
anims/demo-math-axes-3d.ts
```

向量（点积/夹角/投影）：

```animts
anims/demo-math-vectors.ts
```

矩阵（2×2 线性变换：基向量 + 单位正方形变平行四边形）：

```animts
anims/demo-math-matrix.ts
```

## 脚本模式一：自由模式（`run(ctx)`）

动画脚本需要导出一个函数（默认导出或命名导出 `run` 均可）：

```ts
export default async function run(ctx) {
  // ctx.stage: 动画容器（HTMLElement）
  // ctx.signal: AbortSignal（切换文章/重播时会 abort）
  // ctx.onDispose(fn): 注册清理逻辑
}
```

`ctx` 提供一些便捷能力（当前版本最小集合）：

- `ctx.stage`: 动画舞台容器（你可以 append canvas / DOM）
- `ctx.wait(ms)`: 等待指定毫秒
- `ctx.danmaku.send(text, options)`: 发送弹幕（简单轨道）
- `ctx.npc.say({ name, text, durationMs })`: 生成 NPC 气泡对话
- `ctx.runtime.isPaused()`: 是否处于“暂停”（由运行时按钮控制）
- `ctx.onDispose(fn)`: 注册清理回调（移除事件、取消 `requestAnimationFrame` 等）

适用场景：

- 你要创建多层 DOM/HUD、复杂交互、或自定义布局；
- 你要做“演示片段串联”（例如先讲概念，再播放一段动画，再切换到另一段）。

## 脚本模式二：AI-only（`updateAI + render`）

如果你只想专注两件事：

1) **AI 更新**（状态机、计时、碰撞/寻路简化、目标选择…）  
2) **绘制**（把当前状态画出来）

那么你可以只导出这两个函数：

```ts
export function updateAI(state, input, dt) {
  // state: 你的持久状态（运行时会帮你保留）
  // input.player.pos: 玩家位置（可拖拽）
  // input.lockedState: 运行时 UI 的“锁定状态”（点击状态列表）
}

export function render(state, input, gfx) {
  // gfx.g: CanvasRenderingContext2D
  // gfx.width/height: 画布尺寸（CSS 像素）
}
```

运行时会为你提供：

- Canvas + HUD（badge、状态列表、时间轴）
- 交互：拖拽玩家；点击状态锁定；暂停冻结

### 让“状态列表 / 徽章 / 时间轴”工作起来（推荐字段约定）

在 AI-only 模式下，运行时会读取你 `state` 里的约定字段来驱动 UI（你也可以完全不提供这些字段，只画图）：

- `state.mode: string`：当前模式名（用于高亮状态）
- `state.uiStates: Array<{ key: string; label?: string; note?: string }>`：状态列表（用于渲染可点击的状态机面板）
- `state.badges(scene)`：可选函数，用于一次性更新 badge/footer（更适合把 UI 更新逻辑集中在 AI 侧）

一个最小骨架（可直接复制改名）：

```ts
import type { AnimAIInput, AnimGfx2D } from '@animts/types';

export function updateAI(state: any, input: AnimAIInput, dt: number) {
  state.time = (state.time || 0) + dt;
  state.uiStates ||= [
    { key: 'Idle', label: 'Idle', note: '等待' },
    { key: 'Chase', label: 'Chase', note: '追击' }
  ];
  state.mode ||= 'Idle';

  // 支持运行时锁定：点击状态列表会把 input.lockedState 传进来
  if (input.lockedState) state.mode = input.lockedState;

  // 可选：集中更新 UI（badge/时间轴等）
  state.badges = (scene: any) => {
    scene.badges.set(`t=${(state.time || 0).toFixed(2)}`, `mode=${state.mode}`, '');
    scene.footer.setRight('拖拽玩家/点击状态锁定');
    scene.footer.setProgress01(((state.time || 0) % 5) / 5);
  };
}

export function render(state: any, input: any, gfx: AnimGfx2D) {
  const g = gfx.g;
  g.clearRect(0, 0, gfx.width, gfx.height);
  // 这里画你的 AI 可视化（角色/轨迹/箭头/碰撞框…）
}
```

示例脚本：

- 克苏鲁之眼（自由模式）：`docs/anims/demo-eoc-ai.ts`
- 世界吞噬者（AI-only）：`docs/anims/demo-eow-ai.ts`
- 数学可视化（自由模式）：`docs/anims/demo-math-calculus.ts`

## 共享库（可 import + 补全）

动画脚本支持用 `import` 复用站点内置的 Math/UI 库（编辑器会有补全，viewer 与 `docs/anim-renderer.html` 均可运行）：

- `@animts/math2d`：二维直角坐标系、函数曲线、积分面积等基础绘制
- `@animts/math3d`：简单三维坐标轴投影绘制（等距投影）
- `@animts/calc`：有限差分、切线、黎曼和等小工具
- `@animts/ui`：可复用 UI 组件（例如可固定/折叠的面板）
- `@animts/types`：仅类型（`import type`）+ 版本常量

### 示例：在动画里画二维坐标系 + 函数曲线 + 积分面积

```ts
import type { AnimContext } from '@animts/types';
import { createCartesian2D, drawAxes2D, plotFunction2D, fillIntegralArea2D } from '@animts/math2d';
import { createPanel } from '@animts/ui';

export default async function run(ctx: AnimContext) {
  const panel = createPanel(ctx.stage, { title: '参数', pinned: true });
  let a = -1;
  let b = 1;
  panel.addSlider('a', { min: -3, max: 3, step: 0.01, initial: a }, (v) => (a = v));
  panel.addSlider('b', { min: -3, max: 3, step: 0.01, initial: b }, (v) => (b = v));

  const { canvas, g } = ctx.ui.canvas2d({ className: 'animts-ai-canvas' });
  ctx.ui.runLoop({
    update: () => {},
    draw: () => {
      g.clearRect(0, 0, canvas.width, canvas.height);
      const origin = { x: canvas.width / 2, y: canvas.height / 2 };
      const cs = createCartesian2D({ origin, unitPx: 60, yUp: true });
      drawAxes2D(g, cs, { xMin: -6, xMax: 6, yMin: -3, yMax: 3 });
      const f = (x: number) => Math.sin(x);
      fillIntegralArea2D(g, cs, f, a, b);
      plotFunction2D(g, cs, f);
    }
  });
}
```

### 示例：创建可固定/折叠的 UI 面板

`@animts/ui` 的 `createPanel(stage, { title })` 会在舞台左上角创建一个面板：

- “固定”：锁定面板当前位置（不再响应拖拽）；再次点击解除锁定后可继续拖动
- “折叠”：隐藏面板内容，只保留标题栏
- `addButton/addToggle/addSlider`：快速拼出控制区（适合调参数/切模式）

这类 UI 的目标是：动画作者只关注 AI 和绘制逻辑，不用每篇文章都重复造控件。

## 示例：克苏鲁之眼 AI 分析动画（自由模式）

站点自带示例脚本：`docs/anims/demo-eoc-ai.ts`，它实现了一个“简化版状态机可视化 + 交互讲解”：

- 用 Canvas 画出 player、Boss（眼球）、小眼球（servants）、速度向量与瞄准线
- 用 HUD 面板展示当前 AI 状态（Hover/ChargePrep/Charge/Recovery/Phase2…）
- 通过“暂停/继续”冻结 AI 更新，用于讲解每个状态的意义
- 交互：
  - 拖拽画布：移动玩家位置（Boss 会重新锁定/调整冲刺方向）
  - 点击状态机条目：锁定/解除锁定该状态（用于逐状态讲解）
  - 双击画布：重置玩家位置

### 行为参考（原版概念摘要）

下面是对原版行为的“概念级”摘要（不同难度/版本细节会有差异；本文动画是为了教学做的简化可视化，不追求 1:1 复刻）：

- **两阶段**：眼球有 2 个阶段，并能穿墙飞行。
- **阶段 1**：通常会在玩家附近盘旋并生成少量仆从（Servants），随后对玩家进行多次连续冲刺，然后重复循环。
- **阶段 2**（生命值低于阈值后）：变成“张嘴形态”，冲刺更凶，部分难度下会出现更密集/连锁的冲刺，并且仆从机制与数值表现也会变化。

来源（英文）：`https://terraria.fandom.com/wiki/Eye_of_Cthulhu`

## 开发预览：动画渲染器（file:// 直开，无需静态服务器）

如果你在写文章时不方便打开 `docs/viewer.html`，可以直接双击打开 `docs/anim-renderer.html`（`file://` 直开），然后：

1. 点击“播放内置示例：克苏鲁之眼 AI 分析”；或
2. 用“选择 TS 文件”选中你本地的 `*.ts` 动画脚本，然后点“编译并播放”；或
3. 用“选择仓库目录”选择项目根目录（或 `docs/` 目录），从下拉框选择 `anims/*.ts`，再点“播放所选/复制 animts 代码块”。

注意：该渲染器会优先从仓库的 `node_modules/typescript` 加载 TypeScript 编译器；若不存在请先执行 `npm install`。

## 常见问题与排错

### 1) VSCode 报 `ts(2307)`：找不到模块 `@animts/*`

如果你看到类似报错：

> 找不到模块“@animts/types”或其相应的类型声明。 ts(2307)

原因通常是：TS Server 没有识别到本目录下的 `tsconfig.json`。

解决方式（仓库已内置）：

- `docs/anims/tsconfig.json` 为 VSCode/tsserver 提供 `paths` 映射，让 `@animts/*` 在编辑期可解析。

如果你仍然看到报错：

- 确认打开的是仓库根目录（不是单独打开某个文件）
- 在 VSCode 命令面板执行：`TypeScript: Restart TS server`

### 2) 动画在 viewer 能跑，但文章里不显示

按顺序检查：

1. 文章中的 `animts` 路径是否以 `anims/` 开头，且以 `.ts` 结尾
2. 是否运行过 `npm run build`（部署/提交前必须编译 TS）
3. 浏览器控制台是否有加载错误（路径、缓存、拼写问题）

### 3) 如何写“最少 UI”的脚本？

优先用 `updateAI + render`（AI-only 模式）。运行时会给你基础 HUD/交互，你只管：

- `updateAI`：维护 `state.mode`、`state.uiStates`（状态列表）、`state.badges`（可选）
- `render`：根据 state 画出实体、轨迹、箭头、热区等
