---
title: 调试实战 - 问题排查流程
description: 通过具体案例学习调试技巧和问题排查流程
author: Papyru
category: Modder入门
topic: mod-dev
last_updated: 2026-01-30
prev_chapter: 调试基础
next_chapter: 第一个NPC
---

## 版本说明

> WARNING: 版本说明：本教程适用于 **tModLoader 1.4.4+**

> 本文中的调试流程和 API 调用基于 1.4.4 版本。

兼容性说明：
- 1.4.4+: 调试工具和 API 与本文一致
- 1.4.3 及更旧: 某些调试功能可能不可用

## 本章目标

调试基础教会了我们工具的使用，本章将通过**具体案例**来练习调试技能。

本章目标：
- 掌握物品不工作的系统化排查流程
- 学会 NPC 行为异常的调试方法
- 了解配方问题的定位与解决
- 处理多人游戏中的同步问题

预计用时：60-90 分钟（包括实践）

## 案例一：物品不工作的排查流程

### 问题描述

你创建了一个武器物品，但在游戏中：
1. 找不到这个物品
2. 或物品无法正常使用
3. 或物品效果与预期不符

### 排查流程

建议先按这个顺序走一遍：
1. 确认 Mod 已启用且无报错
2. 确认物品是否注册/能被找到
3. 检查 SetDefaults 关键属性
4. 检查 AddRecipes 与工作台/材料
5. 查看 Logs.txt（最后一步）

#### 步骤1：确认物品是否被正确注册

**检查点**：物品是否出现在游戏中

**操作**：
1. 启动游戏，打开 Mod Browser
2. 找到你的 Mod，确认它已启用
3. 进游戏后，打开背包或配方列表
4. 搜索物品名称

**如果找不到物品**：
- 检查 `ModItem` 类是否被正确命名
- 检查是否在 Mod 类中添加了物品引用
- 查看日志中是否有注册失败的错误

**示例代码检查**：
```csharp
// 确保你的 Mod 类中添加了物品
public override void Load() {
    Mod.AddContent(new MyItem()); // 注册物品
}
```

#### 步骤2：检查物品的 SetDefaults 配置

**检查点**：属性是否正确设置

**操作**：
1. 打开物品类
2. 检查 `SetDefaults` 方法
3. 验证关键属性是否被正确赋值

**常见问题**：
- `Item.damage = 0` 或未设置
- `Item.DamageType = DamageClass.None`
- `Item.width` 或 `Item.height` 为 0
- `Item.useTime` 或 `Item.useAnimation` 设置不当

**日志输出方法**：
```csharp
public override void SetDefaults() {
    Item.damage = 10;
    Item.DamageType = DamageClass.Melee;
    
    // 添加日志输出
    Mod.Logger.Info($"物品 {Name} 的伤害设置为: {Item.damage}");
    Mod.Logger.Debug($"物品类型: {Item.DamageType}");
}
```

#### 步骤3：验证配方是否正确

**检查点**：配方是否能正常合成

**操作**：
1. 打开合成界面
2. 准备配方所需材料
3. 站在正确的工作台旁
4. 查看配方列表

**常见问题**：
- `AddRecipe` 方法没有 `.Register()`
- 工作台类型不正确
- 材料数量或 ID 错误
- 配方顺序问题

**日志输出方法**：
```csharp
public override void AddRecipes() {
    CreateRecipe()
        .AddIngredient(ItemID.DirtBlock, 10)
        .AddTile(TileID.WorkBenches)
        .Register();
    
    // 添加日志确认配方已注册
    Mod.Logger.Info($"{Name} 的配方已注册");
}
```

#### 步骤4：检查物品的使用方法

**检查点**：物品是否能正常使用

**操作**：
1. 装备物品
2. 按使用键（左键）
3. 观察是否有挥动动画和音效

**常见问题**：
- `Item.useStyle` 设置错误
- `Item.UseSound` 未设置
- `Item.autoReuse` 设置不当

**日志输出方法**：
```csharp
public override void OnHitNPC(...) {
    Mod.Logger.Info($"{Name} 击中了 NPC");
    Mod.Logger.Debug($"造成伤害: {damage}");
}
```

#### 步骤5：查看日志文件

**最后手段**：如果以上步骤都没有发现问题，查看完整日志

**操作**：
1. 关闭游戏
2. 打开日志文件（参考《调试基础》）
3. 搜索你的 Mod 名称或物品名称
4. 查找 ERROR 或 WARN 级别的日志

### 常见原因总结

| 问题 | 常见原因 | 解决方法 |
|------|---------|---------|
| 物品不存在 | 没有注册 | 在 Mod.Load 中添加物品 |
| 伤害为 0 | Item.damage 未设置 | 在 SetDefaults 中设置 |
| 无法挥动 | useStyle 未设置 | 添加 Item.useStyle |
| 没有配方 | AddRecipes 没有 Register | 添加 .Register() |
| 配方不显示 | 工作台类型错误 | 检查 AddTile 参数 |

## 案例二：NPC 行为异常的排查流程

### 问题描述

你创建了一个 NPC，但在游戏中：
1. NPC 没有按预期移动
2. NPC 没有攻击玩家
3. NPC 会出现异常的闪烁或消失

### 排查流程

#### 步骤1：确认 NPC 是否被正确生成

**检查点**：NPC 是否能出现在游戏中

**操作**：
1. 使用 Hero's Mod 或调试命令生成 NPC
2. 观察怪物图鉴中是否显示 NPC
3. 进游戏后，检查世界中的 NPC

**如果 NPC 没有出现**：
- 检查 `ModNPC` 类是否被注册
- 检查 NPC 的生成条件（SpawnConditions）
- 查看日志中是否有错误

**示例代码检查**：
```csharp
// 检查 SpawnConditions 设置
public override void SetStaticDefaults() {
    DisplayName.SetDefault("我的怪物");
}

public override void SetDefaults() {
    NPC.width = 32;
    NPC.height = 32;
    NPC.damage = 10;
    NPC.lifeMax = 100;
    
    // 添加日志
    Mod.Logger.Info($"NPC {Name} 属性已设置");
}
```

#### 步骤2：检查 AI 方法

**检查点**：NPC 的 AI 是否正常执行

**操作**：
1. 打开 `AI` 方法
2. 添加日志输出，确认 AI 是否被调用
3. 观察日志中的输出频率

**常见问题**：
- AI 方法没有正确继承或重写
- NPC.ai 数组使用错误
- 循环或条件判断导致 AI 卡死

**日志输出方法**：
```csharp
private int aiTimer = 0;

public override void AI() {
    aiTimer++;
    
    // 每 60 帧（1秒）输出一次日志
    if (aiTimer % 60 == 0) {
Mod.Logger.Info($"NPC {Name} AI 正在运行，位置: {NPC.position}");
    }
    
    // 简单的移动 AI
    NPC.TargetClosest(true);
    if (NPC.HasValidTarget) {
Vector2 direction = Main.player[NPC.target].Center - NPC.Center;
direction.Normalize();
NPC.velocity = direction * 2f;
    }
}
```

#### 步骤3：验证 NPC 的攻击行为

**检查点**：NPC 是否能攻击玩家

**操作**：
1. 确认 NPC 的伤害值已设置
2. 检查 NPC 的碰撞箱（width/height）
3. 测试 NPC 是否能接触玩家

**常见问题**：
- `NPC.damage` 未设置或为 0
- NPC 的碰撞箱太小或太大
- NPC 的攻击方式（AI）未实现

**日志输出方法**：
```csharp
public override void OnHitPlayer(Player target, int damage, bool crit) {
    Mod.Logger.Info($"{Name} 击中了玩家，造成 {damage} 伤害");
}
```

#### 步骤4：检查 NPC 的生成规则

**检查点**：NPC 是否在正确的地点生成

**操作**：
1. 检查 `SpawnConditions` 配置
2. 测试在不同生物群系中生成
3. 验证生成条件和时间

**常见问题**：
- `SpawnConditions` 设置过于严格
- 限制了生成位置或时间
- 没有添加到任何怪物图鉴

**示例代码**：
```csharp
public override void SetStaticDefaults() {
    DisplayName.SetDefault("我的怪物");
    Main.npcFrameCount[NPC.type] = Main.npcFrameCount[NPCID.Zombie];
}

public override float SpawnChance(NPCSpawnInfo spawnInfo) {
    // 在地表生成
    return spawnInfo.spawnTileY < Main.worldSurface ? 0.1f : 0f;
}
```

### 常见原因总结

| 问题 | 常见原因 | 解决方法 |
|------|---------|---------|
| NPC 不出现 | SpawnConditions 限制 | 调整生成条件 |
| NPC 不移动 | AI 方法未实现 | 编写 AI 逻辑 |
| NPC 不攻击 | damage 未设置 | 设置 NPC.damage |
| NPC 瞬间消失 | lifeMax 过小或未设置 | 设置合理的生命值 |
| AI 不工作 | AI 方法未调用 | 检查方法签名 |

## 案例三：配方不工作的排查流程

### 问题描述

你添加了一个配方，但在游戏中：
1. 找不到配方
2. 配方无法合成
3. 配方显示但无法使用

### 排查流程

建议先按这个顺序走一遍：
1. 确认 AddRecipes 是否执行并注册成功
2. 检查链式调用是否完整（Create -> AddIngredient -> AddTile -> Register）
3. 检查材料 ID 与数量
4. 检查工作台 ID 与实际位置
5. 如果有 AddCondition，确认环境条件满足

#### 步骤1：确认配方是否被注册

**检查点**：配方是否出现在配方列表中

**操作**：
1. 启动游戏
2. 站在正确的工作台旁
3. 打开合成界面
4. 搜索配方名称

**如果配方不显示**：
- 检查 `AddRecipes` 方法是否被重写
- 检查链式调用是否完整（Create -> AddIngredient -> AddTile -> Register）
- 查看日志中是否有错误

**示例代码检查**：
```csharp
public override void AddRecipes() {
    CreateRecipe()                // 1. 创建配方
        .AddIngredient(ItemID.DirtBlock, 10)  // 2. 添加材料
        .AddTile(TileID.WorkBenches)  // 3. 设置工作台
        .Register();               // 4. 注册配方（关键！）
    
    // 确认配方已注册
    Mod.Logger.Info($"{Name} 配方已注册");
}
```

#### 步骤2：检查配方材料

**检查点**：材料是否正确

**操作**：
1. 准备配方所需的所有材料
2. 确认材料的数量正确
3. 检查材料的 ID 是否存在

**常见问题**：
- 材料 ID 不存在（拼写错误）
- 材料数量设置过大
- 使用了自定义物品但未正确引用

**日志输出方法**：
```csharp
public override void AddRecipes() {
    int dirtCount = 10;
    CreateRecipe()
        .AddIngredient(ItemID.DirtBlock, dirtCount)
        .AddTile(TileID.WorkBenches)
        .Register();
    
    Mod.Logger.Info($"配方需要 {dirtCount} 个土块");
}
```

#### 步骤3：检查工作台要求

**检查点**：工作台是否正确

**操作**：
1. 站在指定的工作台旁
2. 确认工作台类型正确
3. 测试在不同工作台附近是否能合成

**常见问题**：
- 工作台 ID 错误（如 WorkBenches 错拼为 WorkBench）
- 工作台限制过于严格
- 需要特殊工作台但未说明

**常见工作台 ID**：
```csharp
TileID.WorkBenches      // 工作台
TileID.Anvils           // 铁砧
TileID.Furnaces         // 熔炉
TileID.AlchemyTable     // 炼药台
TileID.TinkerersWorkbench     // 工匠作坊
```

#### 步骤4：验证配方的条件限制

**检查点**：配方是否有额外条件

**操作**：
1. 检查是否使用了 `AddCondition` 或 `AddDecraftCondition`
2. 验证条件是否满足
3. 查看日志中的条件验证信息

**示例代码**：
```csharp
public override void AddRecipes() {
    CreateRecipe()
        .AddIngredient(ItemID.DirtBlock, 10)
        .AddTile(TileID.WorkBenches)
        .AddCondition(Condition.InGraveyard)  // 需要墓地环境
        .Register();
    
    Mod.Logger.Info($"{Name} 配方需要墓地环境");
}
```

### 常见原因总结

| 问题 | 常见原因 | 解决方法 |
|------|---------|---------|
| 配方不显示 | 没有调用 Register() | 添加 .Register() |
| 材料不正确 | ItemID 拼写错误 | 检查材料 ID |
| 无法合成 | 工作台类型错误 | 修正 AddTile 参数 |
| 条件不满足 | 需要特殊环境 | 移除或调整条件 |
| 合成数量错误 | createRecipe 数量参数设置错误 | 检查 CreateRecipe 的参数 |

## 案例四：多人游戏同步问题的排查流程

### 问题描述

在多人游戏中：
1. 物品/NPC 在服务器正常，但在客户端显示异常
2. 客户端能看到，但服务器无法同步状态
3. 不同客户端显示的内容不一致

### 排查流程

#### 步骤1：理解 tModLoader 的网络同步机制

**核心概念**：
- 服务器负责计算逻辑和权威数据
- 客户端负责显示和交互
- 需要通过 `ModPacket` 同步数据

**关键点**：
- 服务器和客户端的代码执行顺序可能不同
- 网络延迟会导致不同步
- 需要区分 `if (Main.netMode == NetmodeID.Server)` 和 `if (Main.netMode == NetmodeID.MultiplayerClient)`

#### 步骤2：检查是否需要手动同步

**判断方法**：
- 如果修改了 NPC 或 Projectile 的自定义数据 -> **需要同步**
- 如果修改了 ModPlayer 的自定义数据 -> **需要同步**
- 如果只是在客户端显示临时效果 -> **可能不需要同步**

**示例：需要同步的情况**：
```csharp
// 自定义 NPC 数据
public class MyNPC : ModNPC {
    public override void SendExtraAI(BinaryWriter writer) {
writer.Write(NPC.ai[0]);
writer.Write(NPC.ai[1]);
    }
    
    public override void ReceiveExtraAI(BinaryReader reader) {
NPC.ai[0] = reader.ReadSingle();
NPC.ai[1] = reader.ReadSingle();
    }
}
```

#### 步骤3：实现 ModPacket 同步

**步骤**：
1. 定义一个 ModPacket ID
2. 在服务器发送数据
3. 在客户端接收数据

**示例代码**：
```csharp
// 在 Mod 类中定义 Packet 类型
public class MyMod : Mod {
    public override void Load() {
// 注册数据包类型
    }
}

// 发送数据（服务器）
public void SendMyData(int playerWho, int value) {
    if (Main.netMode == NetmodeID.Server) {
ModPacket packet = Mod.GetPacket();
packet.Write((byte)MyMessageType.MyData);
packet.Write(playerWho);
packet.Write(value);
packet.Send();
    }
}

// 接收数据（客户端）
public override void HandlePacket(BinaryReader reader, int whoAmI) {
    byte messageType = reader.ReadByte();
    
    switch (messageType) {
case (byte)MyMessageType.MyData:
    int playerWho = reader.ReadInt32();
    int value = reader.ReadInt32();
    // 处理接收到的数据
    break;
    }
}
```

#### 步骤4：使用日志验证同步

**方法**：
1. 在服务器端发送时输出日志
2. 在客户端接收时输出日志
3. 对比日志的时间和内容

**示例**：
```csharp
// 服务器端
public void SendMyData(int playerWho, int value) {
    if (Main.netMode == NetmodeID.Server) {
Mod.Logger.Info($"服务器发送数据给玩家 {playerWho}: {value}");

ModPacket packet = Mod.GetPacket();
packet.Write((byte)MyMessageType.MyData);
packet.Write(playerWho);
packet.Write(value);
packet.Send();
    }
}

// 客户端端
public override void HandlePacket(BinaryReader reader, int whoAmI) {
    byte messageType = reader.ReadByte();
    
    switch (messageType) {
case (byte)MyMessageType.MyData:
    int playerWho = reader.ReadInt32();
    int value = reader.ReadInt32();
    Mod.Logger.Info($"客户端接收数据: 玩家 {playerWho}, 值 {value}");
    break;
    }
}
```

### 常见原因总结

| 问题 | 常见原因 | 解决方法 |
|------|---------|---------|
| 客户端不同步 | 没有发送 ModPacket | 实现 SendExtraAI/ReceiveExtraAI |
| 数据混乱 | 服务器和客户端都修改同一数据 | 只在服务器修改 |
| 延迟导致卡顿 | 频繁发送数据包 | 减少同步频率 |
| 显示不一致 | 客户端代码在服务器执行 | 检查 if (Main.netMode == ...) |

## 综合验证清单

### 调试技能验证清单

**物品问题排查**
- 能使用日志确认物品是否被注册
- 能检查 SetDefaults 的属性设置
- 能验证配方的工作台和材料
- 能输出物品使用时的日志

**NPC 问题排查**
- 能确认 NPC 是否被正确生成
- 能在 AI 方法中添加日志输出
- 能验证 NPC 的攻击行为
- 能检查 NPC 的 SpawnConditions

**配方问题排查**
- 能确认配方是否被注册
- 能检查材料的 ID 和数量
- 能验证工作台类型
- 能理解和实现配方的条件限制

**多人游戏同步排查**
- 理解服务器和客户端的区别
- 能实现 ModPacket 的发送和接收
- 能使用日志验证网络同步
- 能处理网络延迟导致的显示不一致

### 调试最佳实践

1. **日志优先**：遇到问题时，首先添加日志输出
2. **逐步验证**：不要一次性修改太多代码，逐步验证每个步骤
3. **对比原版**：参考原版代码的实现方式
4. **版本一致性**：确保代码与 tModLoader 版本兼容
5. **文档参考**：查阅官方文档和示例代码

### 下一步

完成本章学习后，你已经掌握了系统的调试方法。

接下来，你将学习如何创建更复杂的 Mod 内容：
- 《第一个NPC》 - 创建基础怪物
- 《第一个弹幕》 - 创建攻击效果
- 《NPC弹幕联动》 - 让怪物发射弹幕
- 《世界生成基础》 - 修改世界生成规则

这些内容将帮助你从简单的物品开发，逐步进阶到完整的 Mod 创作。

<!-- generated from: Modder入门/详细文档/Mod开发实践/调试实战.cs -->
