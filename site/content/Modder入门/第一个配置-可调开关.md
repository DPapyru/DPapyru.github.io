---
title: 配置：给你的 Mod 加一个可调开关
author: loguhan
topic: article-contribution
description: 这篇实操教程将带你从零完成第一个 ModConfig，配置输入框、开关、滑条和 Vector2 参数
order: 100
difficulty: beginner
time: 60
---
# 第一个配置：给你的 Mod 加一个可调开关

这篇是实操向教程，目标是做出一个最小可用的 `ModConfig`，并在代码里读取它

## 前言

> 这是一个偏实操的小教程，目标是让你照着就能跑通
本文主要补充“配置实战”这块

## 本节你会做出来什么

- 输入框配置：`DamageNote`（玩家可输入任意文本）
- 布尔配置：`EnableDamageBoost`（开关控制）
- 滑动配置：`DamageBoostPercent`（范围 + 步长）
- 二维向量配置：`DamageCritVector`（`X` 和 `Y` 两路参数）
- 在武器代码里按类型读取并生效

## 学习节奏

- 第一步：先把配置类一次写完整
- 第二步：按内容分类读取 4 种配置
- 第三步：进游戏验证每种类型的效果

> 新手建议：先照抄完整代码跑通，再回头逐个改参数，这样最不容易卡住

## 0. 建议

建议目录结构

```text
YourMod/
  Common/
    Configs/
      FirstConfig.cs
  Content/
    Items/
      ExampleSword.cs
```

## 1. 新建配置类

文件：`Common/Configs/FirstConfig.cs`

```csharp
using Microsoft.Xna.Framework;
using System.ComponentModel;
using Terraria.ModLoader;
using Terraria.ModLoader.Config;

namespace YourMod.Common.Configs;

public class FirstConfig : ModConfig
{
    public override ConfigScope Mode => ConfigScope.ClientSide; // 仅影响本地；多人统一规则请改 ServerSide

    [Header("DamageDemo")] // 分组键，显示文本建议放到本地化文件
    [DefaultValue("这是我的第一把配置武器")] // 输入框默认文本
    public string DamageNote = "这是我的第一把配置武器"; // 输入框配置：给 Tooltip 用的文本

    [DefaultValue(true)] // 默认开启伤害加成
    public bool EnableDamageBoost; // 布尔配置：总开关

    [DefaultValue(20)] // 默认加成为 20%
    [Range(0, 300)] // 允许范围 0~300
    [Increment(5)] // 每次调整步长为 5
    public int DamageBoostPercent; // 滑动配置：基础伤害加成百分比

    public Vector2 DamageCritVector = new(10f, 5f); // 二维向量配置：X 额外伤害百分比，Y 额外暴击率
}
```

### 这一步按步骤做

1. 在 `Common/Configs` 下新建 `FirstConfig.cs` 文件
2. 让 `FirstConfig` 继承 `ModConfig`
3. 设置 `Mode` 为 `ConfigScope.ClientSide`
4. 按内容添加 4 个字段：`DamageNote`、`EnableDamageBoost`、`DamageBoostPercent`、`DamageCritVector`
5. 给 `string`、`bool`、`int` 字段写默认值
6. 给 `int` 字段补 `Range + Increment`

> 新手常见顺序是先写字段再补特性，如果编译报错，多半是 `using` 或特性拼写漏了

### 这一步 API 一点点讲（配置层）

#### `ModConfig`

- 作用：把类注册为可被 tModLoader 识别和保存的配置类
- 默认值：无（这是基类，不是配置值）
- 常见坑：不继承 `ModConfig` 会导致配置项不出现在 `Mod Configuration`
- 本节怎么用：`public class FirstConfig : ModConfig`

#### `ConfigScope.ClientSide`

- 作用：定义配置作用域，决定是本地偏好还是联机统一规则
- 默认值：本例显式设置为 `ConfigScope.ClientSide`
- 常见坑：影响联机规则的配置仍写成 `ClientSide`，会导致多人不一致
- 本节怎么用：`public override ConfigScope Mode => ConfigScope.ClientSide`

> 只要配置会改变联机规则（伤害、掉率、Boss 数值），就改用 `ServerSide`

#### 输入框配置（`string`）

- 作用：让玩家在配置界面输入一段文本
- 默认值：`"这是我的第一把配置武器"`
- 常见坑：不判空就显示到 Tooltip，容易出现空行
- 本节怎么用：读取 `cfg.DamageNote` 后配合 `string.IsNullOrWhiteSpace` 判空

#### 布尔配置（`bool`）

- 作用：提供开关型配置，控制某段逻辑是否执行
- 默认值：`true`
- 常见坑：没写守卫判断，导致关闭后逻辑仍执行
- 本节怎么用：`if (!cfg.EnableDamageBoost) return`

#### 滑动配置（`int + [Range] + [Increment]`）

- 作用：提供可调数值，并约束上下限和步长
- 默认值：`20`
- 常见坑：把百分比直接当倍率，或写成整除公式导致结果不对
- 本节怎么用：`damage *= 1f + cfg.DamageBoostPercent / 100f`

#### 二维向量配置（`Vector2`）

- 作用：把两个关联参数打包成一个配置字段
- 默认值：`new(10f, 5f)`（`X=10`，`Y=5`）
- 常见坑：不约定 `X/Y` 语义，后续维护容易混乱
- 本节怎么用：`X` 参与伤害倍率，`Y` 参与暴击率

#### `[Header]`

- 作用：给配置界面添加分组标题
- 默认值：无
- 常见坑：把它当成逻辑控制项，它只影响展示
- 本节怎么用：`[Header("DamageDemo")]` 放在该组字段最前面

#### `[DefaultValue]`

- 作用：指定首次生成配置文件时的初始值
- 默认值：由特性参数决定（如 `true`、`20`、字符串文本）
- 常见坑：误以为每次加载都会强制重置成默认值
- 本节怎么用：给 `DamageNote`、`EnableDamageBoost`、`DamageBoostPercent` 设置初值

> 你改了默认值后，老玩家已有配置通常不会自动跟着变，除非重置配置

#### 本地化键（推荐）

- 作用：控制配置项显示名称与提示文字的本地化来源
- 默认值：使用自动本地化键
- 常见坑：继续使用已过时的 `[Label]` 和 `[Tooltip]`
- 本节怎么用：默认走自动键，需自定义时用 `[LabelKey("...")]`、`[TooltipKey("...")]`
- 本节键示例：`Mods.YourMod.Configs.FirstConfig.EnableDamageBoost.Label`
- 本节键示例：`Mods.YourMod.Configs.FirstConfig.EnableDamageBoost.Tooltip`
- 本节键示例：`Mods.YourMod.Configs.FirstConfig.DamageBoostPercent.Label`
- 本节键示例：`Mods.YourMod.Configs.FirstConfig.DamageBoostPercent.Tooltip`
- 本节键示例：`Mods.YourMod.Configs.FirstConfig.Headers.DamageDemo`

> 结论先记住：新项目不要再写 `[Label]` 和 `[Tooltip]`

## 2. 在武器里读取配置

示例文件：`Content/Items/ExampleSword.cs`

```csharp
using System.Collections.Generic;
using Terraria;
using Terraria.ModLoader;
using YourMod.Common.Configs;

namespace YourMod.Content.Items;

public class ExampleSword : ModItem
{
    public override void ModifyTooltips(List<TooltipLine> tooltips) // 输入框配置：把文本显示到武器提示
    {
        FirstConfig cfg = ModContent.GetInstance<FirstConfig>(); // 读取配置实例
        if (string.IsNullOrWhiteSpace(cfg.DamageNote)) return; // 输入框为空就不显示
        tooltips.Add(new TooltipLine(Mod, "DamageNote", cfg.DamageNote)); // 把输入框文本加进 Tooltip
    }

    public override void ModifyWeaponDamage(Player player, ref StatModifier damage) // 布尔 + 滑动 + Vector2.X：控制最终伤害倍率
    {
        FirstConfig cfg = ModContent.GetInstance<FirstConfig>(); // 读取配置实例
        if (!cfg.EnableDamageBoost) return; // 布尔开关关闭直接结束
        damage *= 1f + (cfg.DamageBoostPercent + cfg.DamageCritVector.X) / 100f; // 滑动值与 X 相加后转倍率
    }

    public override void ModifyWeaponCrit(Player player, ref float crit) // Vector2.Y：控制额外暴击率
    {
        FirstConfig cfg = ModContent.GetInstance<FirstConfig>(); // 读取配置实例
        if (!cfg.EnableDamageBoost) return; // 布尔开关关闭直接结束
        crit += cfg.DamageCritVector.Y; // 给暴击率叠加 Y 分量
    }
}
```

### 这一步按步骤做

1. 先重写 `ModifyTooltips` 读取输入框配置
2. 再重写 `ModifyWeaponDamage` 读取布尔 + 滑动 + `Vector2.X`
3. 最后重写 `ModifyWeaponCrit` 读取 `Vector2.Y`

> 这三个方法职责分开：`Tooltip` 管文本，`Damage` 管伤害，`Crit` 管暴击

### 2.1 输入框配置（`string`）

#### 对应读取代码

```csharp
if (string.IsNullOrWhiteSpace(cfg.DamageNote)) return; // 输入框为空就不显示
tooltips.Add(new TooltipLine(Mod, "DamageNote", cfg.DamageNote)); // 把文本加进 Tooltip
```

#### `ModifyTooltips(List<TooltipLine> tooltips)`

- 作用：修改物品提示文本
- 默认值：不重写时不会添加这条自定义提示
- 常见坑：不做空文本判断，Tooltip 会出现无意义空行
- 本节怎么用：在这里读取 `cfg.DamageNote` 并追加 `TooltipLine`

#### `string.IsNullOrWhiteSpace`

- 作用：判断字符串是否为空或仅空白字符
- 默认值：无
- 常见坑：只判断 `== ""`，漏掉全空格文本
- 本节怎么用：`if (string.IsNullOrWhiteSpace(cfg.DamageNote)) return`

#### `TooltipLine`

- 作用：向物品说明添加一条自定义文本
- 默认值：无
- 常见坑：把内部 key 和显示文本写反
- 本节怎么用：`new TooltipLine(Mod, "DamageNote", cfg.DamageNote)`

### 2.2 布尔配置（`bool`）

#### 对应读取代码

```csharp
if (!cfg.EnableDamageBoost) return; // 开关关闭直接结束
```

#### `if (!cfg.EnableDamageBoost) return`

- 作用：布尔守卫，关闭开关时直接退出逻辑
- 默认值：`EnableDamageBoost` 默认是 `true`
- 常见坑：守卫写反，或遗漏 `return` 让关闭状态仍继续执行
- 本节怎么用：放在 `ModifyWeaponDamage` 和 `ModifyWeaponCrit` 的前面

### 2.3 滑动配置（`int + Range + Increment`）

#### 对应读取代码

```csharp
damage *= 1f + cfg.DamageBoostPercent / 100f; // 20 -> 1.20
```

> 记忆点：`20` 是 `+20%`，不是乘 `20` 倍

#### `damage *= 1f + cfg.DamageBoostPercent / 100f`

- 作用：把滑动配置里的百分比转成伤害倍率并应用到最终伤害
- 默认值：`DamageBoostPercent` 默认是 `20`，即默认倍率 `1.20`
- 常见坑：写成 `damage *= cfg.DamageBoostPercent` 或用整除导致倍率错误
- 本节怎么用：在 `ModifyWeaponDamage` 中读取后直接乘到 `damage`

### 2.4 二维向量配置（`Vector2`）

#### 对应读取代码

```csharp
damage *= 1f + (cfg.DamageBoostPercent + cfg.DamageCritVector.X) / 100f; // X 参与伤害倍率
crit += cfg.DamageCritVector.Y; // Y 参与暴击率
```

#### `cfg.DamageCritVector.X` 与 `cfg.DamageCritVector.Y`

- 作用：从二维向量配置中分别读取两路参数
- 默认值：`X=10`、`Y=5`
- 常见坑：`X` 和 `Y` 语义搞反，导致效果和说明不一致
- 本节怎么用：`X` 加到伤害百分比通道，`Y` 叠加到暴击率通道

### 快速验证（3 步）

1. `Build + Reload`
2. 进入 `Mods -> Mod Configuration` 调整 `DamageNote`、`EnableDamageBoost`、`DamageBoostPercent`、`DamageCritVector`
3. 进世界测试这把武器，观察 Tooltip、伤害和暴击是否随配置变化

> 改了代码但游戏里没变化时，先确认你做了 `Build + Reload`

### 关键补充

> 重点补充先记这 4 条
> - 配置文件位置：`%userprofile%\Documents\My Games\Terraria\tModLoader\ModConfigs`
> - 文件名通常形如：`<ModName>_<ConfigName>.json`
> - JSON 常只保存“和默认值不同”的项，所以看到 `{}` 也是正常现象
> - 本文用 `ClientSide` 仅作入门演示；若配置会影响伤害/掉率等玩法平衡，联机应使用 `ServerSide`

## 2.5 四种类型速记

> 速记卡
> - 输入框配置：`string DamageNote` -> 读取 `cfg.DamageNote` -> 常用于提示文本或命名
> - 布尔配置：`bool EnableDamageBoost` -> 读取 `if (cfg.EnableDamageBoost)` -> 控制开关
> - 滑动配置：`int DamageBoostPercent + [Range] + [Increment]` -> 读取数值后转倍率
> - 二维向量配置：`Vector2 DamageCritVector` -> `X` 和 `Y` 拆开用于两路效果

## 3. 选择题自测

```quiz
type: single
id: quiz-single-config-01
question: |
  下面哪种配置更适合用 ClientSide
options:
  - id: A
    text: 掉率倍率
  - id: B
    text: Boss 血量倍率
  - id: C
    text: 伤害数字显示样式
  - id: D
    text: PVP 伤害规则
answer: C
explain: |
  ClientSide 更适合个人显示或本地体验，不应影响多人玩法公平
```

```quiz
type: single
id: quiz-single-config-02
question: |
  你希望“多人联机下所有人规则一致”，应该使用
options:
  - id: A
    text: ConfigScope.ClientSide
  - id: B
    text: ConfigScope.ServerSide
  - id: C
    text: DefaultValue
  - id: D
    text: Increment
answer: B
explain: |
  玩法规则统一应交给 ServerSide，由服务器决定并同步逻辑
```

```quiz
type: single
id: quiz-single-config-03
question: |
  以下哪个写法用于读取配置实例最直接
options:
  - id: A
    text: new FirstConfig()
  - id: B
    text: ModContent.GetInstance<FirstConfig>()
  - id: C
    text: ConfigManager.Load<FirstConfig>()
  - id: D
    text: Item.GetGlobalItem<FirstConfig>()
answer: B
explain: |
  tModLoader 常规做法是使用 ModContent.GetInstance<TConfig>() 访问配置实例
```

```quiz
type: single
id: quiz-single-config-04
question: |
  DamageBoostPercent = 20 时，下面哪条计算是正确的
options:
  - id: A
    text: damage *= 20f
  - id: B
    text: damage *= 1f + 20 / 100f
  - id: C
    text: damage += 20f / 100f
  - id: D
    text: damage = 20f
answer: B
explain: |
  百分比加成通常转成倍率：1 + 百分比/100，再乘到原始伤害上
```

```quiz
type: single
id: quiz-single-config-05
question: |
  如果配置界面看不到你的配置项，第一步最该检查
options:
  - id: A
    text: 武器贴图尺寸
  - id: B
    text: 是否继承 ModConfig 且类是 public
  - id: C
    text: 游戏分辨率
  - id: D
    text: 是否开了自动存档
answer: B
explain: |
  首先排查配置类定义是否符合框架要求，这是最常见原因
```

## 4. 问答速查（Q&A）

Q1：我改了配置，但伤害没变化
> A1：先确认逻辑里每次计算都读取了 `ModContent.GetInstance<FirstConfig>()`，再确认你在测的是同一把武器逻辑路径

Q2：什么时候必须用 `ServerSide`
> A2：在联机场景下，只要配置会影响玩法公平或战斗数值（掉率、伤害、Boss 属性），就应使用 `ServerSide`

Q3：`Range` 和 `Increment` 分别做什么
> A3：`Range` 限制上下限；`Increment` 控制滑动步长，方便玩家微调

Q4：我想让改动后立刻执行额外逻辑
> A4：把同步更新代码写到 `OnChanged()` 里，比如刷新缓存、重算状态

Q5：配置字段命名可以中文吗
> A5：字段名建议英文；显示给玩家的中文建议写在本地化文件自动键里，若要自定义键可用 `LabelKey/TooltipKey`

## 5. 常见问题

1. 配置项看不到

- 检查类是否 `public class Xxx : ModConfig`
- 检查文件是否被工程编译到（命名空间和文件位置无硬性要求，但建议清晰）

2. 改了配置没生效

- 你是否真的在逻辑里读取了 `ModContent.GetInstance<FirstConfig>()`
- 某些逻辑可能需要重进世界或重新触发计算

3. 单人正常，多人表现不一致

- 玩法平衡相关配置应使用 `ConfigScope.ServerSide`
