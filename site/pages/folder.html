<!DOCTYPE html>
<!-- 目录可视化页面（SVG） -->
<html lang="zh-CN" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>文件夹内容 - 泰拉瑞亚Mod制作教程</title>

    <meta name="description" content="泰拉瑞亚Mod制作教程文档目录可视化页面，支持按目录下钻和章节关系查看。">
    <meta name="keywords" content="泰拉瑞亚,Mod,教程,文档,文件夹,tModLoader">
    <meta name="author" content="泰拉瑞亚Mod社区">
    <meta name="robots" content="index, follow">

    <meta property="og:title" content="文件夹内容 - 泰拉瑞亚Mod制作教程">
    <meta property="og:description" content="泰拉瑞亚Mod制作教程文档目录可视化页面，支持按目录下钻和章节关系查看。">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://dpapyru.github.io/site/pages/folder.html">
    <meta property="og:image" content="https://dpapyru.github.io/site/assets/imgs/Green_tModLoader.png">
    <meta property="og:site_name" content="泰拉瑞亚Mod制作教程">
    <meta property="og:locale" content="zh_CN">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="文件夹内容 - 泰拉瑞亚Mod制作教程">
    <meta name="twitter:description" content="泰拉瑞亚Mod制作教程文档目录可视化页面，支持按目录下钻和章节关系查看。">
    <meta name="twitter:image" content="https://dpapyru.github.io/site/assets/imgs/Green_tModLoader.png">

    <link rel="canonical" href="https://dpapyru.github.io/site/pages/folder.html">

    <link rel="stylesheet" href="/site/assets/css/style.css">
    <link rel="stylesheet" href="/site/assets/css/workbench-phase.css">
    <link rel="stylesheet" href="/site/assets/css/prism.min.css">
    <link rel="stylesheet" href="/site/assets/css/vs2022-theme.css">
    <link rel="icon" type="image/png" href="/site/assets/imgs/Green_tModLoader.png">

    <script src="/site/assets/js/theme-init.js"></script>

    <style>
        .folder-map-page {
            padding: 5px 0 8px;
            min-height: calc(100vh - 86px);
        }

        .folder-map-panel {
            border: 1px solid var(--border-color);
            background: var(--bg-content);
            border-radius: 10px;
            box-shadow: var(--shadow-md);
            overflow: hidden;
            margin: 0 5px;
        }

        .folder-map-toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            flex-wrap: wrap;
            padding: 8px 10px;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-secondary);
        }

        .folder-map-title {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .folder-map-meta {
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--text-secondary);
            font-size: 0.8rem;
            flex-wrap: wrap;
        }

        .folder-map-stage {
            position: relative;
            width: 100%;
            overflow: auto;
            background: var(--bg-color);
            min-height: 420px;
            height: clamp(420px, calc(100vh - 210px), 820px);
        }

        .folder-map-svg {
            display: block;
            width: 100%;
            min-width: 700px;
            height: auto;
        }

        .folder-map-empty {
            padding: 12px 10px;
            text-align: center;
            color: var(--text-secondary);
            border-top: 1px solid var(--border-color);
        }

        .folder-map-legend {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            font-size: 0.78rem;
            color: var(--text-secondary);
            padding: 8px 10px 10px;
        }

        .legend-chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .legend-line {
            display: inline-block;
            width: 24px;
            height: 0;
            border-top-width: 2px;
            border-top-style: solid;
        }

        #legend-prev-line {
            border-top-style: solid;
        }

        #legend-next-line {
            border-top-style: solid;
        }

        .map-clickable {
            cursor: pointer;
            outline: none;
        }

        .map-clickable rect {
            transition: transform 0.18s ease, stroke-width 0.18s ease;
            transform-box: fill-box;
            transform-origin: center;
        }

        .map-clickable:hover rect,
        .map-clickable:focus rect {
            transform: scale(1.03);
            stroke-width: 2.5;
        }

        @media (max-width: 768px) {
            .folder-map-page {
                padding: 4px 0 6px;
            }

            .folder-map-panel {
                margin: 0 4px;
            }

            .folder-map-stage {
                min-height: 360px;
                height: clamp(360px, calc(100vh - 190px), 700px);
            }

            .folder-map-svg {
                min-width: 620px;
            }

            .folder-map-toolbar {
                align-items: flex-start;
            }
        }
    </style>
</head>

<body class="workbench-page">
    <a class="skip-link" href="#main-content">跳到主要内容</a>

    <header class="site-header">
        <div class="container">
            <div class="header-content">
                <div class="logo">
                    <a href="/site/index.html">
                        <img src="/site/assets/imgs/Green_tModLoader.png" alt="泰拉瑞亚Mod制作教程" class="logo-image">
                        <h1 class="site-title">泰拉瑞亚Mod制作教程</h1>
                    </a>
                </div>
                <form class="header-search" role="search" action="/site/search-results.html" method="get">
                    <label class="visually-hidden" for="header-search-q">搜索教程</label>
                    <input class="header-search-input" id="header-search-q" type="search" name="q" placeholder="搜索教程..." aria-label="搜索教程">
                    <button class="header-search-button" type="submit" aria-label="执行搜索">
                        <i class="icon-search" aria-hidden="true"></i>
                    </button>
                </form>
                <nav class="main-nav" id="main-nav">
                    <ul class="nav-list">
                        <li class="nav-item"><a href="/site/index.html" class="nav-link">首页</a></li>
                        <li class="nav-item"><a href="/site/pages/folder.html" class="nav-link">文档</a></li>
                        <li class="nav-item"><a href="/tml-ide/" class="nav-link">在线 IDE（Markdown/C#/HLSL）</a></li>
                        <li class="nav-item"><a href="/site/qa.html" class="nav-link">问答</a></li>
                        <li class="nav-item"><a href="https://github.com/DPapyru/DPapyru.github.io" class="nav-link" target="_blank" rel="noopener noreferrer">GitHub</a></li>
                        <li class="nav-item nav-accent">
                            <label class="visually-hidden" for="accent-select">配色</label>
                            <select class="nav-accent-select" id="accent-select" aria-label="配色">
                                <option value="green">绿色</option>
                                <option value="blue">蓝色</option>
                                <option value="purple">紫色</option>
                                <option value="orange">橙色</option>
                                <option value="red">红色</option>
                                <option value="cyan">青色</option>
                                <option value="black">黑色</option>
                                <option value="white">白色</option>
                                <option value="vs">VS</option>
                                <option value="git">Git</option>
                                <option value="terraria-crimson">猩红</option>
                                <option value="terraria-corruption">腐化</option>
                                <option value="terraria-hallow">神圣</option>
                                <option value="terraria-tundra">冰原</option>
                                <option value="terraria-desert">沙漠</option>
                            </select>
                        </li>
                    </ul>
                </nav>
                <button class="mobile-menu-toggle" type="button" aria-label="切换菜单" aria-controls="main-nav" aria-expanded="false">
                    <span class="bar"></span>
                    <span class="bar"></span>
                    <span class="bar"></span>
                </button>
            </div>
        </div>
    </header>

    <main class="workbench-main" id="main-content" tabindex="-1">
        <section class="folder-map-page">
            <div class="folder-map-panel">
                <div class="folder-map-toolbar">
                    <button class="btn btn-outline" id="go-parent-btn" type="button">返回上一级</button>
                    <div class="folder-map-title" id="folder-map-title">目录可视化</div>
                    <div class="folder-map-meta">
                        <span id="folder-count-meta">目录 0</span>
                        <span id="doc-count-meta">文章 0</span>
                    </div>
                </div>

                <div class="folder-map-stage">
                    <svg class="folder-map-svg" id="folder-map-svg" viewBox="0 0 1200 860" role="img" aria-label="文档目录结构"></svg>
                </div>

                <div class="folder-map-legend">
                    <span class="legend-chip"><span class="legend-line" id="legend-prev-line"></span>左侧箭头（橙色）</span>
                    <span class="legend-chip"><span class="legend-line" id="legend-next-line"></span>右侧箭头（蓝色）</span>
                    <span>点击目录节点进入目录，点击文章节点打开文章</span>
                </div>

                <div class="folder-map-empty" id="folder-map-empty" hidden>当前目录暂无子目录与文章。</div>
            </div>
        </section>
    </main>
    <div class="workbench-statusbar" role="status" aria-label="页面状态栏"><span class="workbench-statusbar-item">SWISS WORKBENCH</span><span class="workbench-statusbar-sep" aria-hidden="true">|</span><span class="workbench-statusbar-item">LAYOUT: IDE</span><span class="workbench-statusbar-spacer"></span><span class="workbench-statusbar-item">THEME: ACCENT</span></div>

    <script src="/shared/assets/js/site-core.js"></script>
    <script>
        if (window.SITE) window.SITE.bootstrapPage('folder');
    </script>
    <script src="/site/assets/js/site-config.js"></script>
    <script src="/site/assets/js/accent-theme.js"></script>
    <script src="/site/assets/js/main.js"></script>
    <script src="/site/assets/js/navigation.js"></script>

    <script>
        (function () {
            // 文章列表不做分流
            var ROOT_LABEL = '绿群教程';
            var SAFE_SCALE = 0.2;
            var SVG_NS = 'http://www.w3.org/2000/svg';

            var state = {
                allDocs: [],
                docByPath: new Map(),
                tree: null,
                currentPath: ''
            };

            function escapeHtml(text) {
                return String(text == null ? '' : text)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;');
            }

            function normalizePath(value) {
                return String(value || '')
                    .replace(/\\/g, '/')
                    .replace(/^\/+|\/+$/g, '');
            }

            function splitFolderPath(path) {
                var normalized = normalizePath(path);
                return normalized ? normalized.split('/').filter(Boolean) : [];
            }

            function getFolderPathFromURL() {
                var params = new URLSearchParams(window.location.search);
                return normalizePath(params.get('path') || '');
            }

            function setMetaContent(selector, content) {
                var el = document.querySelector(selector);
                if (el && content) el.setAttribute('content', content);
            }

            function setCanonical(href) {
                var link = document.querySelector('link[rel="canonical"]');
                if (!link) {
                    link = document.createElement('link');
                    link.setAttribute('rel', 'canonical');
                    document.head.appendChild(link);
                }
                link.setAttribute('href', href);
            }

            function updateSeo(folderPath) {
                var baseUrl = 'https://dpapyru.github.io/site/pages/folder.html';
                var displayPath = folderPath || ROOT_LABEL;
                var canonical = folderPath ? (baseUrl + '?path=' + encodeURIComponent(folderPath)) : baseUrl;
                var title = displayPath + ' - 目录可视化 - 泰拉瑞亚Mod制作教程';
                var description = '泰拉瑞亚Mod制作教程目录视图：浏览“' + displayPath + '”的子目录与文章关系。';

                document.title = title;
                setCanonical(canonical);
                setMetaContent('meta[name="description"]', description);
                setMetaContent('meta[property="og:title"]', title);
                setMetaContent('meta[property="og:description"]', description);
                setMetaContent('meta[property="og:url"]', canonical);
                setMetaContent('meta[name="twitter:title"]', title);
                setMetaContent('meta[name="twitter:description"]', description);
            }

            function createFolderNode(name, path, parent) {
                return {
                    name: name,
                    path: path,
                    parent: parent,
                    children: new Map(),
                    docs: []
                };
            }

            function normalizeDoc(raw) {
                var path = normalizePath(raw && raw.path ? raw.path : raw && raw.filename ? raw.filename : '');
                if (!path || !/\.md$/i.test(path)) return null;

                return {
                    filename: raw.filename || path.split('/').pop() || '',
                    path: path,
                    title: raw.title || path.split('/').pop().replace(/\.md$/i, ''),
                    author: raw.author || '未知',
                    category: raw.category || '未分类',
                    order: Number(raw.order || 999) || 999,
                    prev_chapter: raw.prev_chapter || '',
                    next_chapter: raw.next_chapter || ''
                };
            }

            function compareFolder(a, b) {
                return String(a.name || '').localeCompare(String(b.name || ''), 'zh-CN');
            }

            function compareDoc(a, b) {
                var orderDelta = (a.order || 999) - (b.order || 999);
                if (orderDelta !== 0) return orderDelta;
                return String(a.title || '').localeCompare(String(b.title || ''), 'zh-CN');
            }

            function buildDocFlowOrder(docs) {
                var sorted = docs.slice().sort(compareDoc);
                var pathSet = new Set(sorted.map(function (doc) { return doc.path; }));
                var byPath = new Map(sorted.map(function (doc) { return [doc.path, doc]; }));
                var nextMap = new Map();
                var indegree = new Map();
                var ordered = [];
                var visited = new Set();

                sorted.forEach(function (doc) {
                    indegree.set(doc.path, 0);
                });

                sorted.forEach(function (doc) {
                    var nextPath = resolveChapterPath(doc.path, doc.next_chapter);
                    if (!nextPath || !pathSet.has(nextPath) || nextPath === doc.path) return;
                    if (nextMap.has(doc.path)) return;
                    nextMap.set(doc.path, nextPath);
                    indegree.set(nextPath, (indegree.get(nextPath) || 0) + 1);
                });

                function walk(startDoc) {
                    var current = startDoc;
                    while (current && !visited.has(current.path)) {
                        visited.add(current.path);
                        ordered.push(current);
                        var nextPath = nextMap.get(current.path);
                        current = nextPath ? byPath.get(nextPath) : null;
                    }
                }

                sorted.filter(function (doc) {
                    return (indegree.get(doc.path) || 0) === 0;
                }).forEach(walk);

                sorted.forEach(walk);
                return ordered;
            }

            function buildTree(docs) {
                var root = createFolderNode(ROOT_LABEL, '', null);

                docs.forEach(function (doc) {
                    var parts = splitFolderPath(doc.path);
                    var fileName = parts.pop();
                    if (!fileName) return;

                    var current = root;
                    var currentPath = '';

                    parts.forEach(function (part) {
                        currentPath = currentPath ? currentPath + '/' + part : part;
                        if (!current.children.has(part)) {
                            current.children.set(part, createFolderNode(part, currentPath, current));
                        }
                        current = current.children.get(part);
                    });

                    current.docs.push(doc);
                });

                return root;
            }

            function getFolderNode(path) {
                var normalized = normalizePath(path);
                if (!normalized) return state.tree;

                var parts = splitFolderPath(normalized);
                var current = state.tree;
                var i;
                for (i = 0; i < parts.length; i += 1) {
                    if (!current || !current.children.has(parts[i])) return null;
                    current = current.children.get(parts[i]);
                }
                return current;
            }

            function getParentPath(path) {
                var parts = splitFolderPath(path);
                parts.pop();
                return parts.join('/');
            }

            function resolveChapterPath(sourcePath, chapterRef) {
                var ref = normalizePath(chapterRef || '');
                if (!ref) return '';

                if (state.docByPath.has(ref)) return ref;

                var sourceParts = splitFolderPath(sourcePath);
                sourceParts.pop();

                ref.split('/').forEach(function (part) {
                    if (!part || part === '.') return;
                    if (part === '..') {
                        if (sourceParts.length > 0) sourceParts.pop();
                    } else {
                        sourceParts.push(part);
                    }
                });

                var resolved = sourceParts.join('/');
                if (state.docByPath.has(resolved)) return resolved;
                return '';
            }

            function getCssVar(name, fallback) {
                var value = getComputedStyle(document.documentElement).getPropertyValue(name);
                value = String(value || '').trim();
                return value || fallback;
            }

            function getPalette() {
                return {
                    bg: getCssVar('--bg-color', '#121212'),
                    surface: getCssVar('--bg-secondary', '#1c1f26'),
                    text: getCssVar('--text-color', '#f0f0f0'),
                    muted: getCssVar('--text-secondary', '#9aa4b2'),
                    border: getCssVar('--border-color', '#2f3b4f'),
                    primary: getCssVar('--primary-color', '#3fb950'),
                    folder: getCssVar('--link-color', '#4dabf7'),
                    doc: getCssVar('--text-color', '#f0f0f0'),
                    prev: '#4dabf7',
                    next: '#ff922b',
                    line: getCssVar('--border-color', '#3a4557')
                };
            }

            function createSvgEl(tag, attrs) {
                var el = document.createElementNS(SVG_NS, tag);
                Object.keys(attrs || {}).forEach(function (key) {
                    el.setAttribute(key, attrs[key]);
                });
                return el;
            }

            function polylinePath(points) {
                return points.map(function (point, index) {
                    return (index === 0 ? 'M ' : 'L ') + point.x + ' ' + point.y;
                }).join(' ');
            }

            function getAlternatingOffset(index, step) {
                if (index === 0) return 0;
                var level = Math.ceil(index / 2);
                return index % 2 === 1 ? (-level * step) : (level * step);
            }

            function clamp(value, min, max) {
                return Math.max(min, Math.min(max, value));
            }

            function truncateText(text, maxLen) {
                var value = String(text || '');
                if (value.length <= maxLen) return value;
                return value.slice(0, Math.max(1, maxLen - 1)) + '…';
            }

            function wrapTextLines(text, maxCharsPerLine, maxLines) {
                var value = String(text || '').replace(/\s+/g, ' ').trim();
                var chars = Array.from(value);
                var lineLimit = Math.max(1, maxLines || 1);
                var lineChars = Math.max(1, maxCharsPerLine || 10);
                var lines = [];
                var i;

                if (!chars.length) return [''];

                for (i = 0; i < lineLimit && chars.length > 0; i += 1) {
                    lines.push(chars.splice(0, lineChars).join(''));
                }

                if (chars.length > 0) {
                    lines[lineLimit - 1] = truncateText(lines[lineLimit - 1] + chars.join(''), lineChars);
                }
                return lines;
            }

            function addInteractiveNode(group, onClick) {
                group.classList.add('map-clickable');
                group.setAttribute('tabindex', '0');
                group.setAttribute('role', 'button');
                group.addEventListener('click', onClick);
                group.addEventListener('keydown', function (event) {
                    if (event.key === 'Enter' || event.key === ' ') {
                        event.preventDefault();
                        onClick();
                    }
                });
            }

            function drawNode(layer, options) {
                var x = options.cx - options.width / 2;
                var y = options.cy - options.height / 2;
                var titleLines = Array.isArray(options.titleLines) && options.titleLines.length > 0
                    ? options.titleLines
                    : [truncateText(options.title || '', options.titleMax || 14)];
                var titleSize = options.titleSize || 16;
                var titleLineHeight = options.titleLineHeight || Math.round(titleSize * 1.24);
                var hasSubtitle = !!options.subtitle;
                var titleStartY = options.cy - ((titleLines.length - 1) * titleLineHeight) / 2 - (hasSubtitle ? 9 : 0);

                var group = createSvgEl('g', {
                    'aria-label': options.label || ''
                });
                layer.appendChild(group);

                var rect = createSvgEl('rect', {
                    x: String(x),
                    y: String(y),
                    width: String(options.width),
                    height: String(options.height),
                    rx: String(options.radius || 10),
                    ry: String(options.radius || 10),
                    fill: options.fill,
                    stroke: options.stroke,
                    'stroke-width': String(options.strokeWidth || 2)
                });
                group.appendChild(rect);

                titleLines.forEach(function (lineText, lineIndex) {
                    var title = createSvgEl('text', {
                        x: String(options.cx),
                        y: String(titleStartY + lineIndex * titleLineHeight),
                        'text-anchor': 'middle',
                        'font-size': String(titleSize),
                        'font-weight': String(options.titleWeight || 700),
                        fill: options.textColor
                    });
                    title.textContent = lineText;
                    group.appendChild(title);
                });

                if (hasSubtitle) {
                    var subtitle = createSvgEl('text', {
                        x: String(options.cx),
                        y: String(titleStartY + titleLines.length * titleLineHeight + 9),
                        'text-anchor': 'middle',
                        'font-size': String(options.subtitleSize || 12),
                        fill: options.subTextColor || options.textColor,
                        opacity: '0.92'
                    });
                    subtitle.textContent = truncateText(options.subtitle, options.subtitleMax || 20);
                    group.appendChild(subtitle);
                }

                if (options.tooltip) {
                    var tip = createSvgEl('title', {});
                    tip.textContent = options.tooltip;
                    group.appendChild(tip);
                }

                if (typeof options.onClick === 'function') {
                    addInteractiveNode(group, options.onClick);
                }

                return group;
            }

            function updateLegendColors(palette) {
                var prevLine = document.getElementById('legend-prev-line');
                var nextLine = document.getElementById('legend-next-line');
                if (prevLine) prevLine.style.borderTopColor = palette.next;
                if (nextLine) nextLine.style.borderTopColor = palette.prev;
            }

            function updateToolbar(folderNode) {
                var title = document.getElementById('folder-map-title');
                var folderCount = document.getElementById('folder-count-meta');
                var docCount = document.getElementById('doc-count-meta');
                var goParentBtn = document.getElementById('go-parent-btn');

                var folderPath = state.currentPath;
                var displayName = folderPath || ROOT_LABEL;
                var children = Array.from(folderNode.children.values()).sort(compareFolder);
                var docs = folderNode.docs.slice().sort(compareDoc);

                if (title) {
                    title.textContent = '当前目录：' + displayName;
                }
                if (folderCount) {
                    folderCount.textContent = '目录 ' + children.length;
                }
                if (docCount) {
                    docCount.textContent = '文章 ' + docs.length;
                }

                if (goParentBtn) {
                    var parentPath = getParentPath(folderPath);
                    var isRoot = !folderPath;
                    goParentBtn.disabled = isRoot;
                    goParentBtn.setAttribute('aria-disabled', isRoot ? 'true' : 'false');
                    goParentBtn.onclick = function () {
                        if (isRoot) return;
                        navigateTo(parentPath, false);
                    };
                }
            }

            function setMapEmpty(visible) {
                var empty = document.getElementById('folder-map-empty');
                if (!empty) return;
                empty.hidden = !visible;
            }

            function renderMap(folderNode) {
                var svg = document.getElementById('folder-map-svg');
                if (!svg) return;

                var palette = getPalette();
                updateLegendColors(palette);

                var folders = Array.from(folderNode.children.values()).sort(compareFolder);
                var docs = buildDocFlowOrder(folderNode.docs.slice());

                var center = {
                    x: 600,
                    y: docs.length > 0 ? 198 : 220
                };

                var docPathSet = new Set(docs.map(function (doc) { return doc.path; }));
                var flowEdgeCount = 0;
                docs.forEach(function (doc) {
                    var nextPath = resolveChapterPath(doc.path, doc.next_chapter);
                    if (nextPath && docPathSet.has(nextPath) && nextPath !== doc.path) {
                        flowEdgeCount += 1;
                    }
                });

                var flowLayout = flowEdgeCount > 0 && docs.length > 0 && docs.length <= 8;
                var sequenceLayout = flowLayout;
                var cardWidth = flowLayout ? 252 : 232;
                var cardHeight = flowLayout ? 84 : 68;
                var gapX = flowLayout ? 24 : 16;
                var gapY = flowLayout ? 112 : 90;
                var docColumnCount;
                if (sequenceLayout) {
                    docColumnCount = 1;
                } else {
                    docColumnCount = Math.min(4, Math.max(1, Math.ceil(Math.sqrt(Math.max(1, docs.length)))));
                }
                var docRows = docs.length > 0 ? Math.ceil(docs.length / docColumnCount) : 0;

                var folderLayout = [];
                var folderNodeHeight = 58;
                var maxFolderBottom = center.y + 43;

                if (folders.length > 0) {
                    var startDeg = -170;
                    var endDeg = 140;
                    var folderOrbitSafePadding = Math.round(170 * SAFE_SCALE);
                    var orbitRadiusX = 600 - folderOrbitSafePadding - 105;
                    var orbitRadiusY = Math.max(120, Math.round(130 + 120 * SAFE_SCALE));
                    var step = folders.length === 1 ? 0 : (endDeg - startDeg) / (folders.length - 1);
                    var folderStrokePalette = ['#4dabf7', '#51cf66', '#9775fa', '#ff922b', '#22b8cf', '#f06595'];

                    folders.forEach(function (folder, index) {
                        var deg = folders.length === 1 ? -90 : (startDeg + step * index);
                        var rad = deg * (Math.PI / 180);
                        var folderColor = folderStrokePalette[index % folderStrokePalette.length];
                        var point = folders.length === 1
                            ? { x: center.x, y: center.y - 138 }
                            : {
                                x: center.x + orbitRadiusX * Math.cos(rad),
                                y: center.y + orbitRadiusY * Math.sin(rad)
                            };

                        folderLayout.push({ folder: folder, point: point, color: folderColor });
                        maxFolderBottom = Math.max(maxFolderBottom, point.y + folderNodeHeight / 2);
                    });
                }

                var docStartY = Math.max(322, maxFolderBottom + Math.max(30, Math.round(72 * SAFE_SCALE)));
                var bottomSafePadding = Math.max(20, Math.round(90 * SAFE_SCALE));
                var viewHeight = docs.length > 0
                    ? Math.max(
                        flowLayout ? 660 : 600,
                        docStartY + Math.max(0, docRows - 1) * gapY + cardHeight / 2 + bottomSafePadding
                    )
                    : Math.max(440, maxFolderBottom + 84);

                svg.setAttribute('viewBox', '0 0 1200 ' + viewHeight);
                svg.innerHTML = '';

                var defs = createSvgEl('defs', {});
                var markerPrev = createSvgEl('marker', {
                    id: 'arrow-prev',
                    viewBox: '0 0 10 10',
                    refX: '8',
                    refY: '5',
                    markerWidth: '7',
                    markerHeight: '7',
                    orient: 'auto'
                });
                markerPrev.appendChild(createSvgEl('path', { d: 'M 0 0 L 10 5 L 0 10 z', fill: palette.prev }));

                var markerPrevStart = createSvgEl('marker', {
                    id: 'arrow-prev-start',
                    viewBox: '0 0 10 10',
                    refX: '8',
                    refY: '5',
                    markerWidth: '6',
                    markerHeight: '6',
                    orient: 'auto-start-reverse'
                });
                markerPrevStart.appendChild(createSvgEl('path', { d: 'M 0 0 L 10 5 L 0 10 z', fill: palette.prev }));

                var markerNext = createSvgEl('marker', {
                    id: 'arrow-next',
                    viewBox: '0 0 10 10',
                    refX: '8',
                    refY: '5',
                    markerWidth: '7',
                    markerHeight: '7',
                    orient: 'auto'
                });
                markerNext.appendChild(createSvgEl('path', { d: 'M 0 0 L 10 5 L 0 10 z', fill: palette.next }));

                defs.appendChild(markerPrev);
                defs.appendChild(markerPrevStart);
                defs.appendChild(markerNext);
                svg.appendChild(defs);

                svg.appendChild(createSvgEl('rect', {
                    x: '0',
                    y: '0',
                    width: '1200',
                    height: String(viewHeight),
                    fill: palette.bg
                }));

                var branchLayer = createSvgEl('g', { 'pointer-events': 'none' });
                var relationLayer = createSvgEl('g', { 'pointer-events': 'none' });
                var nodeLayer = createSvgEl('g', {});
                svg.appendChild(branchLayer);
                svg.appendChild(relationLayer);
                svg.appendChild(nodeLayer);

                drawNode(nodeLayer, {
                    cx: center.x,
                    cy: center.y,
                    width: 290,
                    height: 86,
                    radius: 14,
                    fill: palette.primary,
                    stroke: palette.primary,
                    textColor: palette.bg,
                    title: folderNode.path ? folderNode.name : ROOT_LABEL,
                    subtitle: folderNode.path || '站点顶层目录',
                    subtitleSize: 13,
                    subtitleMax: 28,
                    titleMax: 18,
                    titleSize: 21,
                    titleWeight: 800,
                    tooltip: folderNode.path || ROOT_LABEL
                });

                if (folderLayout.length > 0) {
                    folderLayout.forEach(function (item) {
                        var folder = item.folder;
                        var point = item.point;
                        var midY = point.y < center.y ? (center.y - 34) : (center.y + 30);
                        var midX = Math.round((center.x + point.x) / 2);
                        var path = createSvgEl('path', {
                            d: polylinePath([
                                { x: center.x, y: center.y },
                                { x: midX, y: midY },
                                { x: point.x, y: point.y }
                            ]),
                            fill: 'none',
                            stroke: item.color,
                            'stroke-width': '2',
                            'stroke-opacity': '0.45'
                        });
                        branchLayer.appendChild(path);

                        drawNode(nodeLayer, {
                            cx: point.x,
                            cy: point.y,
                            width: 200,
                            height: 58,
                            radius: 10,
                            fill: palette.surface,
                            stroke: item.color,
                            textColor: palette.text,
                            title: folder.name,
                            titleMax: 14,
                            titleSize: 15,
                            subtitle: '目录',
                            subtitleSize: 12,
                            subtitleMax: 10,
                            tooltip: folder.path,
                            onClick: function () {
                                navigateTo(folder.path, false);
                            }
                        });
                    });
                }

                var docPointByPath = new Map();
                var docIndexByPath = new Map();
                var docHalfHeight = cardHeight / 2;
                var totalWidth = docColumnCount * cardWidth + (docColumnCount - 1) * gapX;
                var docStartX = (1200 - totalWidth) / 2 + cardWidth / 2;

                docs.forEach(function (doc, index) {
                    docIndexByPath.set(doc.path, index);
                    var col = index % docColumnCount;
                    var row = Math.floor(index / docColumnCount);
                    var point = {
                        x: docStartX + col * (cardWidth + gapX),
                        y: docStartY + row * gapY
                    };
                    docPointByPath.set(doc.path, point);

                    var docBranchStartY = center.y + 44;
                    var docTopY = point.y - docHalfHeight - 5;
                    var docMidY = Math.min(docTopY - 18, center.y + 154);
                    var branch = createSvgEl('path', {
                        d: polylinePath([
                            { x: center.x, y: docBranchStartY },
                            { x: center.x, y: docMidY },
                            { x: point.x, y: docMidY },
                            { x: point.x, y: docTopY }
                        ]),
                        fill: 'none',
                        stroke: palette.line,
                        'stroke-width': '1.8',
                        'stroke-opacity': '0.78'
                    });
                    branchLayer.appendChild(branch);

                    drawNode(nodeLayer, {
                        cx: point.x,
                        cy: point.y,
                        width: cardWidth,
                        height: cardHeight,
                        radius: 8,
                        fill: palette.surface,
                        stroke: palette.border,
                        textColor: palette.doc,
                        title: doc.title,
                        titleLines: wrapTextLines(doc.title, flowLayout ? 12 : 14, 2),
                        titleLineHeight: flowLayout ? 18 : 17,
                        titleSize: flowLayout ? 15 : 14,
                        tooltip: doc.path,
                        onClick: function () {
                            window.location.href = '/site/pages/viewer.html?file=' + encodeURIComponent(doc.path);
                        }
                    });
                });

                var prevEdges = [];
                var nextEdges = [];

                docs.forEach(function (doc) {
                    var source = docPointByPath.get(doc.path);
                    if (!source) return;
                    var sourceIndex = docIndexByPath.get(doc.path) || 0;

                    var prevPath = resolveChapterPath(doc.path, doc.prev_chapter);
                    var prevPoint = docPointByPath.get(prevPath);
                    if (prevPath && prevPoint && prevPath !== doc.path) {
                        var prevTargetIndex = docIndexByPath.get(prevPath) || 0;
                        prevEdges.push({
                            sourcePath: doc.path,
                            targetPath: prevPath,
                            source: source,
                            target: prevPoint,
                            sourceIndex: sourceIndex,
                            targetIndex: prevTargetIndex,
                            distance: Math.max(1, Math.abs(prevTargetIndex - sourceIndex))
                        });
                    }

                    var nextPath = resolveChapterPath(doc.path, doc.next_chapter);
                    var nextPoint = docPointByPath.get(nextPath);
                    if (nextPath && nextPoint && nextPath !== doc.path) {
                        var nextTargetIndex = docIndexByPath.get(nextPath) || 0;
                        nextEdges.push({
                            sourcePath: doc.path,
                            targetPath: nextPath,
                            source: source,
                            target: nextPoint,
                            sourceIndex: sourceIndex,
                            targetIndex: nextTargetIndex,
                            distance: Math.max(1, Math.abs(nextTargetIndex - sourceIndex))
                        });
                    }
                });

                function compareEdge(a, b) {
                    var distanceDelta = (b.distance || 0) - (a.distance || 0);
                    if (distanceDelta !== 0) return distanceDelta;
                    var sourceDelta = (a.sourceIndex || 0) - (b.sourceIndex || 0);
                    if (sourceDelta !== 0) return sourceDelta;
                    return (a.targetIndex || 0) - (b.targetIndex || 0);
                }

                prevEdges.sort(compareEdge);
                nextEdges.sort(compareEdge);
                var flowEdgeMap = new Map();
                nextEdges.forEach(function (edge) {
                    var key = edge.sourcePath + '->' + edge.targetPath;
                    flowEdgeMap.set(key, {
                        sourcePath: edge.sourcePath,
                        targetPath: edge.targetPath,
                        source: edge.source,
                        target: edge.target,
                        sourceIndex: edge.sourceIndex,
                        targetIndex: edge.targetIndex,
                        distance: edge.distance
                    });
                });

                prevEdges.forEach(function (edge) {
                    var reverseKey = edge.targetPath + '->' + edge.sourcePath;
                    if (flowEdgeMap.has(reverseKey)) return;
                    flowEdgeMap.set(reverseKey, {
                        sourcePath: edge.targetPath,
                        targetPath: edge.sourcePath,
                        source: edge.target,
                        target: edge.source,
                        sourceIndex: edge.targetIndex,
                        targetIndex: edge.sourceIndex,
                        distance: edge.distance
                    });
                });

                var flowEdges = Array.from(flowEdgeMap.values()).sort(compareEdge);

                if (sequenceLayout) {
                    var downwardLaneCount = 0;
                    var upwardLaneCount = 0;
                    var rightBaseX = center.x + cardWidth / 2 + 30;
                    var leftBaseX = center.x - cardWidth / 2 - 30;
                    var laneStep = 20;
                    var sidePortOffsets = new Map();
                    var minPortGap = 12;
                    var portOffsetStep = 12;

                    var reservePortOffset = function (sideKey, preferredOffset) {
                        var offsets = sidePortOffsets.get(sideKey);
                        if (!offsets) {
                            offsets = [];
                            sidePortOffsets.set(sideKey, offsets);
                        }

                        var candidate = preferredOffset;
                        var guard = 0;
                        while (guard < 40 && offsets.some(function (offset) {
                            return Math.abs(offset - candidate) < minPortGap;
                        })) {
                            var delta = (Math.floor(guard / 2) + 1) * portOffsetStep;
                            candidate = preferredOffset + (guard % 2 === 0 ? delta : -delta);
                            guard += 1;
                        }

                        offsets.push(candidate);
                        return candidate;
                    };

                    flowEdges.forEach(function (edge) {
                        var forward = edge.targetIndex >= edge.sourceIndex;
                        var laneIndex = forward ? downwardLaneCount++ : upwardLaneCount++;
                        var leftLaneX = leftBaseX - laneIndex * laneStep;
                        var rightLaneX = rightBaseX + laneIndex * laneStep;
                        var sourceLeftX = edge.source.x - cardWidth / 2 - 10;
                        var sourceRightX = edge.source.x + cardWidth / 2 + 10;
                        var targetLeftX = edge.target.x - cardWidth / 2 - 10;
                        var targetRightX = edge.target.x + cardWidth / 2 + 10;

                        var sourceLeftY = edge.source.y + reservePortOffset(
                            edge.sourcePath + ':left-out',
                            forward ? 18 : -18
                        );
                        var targetLeftY = edge.target.y + reservePortOffset(
                            edge.targetPath + ':left-in',
                            forward ? -18 : 18
                        );
                        var targetRightY = edge.target.y + reservePortOffset(
                            edge.targetPath + ':right-out',
                            forward ? -18 : 18
                        );
                        var sourceRightY = edge.source.y + reservePortOffset(
                            edge.sourcePath + ':right-in',
                            forward ? 18 : -18
                        );

                        relationLayer.appendChild(createSvgEl('path', {
                            d: polylinePath([
                                { x: sourceLeftX, y: sourceLeftY },
                                { x: leftLaneX, y: sourceLeftY },
                                { x: leftLaneX, y: targetLeftY },
                                { x: targetLeftX, y: targetLeftY }
                            ]),
                            fill: 'none',
                            stroke: palette.next,
                            'stroke-width': '2.1',
                            'stroke-opacity': '0.9',
                            'stroke-linecap': 'round',
                            'marker-end': 'url(#arrow-next)'
                        }));

                        relationLayer.appendChild(createSvgEl('path', {
                            d: polylinePath([
                                { x: targetRightX, y: targetRightY },
                                { x: rightLaneX, y: targetRightY },
                                { x: rightLaneX, y: sourceRightY },
                                { x: sourceRightX, y: sourceRightY }
                            ]),
                            fill: 'none',
                            stroke: palette.prev,
                            'stroke-width': '2.1',
                            'stroke-opacity': '0.9',
                            'stroke-linecap': 'round',
                            'marker-end': 'url(#arrow-prev)'
                        }));
                    });
                } else {
                    var flowBaseLane = flowEdges.length > 0
                        ? Math.round(Math.max.apply(null, flowEdges.map(function (edge) {
                            return Math.max(edge.source.y + docHalfHeight + 4, edge.target.y + docHalfHeight + 4);
                        })) + 64)
                        : 0;
                    var usedFlowColumns = [];

                    function reserveFlowColumn(preferredX) {
                        var candidate = clamp(Math.round(preferredX), 20, 1180);
                        var guard = 0;
                        while (guard < 80 && usedFlowColumns.some(function (col) {
                            return Math.abs(col - candidate) < 18;
                        })) {
                            var step = (Math.floor(guard / 2) + 1) * 18;
                            candidate = clamp(
                                preferredX + (guard % 2 === 0 ? step : -step),
                                20,
                                1180
                            );
                            guard += 1;
                        }
                        usedFlowColumns.push(candidate);
                        return candidate;
                    }

                    flowEdges.forEach(function (edge, edgeOrder) {
                        var sourceAnchorY = edge.source.y + docHalfHeight + 4;
                        var targetAnchorY = edge.target.y + docHalfHeight + 4;
                        var direction = edge.target.x >= edge.source.x ? 1 : -1;
                        var laneOffset = (Math.floor(edgeOrder / 2) + 1) * 16;
                        var sourcePortX = reserveFlowColumn(edge.source.x + direction * (24 + laneOffset));
                        var targetPortX = reserveFlowColumn(edge.target.x - direction * (28 + laneOffset));
                        var laneY = flowBaseLane + edgeOrder * 30;

                        relationLayer.appendChild(createSvgEl('path', {
                            d: polylinePath([
                                { x: edge.source.x, y: sourceAnchorY },
                                { x: sourcePortX, y: sourceAnchorY },
                                { x: sourcePortX, y: laneY },
                                { x: targetPortX, y: laneY },
                                { x: targetPortX, y: targetAnchorY },
                                { x: edge.target.x, y: targetAnchorY }
                            ]),
                            fill: 'none',
                            stroke: palette.next,
                            'stroke-width': '2.2',
                            'stroke-opacity': '0.9',
                            'stroke-linecap': 'round',
                            'marker-start': 'url(#arrow-prev-start)',
                            'marker-end': 'url(#arrow-next)'
                        }));
                    });
                }

                setMapEmpty(folders.length === 0 && docs.length === 0);
            }

            function applyPathToUrl(path, replace) {
                var normalized = normalizePath(path);
                var url = new URL(window.location.href);
                if (normalized) {
                    url.searchParams.set('path', normalized);
                } else {
                    url.searchParams.delete('path');
                }

                if (replace) {
                    window.history.replaceState({ path: normalized }, '', url.toString());
                } else {
                    window.history.pushState({ path: normalized }, '', url.toString());
                }
            }

            function navigateTo(path, replaceState) {
                var normalized = normalizePath(path);
                var node = getFolderNode(normalized);
                if (!node) {
                    normalized = '';
                    node = state.tree;
                }

                state.currentPath = normalized;
                updateSeo(normalized);
                applyPathToUrl(normalized, !!replaceState);
                updateToolbar(node);
                renderMap(node);
            }

            async function loadConfig() {
                var config;
                if (window.SiteConfig && typeof window.SiteConfig.load === 'function') {
                    config = await window.SiteConfig.load();
                } else {
                    var response = await fetch('/site/content/config.json');
                    if (!response.ok) throw new Error('无法加载配置文件: ' + response.status);
                    config = await response.json();
                }

                var rawDocs = Array.isArray(config && config.all_files) ? config.all_files : [];
                var docs = rawDocs.map(normalizeDoc).filter(Boolean);

                state.allDocs = docs;
                state.docByPath = new Map();
                docs.forEach(function (doc) {
                    state.docByPath.set(doc.path, doc);
                });
                state.tree = buildTree(docs);
            }

            function bindEvents() {
                window.addEventListener('popstate', function () {
                    var path = getFolderPathFromURL();
                    var node = getFolderNode(path);
                    if (!node) path = '';
                    state.currentPath = path;
                    updateSeo(path);
                    updateToolbar(getFolderNode(path));
                    renderMap(getFolderNode(path));
                });

                window.addEventListener('themechange', function () {
                    var node = getFolderNode(state.currentPath || '');
                    if (node) renderMap(node);
                });
            }

            document.addEventListener('DOMContentLoaded', function () {
                loadConfig().then(function () {
                    bindEvents();
                    navigateTo(getFolderPathFromURL(), true);
                }).catch(function (error) {
                    console.error('folder.html 初始化失败:', error);
                    setMapEmpty(true);
                    var empty = document.getElementById('folder-map-empty');
                    if (empty) {
                        empty.hidden = false;
                        empty.textContent = '加载目录数据失败，请稍后重试。';
                    }
                });
            });
        })();
    </script>
</body>
</html>
