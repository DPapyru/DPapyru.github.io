<!DOCTYPE html>
<!-- 泰拉瑞亚Mod制作教程文档查看器页面 -->
<html lang="zh-CN" data-theme="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>文档查看器 - 泰拉瑞亚Mod制作教程</title>

    <!-- SEO优化标签（实际值会在脚本中根据 ?file 和文档元数据更新） -->
    <meta name="description" content="泰拉瑞亚Mod制作教程文档阅读页面，支持目录、代码高亮与分类导航。">
    <meta name="keywords" content="泰拉瑞亚,Mod,教程,tModLoader,C#,文档">
    <meta name="author" content="泰拉瑞亚Mod社区">
    <meta name="robots" content="index, follow">

    <!-- Open Graph标签 -->
    <meta property="og:title" content="文档查看器 - 泰拉瑞亚Mod制作教程">
    <meta property="og:description" content="泰拉瑞亚Mod制作教程文档阅读页面，支持目录、代码高亮与分类导航。">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://dpapyru.github.io/site/pages/viewer.html">
    <meta property="og:image" content="https://dpapyru.github.io/site/assets/imgs/Green_tModLoader.png">
    <meta property="og:site_name" content="泰拉瑞亚Mod制作教程">
    <meta property="og:locale" content="zh_CN">

    <!-- Twitter Card标签 -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="文档查看器 - 泰拉瑞亚Mod制作教程">
    <meta name="twitter:description" content="泰拉瑞亚Mod制作教程文档阅读页面，支持目录、代码高亮与分类导航。">
    <meta name="twitter:image" content="https://dpapyru.github.io/site/assets/imgs/Green_tModLoader.png">

    <!-- 规范URL（实际值会在脚本中根据 ?file 更新） -->
    <link rel="canonical" href="https://dpapyru.github.io/site/pages/viewer.html">

    <!-- 加载CSS样式文件 -->
    <link rel="stylesheet" href="/site/assets/css/style.css">
    <link rel="stylesheet" href="/site/assets/css/workbench-phase.css"> <!-- 主样式文件 -->
    <link rel="stylesheet" href="/site/assets/css/prism.min.css"> <!-- 代码高亮样式 -->
    <link rel="stylesheet" href="/site/assets/css/rider-dark-theme.css"> <!-- Rider Dark代码高亮主题 -->
    <link rel="stylesheet" href="/site/assets/css/animts-runtime.css"> <!-- 动画运行时样式 -->
    <link rel="icon" type="image/png" href="/site/assets/imgs/Green_tModLoader.png"> <!-- 网站图标 -->

    <!-- 主题切换脚本 - 早期加载以避免闪烁 -->
    <script src="/site/assets/js/theme-init.js"></script>

    <!-- Studio 内嵌预览：仅显示 Markdown 渲染内容 -->
    <style>
        html[data-studio-embed='1'] .skip-link,
        html[data-studio-embed='1'] .site-header,
        html[data-studio-embed='1'] .learn-top-banner,
        html[data-studio-embed='1'] .sidebar,
        html[data-studio-embed='1'] .tutorial-header,
        html[data-studio-embed='1'] .comments-section,
        html[data-studio-embed='1'] .tutorial-footer,
        html[data-studio-embed='1'] .site-footer,
        html[data-studio-embed='1'] .mobile-nav-overlay,
        html[data-studio-embed='1'] .learn-modal-overlay,
        html[data-studio-embed='1'] #table-of-contents,
        html[data-studio-embed='1'] #source-code-section,
        html[data-studio-embed='1'] .mobile-nav-toggle,
        html[data-studio-embed='1'] .mobile-menu-toggle,
        html[data-studio-embed='1'] .viewer-ai-fab-wrap {
            display: none !important;
        }

        html[data-studio-embed='1'] body.viewer-page {
            margin: 0;
            min-height: 100vh;
        }

        html[data-studio-embed='1'] .site-container,
        html[data-studio-embed='1'] .main-content,
        html[data-studio-embed='1'] .content-wrapper,
        html[data-studio-embed='1'] .tutorial-content {
            width: 100%;
            max-width: none;
            margin: 0;
        }

        html[data-studio-embed='1'] .site-container {
            display: block;
            padding: 0;
            min-height: 0;
        }

        html[data-studio-embed='1'] .main-content {
            padding: 0;
            border: 0;
        }

        html[data-studio-embed='1'] .content-wrapper {
            padding: 12px 16px;
            border: 0;
            border-radius: 0;
            background: transparent;
            box-shadow: none;
        }

        html[data-studio-embed='1'] .tutorial-content {
            padding: 0;
            border: 0;
            background: transparent;
        }

        html[data-studio-embed='1'] #markdown-content > :first-child {
            margin-top: 0 !important;
        }

        html[data-studio-embed='1'] #markdown-content > :last-child {
            margin-bottom: 0 !important;
        }

        body.workbench-page .viewer-ai-fab-wrap {
            position: fixed;
            right: 18px;
            bottom: 20px;
            z-index: 1200;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
            touch-action: none;
        }

        .viewer-ai-fab-wrap[data-panel-align='left'] {
            align-items: flex-start;
        }

        .viewer-ai-fab-wrap[data-panel-align='right'] {
            align-items: flex-end;
        }

        .viewer-ai-fab {
            width: 52px;
            height: 52px;
            border: 1px solid var(--border-color);
            border-radius: 999px;
            background: var(--primary-color);
            color: var(--text-color);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition-fast);
            user-select: none;
            touch-action: none;
        }

        html[data-theme='dark'] .viewer-ai-fab {
            color: var(--text-color);
        }

        html:not([data-theme='dark']) .viewer-ai-fab {
            color: var(--bg-color);
        }

        .viewer-ai-fab:hover,
        .viewer-ai-fab:focus-visible {
            background: var(--primary-hover);
            transform: translateY(-1px);
            outline: none;
        }

        .viewer-ai-fab.viewer-ai-fab--dragging {
            cursor: grabbing;
            transform: none;
        }

        .viewer-ai-panel {
            width: clamp(420px, 50vw, 860px);
            max-height: min(82vh, 860px);
            overflow: auto;
            border: 1px solid var(--border-color);
            border-radius: 12px;
            background: var(--bg-secondary);
            color: var(--text-color);
            box-shadow: var(--shadow-lg);
            padding: 16px;
            display: grid;
            gap: 10px;
        }

        .viewer-ai-panel[hidden] {
            display: none;
        }

        .viewer-ai-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .viewer-ai-panel-header h3 {
            margin: 0;
            font-size: 14px;
        }

        .viewer-ai-close {
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: var(--bg-color);
            color: var(--text-color);
            width: 30px;
            height: 30px;
            cursor: pointer;
        }

        .viewer-ai-auth {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 8px;
        }

        .viewer-ai-notice {
            border: 1px dashed var(--border-color);
            border-radius: 8px;
            background: var(--bg-color);
            color: var(--text-secondary);
            padding: 8px 10px;
            font-size: 12px;
            line-height: 1.55;
        }

        .viewer-ai-auth-status,
        .viewer-ai-cooldown {
            display: inline-flex;
            align-items: center;
            min-height: 30px;
            padding: 0 10px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: var(--bg-color);
            color: var(--text-secondary);
            font-size: 12px;
        }

        .viewer-ai-panel label {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .viewer-ai-input,
        .viewer-ai-endpoint,
        .viewer-ai-output {
            width: 100%;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: var(--bg-color);
            color: var(--text-color);
            font-size: 13px;
            line-height: 1.5;
        }

        .viewer-ai-endpoint {
            padding: 8px 10px;
        }

        .viewer-ai-input {
            min-height: clamp(120px, 20vh, 220px);
            resize: vertical;
            padding: 8px 10px;
        }

        .viewer-ai-output {
            margin: 0;
            min-height: clamp(180px, 32vh, 420px);
            max-height: min(56vh, 520px);
            overflow: auto;
            padding: 10px;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .viewer-ai-output.viewer-ai-output--markdown {
            white-space: normal;
            line-height: 1.65;
        }

        .viewer-ai-output.viewer-ai-output--markdown h1,
        .viewer-ai-output.viewer-ai-output--markdown h2,
        .viewer-ai-output.viewer-ai-output--markdown h3,
        .viewer-ai-output.viewer-ai-output--markdown h4,
        .viewer-ai-output.viewer-ai-output--markdown h5,
        .viewer-ai-output.viewer-ai-output--markdown h6 {
            margin: 0.6em 0 0.45em;
            line-height: 1.35;
        }

        .viewer-ai-output.viewer-ai-output--markdown p,
        .viewer-ai-output.viewer-ai-output--markdown ul,
        .viewer-ai-output.viewer-ai-output--markdown ol,
        .viewer-ai-output.viewer-ai-output--markdown blockquote,
        .viewer-ai-output.viewer-ai-output--markdown pre,
        .viewer-ai-output.viewer-ai-output--markdown table {
            margin: 0.55em 0;
        }

        .viewer-ai-output.viewer-ai-output--markdown blockquote {
            margin-left: 0;
            padding-left: 0.8em;
            border-left: 3px solid var(--border-color);
            color: var(--text-secondary);
        }

        .viewer-ai-output.viewer-ai-output--markdown pre {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-secondary);
            padding: 10px;
            overflow: auto;
        }

        .viewer-ai-output.viewer-ai-output--markdown code {
            font-family: var(--font-family-tutorial);
            font-size: 12px;
        }

        .viewer-ai-output.viewer-ai-output--markdown a {
            color: var(--primary-color);
            text-decoration: underline;
        }

        .viewer-ai-input:focus,
        .viewer-ai-endpoint:focus,
        .viewer-ai-close:focus-visible,
        .viewer-ai-fab:focus-visible {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px var(--search-focus);
        }

        .viewer-ai-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        @media (max-width: 640px) {
            .viewer-ai-fab-wrap {
                right: 10px;
                bottom: 12px;
            }

            .viewer-ai-panel {
                width: min(100vw - 12px, 100vw - 12px);
                max-height: 86vh;
                padding: 12px;
            }

            .viewer-ai-output {
                min-height: 34vh;
                max-height: 58vh;
            }
        }
    </style>

</head>

<body class="workbench-page viewer-page">
    <a class="skip-link" href="#main-content">跳到主要内容</a>
    <!-- 网站头部导航区域 -->
    <header class="site-header">
        <div class="container">
            <div class="header-content">
                <div class="logo">
                    <a href="/site/index.html">
                        <img src="/site/assets/imgs/Green_tModLoader.png" alt="泰拉瑞亚Mod制作教程" class="logo-image">
                        <h1 class="site-title">泰拉瑞亚Mod制作教程</h1>
                    </a>
                </div>
                <form class="header-search" role="search" action="/site/search-results.html" method="get">
                    <label class="visually-hidden" for="header-search-q">搜索教程</label>
                    <input class="header-search-input" id="header-search-q" type="search" name="q" placeholder="搜索教程..." aria-label="搜索教程">
                    <button class="header-search-button" type="submit" aria-label="执行搜索">
                        <i class="icon-search" aria-hidden="true"></i>
                    </button>
                </form>
                <nav class="main-nav" id="main-nav">
                    <ul class="nav-list">
                        <li class="nav-item"><a href="/site/index.html" class="nav-link">首页</a></li>
                        <li class="nav-item"><a href="/site/pages/folder.html" class="nav-link">文档</a></li>
                        <li class="nav-item"><a href="/tml-ide/" class="nav-link">在线 IDE（Markdown/C#/HLSL）</a></li>
                        <li class="nav-item"><a href="/site/pages/shader-gallery.html" class="nav-link">Gallery</a></li>
                        <li class="nav-item"><a href="/site/qa.html" class="nav-link">问答</a></li>
                        <li class="nav-item"><a href="https://github.com/DPapyru/DPapyru.github.io" class="nav-link" target="_blank" rel="noopener noreferrer">GitHub</a></li>
                        <li class="nav-item nav-accent">
                            <label class="visually-hidden" for="accent-select">配色</label>
                            <select class="nav-accent-select" id="accent-select" aria-label="配色">
                                <option value="green">绿色</option>
                                <option value="blue">蓝色</option>
                                <option value="purple">紫色</option>
                                <option value="orange">橙色</option>
                                <option value="red">红色</option>
                                <option value="cyan">青色</option>
                                <option value="black">黑色</option>
                                <option value="white">白色</option>
                                <option value="vs">VS</option>
                                <option value="git">Git</option>
                                <option value="terraria-crimson">猩红</option>
                                <option value="terraria-corruption">腐化</option>
                                <option value="terraria-hallow">神圣</option>
                                <option value="terraria-tundra">冰原</option>
                                <option value="terraria-desert">沙漠</option>
                            </select>
                        </li>
                    </ul>
                </nav>
                <button class="mobile-menu-toggle" type="button" aria-label="切换菜单" aria-controls="main-nav" aria-expanded="false">
                    <span class="bar"></span>
                    <span class="bar"></span>
                    <span class="bar"></span>
                </button>
            </div>
        </div>
    </header>

    <!-- Learn 风格提示条（不影响阅读） -->
    <div class="learn-top-banner" id="learn-top-banner" role="status" aria-live="polite" aria-hidden="true" style="display:none;">
        <div class="container-fluid learn-top-banner-inner">
            <div class="learn-top-banner-left">
                <span class="learn-top-banner-icon" aria-hidden="true">ⓘ</span>
                <div class="learn-top-banner-text" id="learn-top-banner-text">当前按默认方式展示内容。</div>
            </div>
            <button class="learn-top-banner-close" id="learn-top-banner-close" type="button" aria-label="关闭提示">✕</button>
        </div>
    </div>

    <!-- 网站主体容器：包含侧边栏和主内容区 -->
    <div class="site-container ui-workbench-shell">
	        <!-- 左侧边栏：文档导航和相关链接 -->
	        <aside class="sidebar">
	            <div class="sidebar-content">
                    <!-- Learn 风格：侧边栏快速查找 -->
                    <div class="learn-sidebar-search" role="search">
                        <input class="learn-sidebar-search-input" id="sidebar-quick-search" type="search" placeholder="按标题查找" aria-label="按标题查找" autocomplete="off">
                    </div>
	                <!-- 侧边栏第一部分：文档导航 -->
	                <div class="sidebar-section">
	                    <h3 class="sidebar-title">文档导航</h3>
	                    <ul class="sidebar-list" id="category-sidebar">
	                        <!-- 分类侧边栏将通过JavaScript动态生成 -->
                    </ul>
                </div>
		                <!-- 侧边栏第二部分：当前分类文档 -->
		                <div class="sidebar-section">
		                    <h3 class="sidebar-title" id="current-category-title">当前分类</h3>
		                    <ul class="sidebar-list" id="current-category-docs">
		                        <!-- 当前分类的文档列表将通过JavaScript动态生成 -->
		                    </ul>
		                </div>
		                <!-- 侧边栏第三部分：贡献者信息 -->
		                <div class="sidebar-section">
		                    <h3 class="sidebar-title">贡献者</h3>
		                    <div class="contributors">
		                        <p>欢迎参与贡献！</p>
                        <a href="viewer.html?file=怎么贡献/教学文章写作指南.md" class="btn btn-small">如何贡献</a>
                    </div>
                </div>
            </div>
        </aside>

        <!-- 主内容区域：显示Markdown文档内容 -->
        <main class="workbench-main main-content" id="main-content" tabindex="-1">
            <div class="content-wrapper">
                <!-- 教程头部区域：包含面包屑导航和文档元信息 -->
                <div class="tutorial-header">
                    <!-- 面包屑导航 -->
                    <div class="tutorial-topbar">
                        <div class="breadcrumb">
                            <a href="../index.html">首页</a> &gt;
                            <a href="folder.html">文档</a> &gt;
                            <span class="current" id="current-doc-name">文档</span>
	                        </div>
		                        <div class="tutorial-actions" aria-label="阅读工具">
		                            <button class="btn btn-small btn-outline" id="focus-mode-toggle" type="button" aria-pressed="false">焦点模式</button>
		                        </div>
	                    </div>
                    <!-- 文档标题 -->
                    <h1 class="tutorial-title" id="doc-title">文档</h1>
                    <!-- 文档元信息：难度、时间、作者 -->
                    <div class="tutorial-meta" id="doc-meta">
                        <span class="difficulty">难度: <span class="difficulty-badge" id="doc-difficulty">未知</span></span>
                        <span class="time">预计时间: <span id="doc-time">未知</span></span>
                        <span class="author">作者: <span id="doc-author">未知</span></span>
                    </div>
                    <!-- 学习偏好/门槛提示（不拦截阅读） -->
                    <div class="learning-hints" id="learning-hints" aria-live="polite">
                        <div id="learning-hint-recommendation"></div>
                        <div id="learning-hint-prefs"></div>
                    </div>
                </div>

                <!-- 教程内容区域：加载和显示Markdown内容 -->
                <div class="tutorial-content">
                    <!-- 加载状态指示器：显示内容加载中的提示 -->
                    <div id="loading-indicator" class="loading-indicator" role="status" aria-live="polite" aria-busy="true">
                        <div class="loading-spinner"></div>
                        <p>正在加载内容...</p>
                    </div>

                    <!-- 错误信息容器：当内容加载失败时显示错误信息 -->
                    <div id="error-message" class="error-message" style="display: none;" role="alert" aria-live="assertive" aria-hidden="true">
                        <h3>加载失败</h3>
                        <p id="error-text">无法加载文档内容，请稍后再试。</p>
                    </div>

                    <!-- 目录容器：自动生成的文档目录 -->
                    <nav id="table-of-contents" class="table-of-contents" style="display: none;" aria-label="目录">
                        <h3>本文内容</h3>
                        <ul id="toc-list"></ul>
                    </nav>

	                    <!-- Markdown内容容器：渲染后的HTML内容将插入这里 -->
	                    <div id="markdown-content" class="markdown-content" style="display: none;">
	                        <!-- 文档内容将通过Markdown渲染后插入这里 -->
	                    </div>

	                    <!-- 源代码展示（可选：由 Markdown Front Matter 指定，可多文件） -->
	                    <section id="source-code-section" class="source-code-section" style="display: none;" aria-label="源代码" aria-hidden="true">
	                        <div id="source-code-list"></div>
	                    </section>
	                </div>

		                <!-- 评论区（Giscus） -->
		                <section class="comments-section" id="comments" aria-label="评论区">
		                    <h3 class="comments-title">评论</h3>
		                    <div id="giscus-container" class="giscus-container">
	                        <p class="comments-placeholder">评论区加载中…</p>
	                    </div>
	                </section>
	
	                <!-- 教程底部区域：导航链接和反馈表单 -->
	                <div class="tutorial-footer">
	                    <!-- 教程导航：上一篇/下一篇链接 -->
	                    <div class="tutorial-navigation">
                        <a href="folder.html" class="btn btn-outline prev-tutorial">← 返回文档列表</a>
	                        <a href="?file=Modder入门/DPapyru-从这里开始.md" class="btn btn-secondary">查看教程</a>
                        <a href="?file=怎么贡献/教学文章写作指南.md" class="btn btn-primary next-tutorial">贡献指南 →</a>
                    </div>
                    <!-- 教程反馈：用户反馈和问题提交 -->
                    <div class="tutorial-feedback">
                        <h3>教程反馈</h3>
                        <p>如果你对本教程有任何问题或建议，欢迎在GitHub上提出Issue或PR。</p>
                        <a href="https://github.com/DPapyru/DPapyru.github.io/issues" class="btn btn-small"
                            target="_blank" rel="noopener noreferrer">提供反馈</a>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- 网站底部区域 -->
    <div class="workbench-statusbar" role="status" aria-label="页面状态栏"><span class="workbench-statusbar-item">SWISS WORKBENCH</span><span class="workbench-statusbar-sep" aria-hidden="true">|</span><span class="workbench-statusbar-item">LAYOUT: IDE</span><span class="workbench-statusbar-spacer"></span><span class="workbench-statusbar-item">THEME: ACCENT</span></div>

    <footer class="site-footer">
        <div class="container">
            <!-- 底部内容容器 -->
            <div class="footer-content">
                <!-- 底部第一栏：关于项目 -->
                <div class="footer-section">
                    <h4>关于项目</h4>
                    <p>这是一个面向泰拉瑞亚Mod开发者的协作教程项目，旨在降低Mod制作门槛。</p>
                </div>
                <!-- 底部第二栏：快速链接 -->
                <div class="footer-section">
                    <h4>快速链接</h4>
                    <ul>
                        <li><a href="../index.html">首页</a></li>
                        <li><a href="folder.html">文档</a></li>
                        <li><a href="https://github.com/DPapyru/DPapyru.github.io" target="_blank" rel="noopener noreferrer">GitHub</a></li>
                    </ul>
                </div>
                <!-- 底部第三栏：联系我们 -->
                <div class="footer-section">
                    <h4>联系我们</h4>
                    <ul>
                        <li><a href="https://github.com/DPapyru/DPapyru.github.io" target="_blank" rel="noopener noreferrer">GitHub</a></li>
                        <li><a href="mailto:contact@example.com">邮箱</a></li>
                    </ul>
                </div>
            </div>
            <!-- 底部版权信息 -->
            <div class="footer-bottom">
                <p>&copy; 2023 泰拉瑞亚Mod制作教程. 采用 <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener noreferrer">CC
                        BY 4.0</a> 许可协议。</p>
            </div>
        </div>
    </footer>

	    <!-- 手机端导航覆盖层 -->
	    <div class="mobile-nav-overlay" id="mobile-nav-overlay" role="dialog" aria-modal="true" aria-label="文档导航" aria-hidden="true">
        <!-- 导航区域 (占屏幕2/3) -->
        <div class="mobile-nav-content">
            <div class="mobile-nav-header">
                <h3>文档导航</h3>
                <button class="mobile-nav-close" id="mobile-nav-close" type="button" aria-label="关闭导航">✕</button>
            </div>
            <div class="mobile-nav-body">
                <!-- 导航内容将在这里动态生成 -->
                <div class="mobile-nav-sections" id="mobile-nav-sections">
                    <!-- 分类导航将通过JavaScript动态生成 -->
                </div>
            </div>
        </div>
        <!-- 半透明返回区域 (占屏幕1/3) -->
	        <button class="mobile-nav-back" id="mobile-nav-back" type="button" aria-label="返回文章">
	            <div class="mobile-nav-back-hint">
	                <p>点击此处返回文章</p>
	                <div class="back-arrow">↑</div>
	            </div>
	        </button>
	    </div>

	    <div class="learning-sidebar-panel" id="learning-sidebar-panel" hidden></div>

	    <div class="viewer-ai-fab-wrap" id="viewer-ai-root">
	        <button class="viewer-ai-fab" id="viewer-ai-fab" type="button" aria-label="打开 AI 对话" aria-controls="viewer-ai-panel" aria-expanded="false">AI</button>
	        <section class="viewer-ai-panel" id="viewer-ai-panel" aria-label="AI 对话服务" hidden>
	            <div class="viewer-ai-panel-header">
	                <h3>AI 对话</h3>
	                <button class="viewer-ai-close" id="viewer-ai-close" type="button" aria-label="关闭 AI 对话">✕</button>
	            </div>
	            <div class="viewer-ai-auth">
	                <span class="viewer-ai-auth-status" id="viewer-ai-auth-status">未登录</span>
	                <button class="btn btn-small" id="viewer-ai-login" type="button">GitHub 登录</button>
	                <button class="btn btn-small btn-outline" id="viewer-ai-logout" type="button">退出</button>
	            </div>
	            <div class="viewer-ai-notice" id="viewer-ai-notice">AI 生成内容可能不准确，请以教程原文为准。</div>
	            <label for="viewer-ai-endpoint">AI API 地址</label>
	            <input class="viewer-ai-endpoint" id="viewer-ai-endpoint" type="text" autocomplete="off">
	            <div class="viewer-ai-actions">
	                <button class="btn btn-small" id="viewer-ai-send" type="button">发送 AI 对话</button>
	                <span class="viewer-ai-cooldown" id="viewer-ai-cooldown">可发送</span>
	            </div>
	            <label for="viewer-ai-input">提问内容</label>
	            <textarea class="viewer-ai-input" id="viewer-ai-input" rows="4" placeholder="输入你的问题，然后发送给 AI。"></textarea>
	            <label for="viewer-ai-output">AI 回复</label>
	            <div class="viewer-ai-output" id="viewer-ai-output" role="status" aria-live="polite">等待提问...</div>
	        </section>
	    </div>

		    <!-- 加载JavaScript文件 -->
			    <script src="/shared/assets/js/site-core.js"></script>
                <script>
                    if (window.SITE) window.SITE.bootstrapPage('viewer');
                </script>
			    <script src="/site/assets/js/site-config.js"></script>
			    <script src="/site/assets/js/marked.min.js"></script> <!-- Markdown解析库 -->
			    <script src="/site/assets/js/mermaid.min.js"></script> <!-- Mermaid流程图渲染 -->
		    <script src="/site/assets/js/site-quiz.js"></script> <!-- Quiz 题目渲染 -->
		    <script src="/site/assets/js/prism.min.js"></script> <!-- 代码高亮库 -->
		    <script src="/site/assets/js/prism-csharp.min.js"></script> <!-- C#语言高亮支持 -->
                <script src="/site/assets/js/animcs-js-runtime.js"></script> <!-- C# 动画运行时（JS 输出） -->
    <script>
        // Mermaid 兜底加载：如果本地资源缺失/加载失败，则尝试从 CDN 加载（不影响已有本地加载）
        (function ensureMermaidLoaded() {
            if (window.mermaid) {
                window.__MERMAID_LOADED = true;
                window.__MERMAID_LOAD_PROMISE = Promise.resolve(true);
                return;
            }

            if (window.__MERMAID_LOAD_PROMISE) return;

            const cdnUrl = 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js';
            window.__MERMAID_LOAD_PROMISE = new Promise((resolve) => {
                const script = document.createElement('script');
                script.src = cdnUrl;
                script.async = true;
                script.referrerPolicy = 'no-referrer';
                script.onload = () => {
                    window.__MERMAID_LOADED = true;
                    console.log('Mermaid 已从 CDN 加载');
                    resolve(true);
                };
                script.onerror = () => {
                    console.warn('Mermaid CDN 加载失败，请检查 /site/assets/js/mermaid.min.js 是否存在');
                    resolve(false);
                };
                document.head.appendChild(script);
            });
        })();
    </script>
    <script>
        // 设置一个标志，告诉main.js这是viewer.html页面，不要执行自动加载
        window.IS_VIEWER_PAGE = true;

        // 禁用main.js中的路由系统，避免干扰viewer.html的文件加载
        window.DISABLE_ROUTER = true;
    </script>
	    <script src="/site/assets/js/accent-theme.js"></script>
	    <script src="/site/assets/js/main.js"></script> <!-- 主要功能脚本 -->
	    <script src="/site/assets/js/navigation.js"></script> <!-- 导航功能脚本 -->
	    <script src="/site/assets/js/giscus-docs.js"></script> <!-- 文档评论（Giscus） -->
	
	    <script>
        // 文档配置和元数据管理
        let VIEWER_DOC_CONFIG = null;
        let ALL_DOCS = [];
	        let CURRENT_DOC_PATH = null;
	        let DOC_LOOKUP_MAP = null;
	        const STUDIO_PREVIEW_STORAGE_KEY = 'articleStudioViewerPreview.v1';
	        let STUDIO_PREVIEW_MODE = false;
	        let STUDIO_EMBED_MODE = false;
	        let STUDIO_PREVIEW_RELOAD_TIMER = 0;
	        let STUDIO_PREVIEW_LAST_IMAGE_NOTICE = '';
	        let STUDIO_PREVIEW_LAST_IMAGE_NOTICE_AT = 0;

	        function normalizeStudioPreviewPath(input) {
	            let value = String(input || '').trim().replace(/\\/g, '/').replace(/^\/+/, '');
	            value = value.replace(/^site\/content\//i, '').replace(/^content\//i, '').replace(/\/{2,}/g, '/');
	            return value;
	        }

	        function readStudioPreviewPayloadFromStorage() {
	            try {
	                const raw = window.localStorage.getItem(STUDIO_PREVIEW_STORAGE_KEY);
	                if (!raw) return null;
	                const parsed = JSON.parse(raw);
	                if (!parsed || typeof parsed !== 'object') return null;
	                const targetPath = normalizeStudioPreviewPath(parsed.targetPath || '');
	                if (!targetPath) return null;
	                const uploadedImages = Array.isArray(parsed.uploadedImages)
                    ? parsed.uploadedImages.map(function (item) {
                        return {
                            assetPath: normalizeStudioPreviewPath(item && item.assetPath || ''),
                            dataUrl: String(item && item.dataUrl || ''),
                            name: String(item && item.name || '')
                        };
                    }).filter(function (item) {
                        return item.assetPath && item.dataUrl;
                    })
                    : [];
                const uploadedMedia = Array.isArray(parsed.uploadedMedia)
                    ? parsed.uploadedMedia.map(function (item) {
                        return {
                            assetPath: normalizeStudioPreviewPath(item && item.assetPath || ''),
                            dataUrl: String(item && item.dataUrl || ''),
                            name: String(item && item.name || ''),
                            type: String(item && item.type || '')
                        };
                    }).filter(function (item) {
                        return item.assetPath && item.dataUrl;
                    })
                    : [];
                const uploadedCsharpFiles = Array.isArray(parsed.uploadedCsharpFiles)
                    ? parsed.uploadedCsharpFiles.map(function (item) {
                        return {
                            assetPath: normalizeStudioPreviewPath(item && item.assetPath || ''),
                            content: String(item && item.content || ''),
                            name: String(item && item.name || '')
                        };
                    }).filter(function (item) {
                        return item.assetPath && item.content;
                    })
                    : [];
                return {
                    targetPath: targetPath,
                    markdown: String(parsed.markdown || ''),
                    uploadedImages: uploadedImages,
                    uploadedMedia: uploadedMedia,
                    uploadedCsharpFiles: uploadedCsharpFiles,
                    updatedAt: String(parsed.updatedAt || '')
                };
	            } catch (_) {
	                return null;
	            }
	        }

	        function isStudioPreviewModeEnabled() {
            try {
                const url = new URL(window.location.href);
                const flag = String(url.searchParams.get('studio_preview') || '').trim().toLowerCase();
                return flag === '1' || flag === 'true' || flag === 'yes';
            } catch (_) {
                return false;
            }
        }

        function isStudioEmbedModeEnabled() {
            try {
                const url = new URL(window.location.href);
                const flag = String(url.searchParams.get('studio_embed') || '').trim().toLowerCase();
                const requested = flag === '1' || flag === 'true' || flag === 'yes';
                return requested && window.parent !== window;
            } catch (_) {
                return false;
            }
        }

        function applyStudioEmbedMode() {
            if (!STUDIO_EMBED_MODE) return;
            document.documentElement.setAttribute('data-studio-embed', '1');
            if (document.body) {
                document.body.classList.add('viewer-studio-embed');
            }
        }

	        function getStudioPreviewTargetPath() {
	            if (!STUDIO_PREVIEW_MODE) return '';
	            const payload = readStudioPreviewPayloadFromStorage();
	            return payload && payload.targetPath ? normalizeStudioPreviewPath(payload.targetPath) : '';
	        }

	        function notifyStudioPreviewImageMapped(assetPath) {
	            if (!STUDIO_PREVIEW_MODE) return;
	
	            const normalized = normalizeStudioPreviewPath(assetPath || '');
	            if (!normalized) return;
	
	            const now = Date.now();
	            if (
	                STUDIO_PREVIEW_LAST_IMAGE_NOTICE === normalized &&
	                now - STUDIO_PREVIEW_LAST_IMAGE_NOTICE_AT < 1500
	            ) {
	                return;
	            }
	
	            STUDIO_PREVIEW_LAST_IMAGE_NOTICE = normalized;
	            STUDIO_PREVIEW_LAST_IMAGE_NOTICE_AT = now;
	
	            try {
	                if (window.parent && window.parent !== window) {
	                    window.parent.postMessage({
	                        type: 'article-studio-preview-image-mapped',
	                        payload: {
	                            assetPath: normalized
	                        }
	                    }, window.location.origin);
	                }
	            } catch (_) {
	                // ignore postMessage errors
	            }
	        }

	        function resolveStudioPreviewImageDataUrl(rawPath) {
	            if (!STUDIO_PREVIEW_MODE) return '';

	            const payload = readStudioPreviewPayloadFromStorage();
	            if (!payload || !Array.isArray(payload.uploadedImages) || payload.uploadedImages.length === 0) {
	                return '';
	            }

	            let normalized = String(rawPath || '').trim();
	            if (!normalized) return '';

	            normalized = normalized.split('#')[0].split('?')[0];
	            try {
	                normalized = decodeURIComponent(normalized);
	            } catch (_) {
	                normalized = normalized;
	            }
	            normalized = normalized.replace(/^https?:\/\/[^/]+/i, '');
	            normalized = normalized.replace(/^\/site\/content\//i, '');
	            normalized = normalized.replace(/^site\/content\//i, '');
	            normalized = normalized.replace(/^content\//i, '');
	            normalized = normalizeStudioPreviewPath(normalized);

	            if (!normalized) return '';

	            const item = payload.uploadedImages.find(function (image) {
	                return normalizeStudioPreviewPath(image && image.assetPath || '') === normalized;
	            });
	
	            if (item && item.dataUrl) {
	                notifyStudioPreviewImageMapped(item.assetPath || normalized);
	                return String(item.dataUrl);
	            }
	
	            return '';
	        }

            function resolveStudioPreviewMediaDataUrl(rawPath) {
                if (!STUDIO_PREVIEW_MODE) return '';

                const payload = readStudioPreviewPayloadFromStorage();
                if (!payload || !Array.isArray(payload.uploadedMedia) || payload.uploadedMedia.length === 0) {
                    return '';
                }

                let normalized = String(rawPath || '').trim();
                if (!normalized) return '';

                normalized = normalized.split('#')[0].split('?')[0];
                try {
                    normalized = decodeURIComponent(normalized);
                } catch (_) {
                    normalized = normalized;
                }
                normalized = normalized.replace(/^https?:\/\/[^/]+/i, '');
                normalized = normalized.replace(/^\/site\/content\//i, '');
                normalized = normalized.replace(/^site\/content\//i, '');
                normalized = normalized.replace(/^content\//i, '');
                normalized = normalizeStudioPreviewPath(normalized);

                if (!normalized) return '';

                const item = payload.uploadedMedia.find(function (media) {
                    return normalizeStudioPreviewPath(media && media.assetPath || '') === normalized;
                });

                if (item && item.dataUrl) {
                    return String(item.dataUrl);
                }

                return '';
            }

        function installStudioPreviewFetchBridge() {
	            if (!STUDIO_PREVIEW_MODE) return;
	            if (window.__STUDIO_PREVIEW_FETCH_PATCHED) return;

	            const nativeFetch = window.fetch.bind(window);
	            window.fetch = function (input, init) {
	                try {
	                    let requestUrl = null;
	                    if (typeof input === 'string') {
	                        requestUrl = new URL(input, window.location.origin);
	                    } else if (input && typeof input.url === 'string') {
	                        requestUrl = new URL(input.url, window.location.origin);
	                    }

	                    if (requestUrl && requestUrl.pathname.startsWith('/site/content/')) {
	                        let requestPath = requestUrl.pathname.replace(/^\/site\/content\//, '');
	                        try {
	                            requestPath = decodeURIComponent(requestPath);
	                        } catch (_) {
	                            requestPath = requestPath;
	                        }
	                        requestPath = normalizeStudioPreviewPath(requestPath);
	
	                        const payload = readStudioPreviewPayloadFromStorage();
	                        if (payload) {
	                            if (payload.targetPath === requestPath) {
	                                return Promise.resolve(new Response(payload.markdown || '', {
	                                    status: 200,
	                                    headers: {
	                                        'content-type': 'text/markdown; charset=utf-8'
	                                    }
	                                }));
	                            }

                            const imageMatch = (payload.uploadedImages || []).find(function (item) {
                                return normalizeStudioPreviewPath(item.assetPath || '') === requestPath;
                            });
                            if (imageMatch && imageMatch.dataUrl) {
                                return nativeFetch(imageMatch.dataUrl, init);
                            }

                            const mediaMatch = (payload.uploadedMedia || []).find(function (item) {
                                return normalizeStudioPreviewPath(item.assetPath || '') === requestPath;
                            });
                            if (mediaMatch && mediaMatch.dataUrl) {
                                return nativeFetch(mediaMatch.dataUrl, init);
                            }

                            const csharpMatch = (payload.uploadedCsharpFiles || []).find(function (item) {
                                return normalizeStudioPreviewPath(item.assetPath || '') === requestPath;
                            });
                            if (csharpMatch && csharpMatch.content) {
                                return Promise.resolve(new Response(csharpMatch.content, {
                                    status: 200,
                                    headers: {
                                        'content-type': 'text/x-csharp; charset=utf-8'
                                    }
                                }));
                            }
	                        }
	                    }
	                } catch (_) {
	                    // ignore and fallback
	                }

	                return nativeFetch(input, init);
	            };

	            window.__STUDIO_PREVIEW_FETCH_PATCHED = true;
	        }

	        function scheduleStudioPreviewReload(path) {
	            if (!STUDIO_PREVIEW_MODE) return;
	            const targetPath = normalizeStudioPreviewPath(path || CURRENT_DOC_PATH || '');
	            if (!targetPath) return;

	            if (STUDIO_PREVIEW_RELOAD_TIMER) {
	                clearTimeout(STUDIO_PREVIEW_RELOAD_TIMER);
	            }

	            STUDIO_PREVIEW_RELOAD_TIMER = window.setTimeout(function () {
	                STUDIO_PREVIEW_RELOAD_TIMER = 0;
	                try {
	                    const currentPath = normalizeStudioPreviewPath(CURRENT_DOC_PATH || '');
	                    if (currentPath && currentPath === targetPath && typeof rerenderCurrentDocPreserveScroll === 'function') {
	                        rerenderCurrentDocPreserveScroll();
	                        return;
	                    }

	                    loadMarkdownDirectly(targetPath);
	                } catch (err) {
	                    console.warn('studio preview reload failed:', err);
	                }
	            }, 80);
	        }

	        function installStudioPreviewMessageBridge() {
	            if (!STUDIO_PREVIEW_MODE) return;
	            if (window.__STUDIO_PREVIEW_MESSAGE_PATCHED) return;

	            window.addEventListener('message', function (event) {
	                if (event.origin !== window.location.origin) return;
	                const data = event && event.data ? event.data : null;
	                if (!data || data.type !== 'article-studio-preview-update') return;

	                const payload = data.payload || {};
	                const targetPath = normalizeStudioPreviewPath(payload.targetPath || '');
	                if (!targetPath) return;

	                try {
	                    window.localStorage.setItem(STUDIO_PREVIEW_STORAGE_KEY, JSON.stringify({
                        targetPath: targetPath,
                        markdown: String(payload.markdown || ''),
                        uploadedImages: Array.isArray(payload.uploadedImages) ? payload.uploadedImages : [],
                        uploadedMedia: Array.isArray(payload.uploadedMedia) ? payload.uploadedMedia : [],
                        uploadedCsharpFiles: Array.isArray(payload.uploadedCsharpFiles) ? payload.uploadedCsharpFiles : [],
                        updatedAt: String(payload.updatedAt || new Date().toISOString())
                    }));
	                } catch (_) {
	                    // ignore storage failures
	                }

	                if (normalizeStudioPreviewPath(CURRENT_DOC_PATH || '') === targetPath) {
	                    scheduleStudioPreviewReload(targetPath);
	                }
	            });

	            window.__STUDIO_PREVIEW_MESSAGE_PATCHED = true;
	        }

	        
	        function initializeMermaidOnce() {
	            if (window.__MERMAID_INITIALIZED) return;
	            if (!window.mermaid || typeof window.mermaid.initialize !== 'function') return;
		            window.mermaid.initialize({
		                startOnLoad: false,
		                theme: 'dark',
		                securityLevel: 'strict',
		                flowchart: {
		                    htmlLabels: true,
		                    // Mermaid 会为箭头预留一点长度，子图标题区域太紧时箭头会“戳进标题里”
		                    titleTopMargin: 36
		                }
		            });
		            window.__MERMAID_INITIALIZED = true;
		        }

	        function autoWrapMermaidFlowchartSource(source, maxCharsPerLine = 16) {
	            const text = String(source || '');
	            const lines = text.split('\n');
	            const firstNonEmpty = lines.find(line => String(line).trim()) || '';
	            const diagramType = String(firstNonEmpty).trim().split(/\s+/)[0] || '';

	            // 仅对 flowchart/graph 做自动换行，避免误伤 sequenceDiagram 等其它语法
	            if (diagramType !== 'flowchart' && diagramType !== 'graph') return text;

	            function isBreakChar(ch) {
	                return (
	                    ch === ' ' ||
	                    ch === '　' ||
	                    ch === '/' ||
	                    ch === '／' ||
	                    ch === '|' ||
	                    ch === '：' ||
	                    ch === ':' ||
	                    ch === '，' ||
	                    ch === ',' ||
	                    ch === '、' ||
	                    ch === ';' ||
	                    ch === '；' ||
	                    ch === '-' ||
	                    ch === '—'
	                );
	            }

	            function trimStartSpaces(chars) {
	                while (chars.length > 0 && (chars[0] === ' ' || chars[0] === '　')) chars.shift();
	                return chars;
	            }

	            function trimEndSpaces(chars) {
	                while (chars.length > 0 && (chars[chars.length - 1] === ' ' || chars[chars.length - 1] === '　')) chars.pop();
	                return chars;
	            }

	            function findLastBreakIndex(chars) {
	                for (let i = chars.length - 1; i >= 0; i--) {
	                    if (isBreakChar(chars[i])) return i + 1; // 在该字符后断行
	                }
	                return -1;
	            }

	            function wrapLabel(label) {
	                const raw = String(label || '');
	                if (!raw) return raw;
	                if (raw.includes('<br') || raw.includes('\\n')) return raw;

	                const chars = Array.from(raw);
	                const out = [];
	                let line = [];
	                let lastBreakIndex = -1;

	                for (let i = 0; i < chars.length; i++) {
	                    const ch = chars[i];
	                    line.push(ch);
	                    if (isBreakChar(ch)) lastBreakIndex = line.length;

	                    const isLast = i === chars.length - 1;
	                    if (!isLast && line.length >= maxCharsPerLine) {
	                        const cut = lastBreakIndex > 0 ? lastBreakIndex : line.length;
	                        const before = trimEndSpaces(line.slice(0, cut)).join('');
	                        out.push(before);
	                        out.push('<br/>');

	                        line = trimStartSpaces(line.slice(cut));
	                        lastBreakIndex = findLastBreakIndex(line);
	                    }
	                }

	                if (line.length > 0) out.push(line.join(''));
	                return out.join('');
	            }

	            function wrapSquareBracketLabels(line) {
	                let cursor = 0;
	                let output = '';
	                while (cursor < line.length) {
	                    const open = line.indexOf('[', cursor);
	                    if (open === -1) {
	                        output += line.slice(cursor);
	                        break;
	                    }
	                    const close = line.indexOf(']', open + 1);
	                    if (close === -1) {
	                        output += line.slice(cursor);
	                        break;
	                    }

	                    const label = line.slice(open + 1, close);
	                    output += line.slice(cursor, open + 1);
	                    output += wrapLabel(label);
	                    output += ']';
	                    cursor = close + 1;
	                }
	                return output;
	            }

		            return lines.map(wrapSquareBracketLabels).join('\n');
		        }

		        function postProcessMermaidSvg(container) {
		            if (!container) return;
		            const svg = container.querySelector('svg');
		            if (!svg) return;

		            try {
		                // 1) 修复绘制层级：确保节点层永远在连线层上方，避免连线“穿过”节点的视觉问题
		                const root = svg.querySelector('g.root');
		                if (root) {
		                    const edgePaths = root.querySelector(':scope > g.edgePaths');
		                    const edgeLabels = root.querySelector(':scope > g.edgeLabels');
		                    const nodes = root.querySelector(':scope > g.nodes');
		                    if (edgePaths) root.appendChild(edgePaths);
		                    if (edgeLabels) root.appendChild(edgeLabels);
		                    if (nodes) root.appendChild(nodes);
		                }

		                // 2) 防御性修复：某些配置/浏览器下节点填充可能变成透明，导致底下的连线可见
		                const shapes = svg.querySelectorAll(
		                    '.node rect, .node polygon, .node ellipse, .node circle, .node path,' +
		                    '.rough-node rect, .rough-node polygon, .rough-node ellipse, .rough-node circle, .rough-node path'
		                );

		                shapes.forEach((shape) => {
		                    if (!shape || !window.getComputedStyle) return;
		                    const computed = window.getComputedStyle(shape);
		                    const fill = String(computed.fill || '').trim();
		                    const fillOpacity = String(computed.fillOpacity || '').trim();

		                    const opacityNumber = parseFloat(fillOpacity);
		                    const isTransparentFill =
		                        !fill ||
		                        fill === 'none' ||
		                        fill === 'transparent' ||
		                        /rgba\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*0\s*\)/.test(fill) ||
		                        (!Number.isNaN(opacityNumber) && opacityNumber === 0);

		                    if (!isTransparentFill) return;
		                    shape.style.fill = 'var(--bg-color)';
		                    shape.style.fillOpacity = '1';
		                });
		            } catch (error) {
		                console.warn('Mermaid SVG 后处理失败:', error);
		            }
		        }

		        async function renderMermaidFlowcharts(root) {
		            try {
		                if (!root) return;
		                const nodes = root.querySelectorAll('.flowchart.mermaid');
	                if (!nodes || nodes.length === 0) return;
	                if (!window.mermaid) {
	                    if (window.__MERMAID_LOAD_PROMISE) {
	                        await window.__MERMAID_LOAD_PROMISE;
	                    }
	                    if (!window.mermaid) {
	                        console.warn('Mermaid 未加载，跳过流程图渲染');
	                        return;
	                    }
	                }

	                initializeMermaidOnce();

	                // 自动换行：在 Mermaid 布局计算之前改写 source，避免长中文文本被裁切
	                nodes.forEach((node) => {
	                    if (!node || node.getAttribute('data-processed') === 'true') return;
	                    const original = node.textContent || '';
	                    const updated = autoWrapMermaidFlowchartSource(original, 16);
	                    if (updated !== original) node.textContent = updated;
	                });

	                if (document.fonts && document.fonts.ready && typeof document.fonts.ready.then === 'function') {
	                    await document.fonts.ready;
	                }

		                if (typeof window.mermaid.run === 'function') {
		                    await window.mermaid.run({ nodes });
		                } else if (typeof window.mermaid.init === 'function') {
		                    window.mermaid.init(undefined, nodes);
		                }

	                nodes.forEach((node) => { postProcessMermaidSvg(node); });
		            } catch (error) {
		                console.warn('流程图渲染失败:', error);
		            }
		        }

        // 主分类配置 - 将从配置文件动态加载
        let MAIN_CATEGORIES = {};
        
        // 主题领域配置 - 将从配置文件动态加载
        let TOPIC_AREAS = {};
        
        // 路径重定向映射 - 将从配置文件动态加载
        let VIEWER_PATH_REDIRECTS = {};

        // 文档查看器的主要JavaScript逻辑
			        document.addEventListener('DOMContentLoaded', function () {
			            console.log('=== site/pages/viewer.html: 页面加载完成 ===');
			            console.log('=== 诊断信息 ===');
			            console.log('当前页面URL:', window.location.href);
			            console.log('当前页面路径:', window.location.pathname);
			            console.log('当前搜索参数:', window.location.search);

	                    // Learn 风格：焦点模式与侧边栏快速查找
	                    initializeViewerFocusMode();
	                    initializeSidebarQuickSearch();

	            // 初始化MD渲染器（优先，避免其它初始化异常导致 Markdown 无法渲染）
	            initializeMarkedRender();

	            // 初始化侧边栏滚动功能
	            initializeSidebarScrolling();

            STUDIO_PREVIEW_MODE = isStudioPreviewModeEnabled();
            STUDIO_EMBED_MODE = isStudioEmbedModeEnabled();
            applyStudioEmbedMode();
            installStudioPreviewFetchBridge();
            installStudioPreviewMessageBridge();

            // 初始化文档配置
            Promise.all([initializeDocumentConfig()]).then(() => {
                // 初始化分类导航
                initializeCategoryNavigation();

                // 从URL参数获取要加载的Markdown文件
                const urlParams = new URLSearchParams(window.location.search);
                let markdownFile = urlParams.get('file');
                const studioTargetPath = getStudioPreviewTargetPath();
                if (studioTargetPath) {
                    markdownFile = studioTargetPath;
                    console.log('studio_preview 模式：优先使用草稿目标路径:', markdownFile);
                } else {
                    console.log('从URL参数获取的文件名:', markdownFile);
                }

                // 如果没有指定文件，尝试从路径中获取
                if (!markdownFile) {
                    const pathParts = window.location.pathname.split('/');
                    markdownFile = pathParts[pathParts.length - 1];
                    console.log('从路径获取的文件名:', markdownFile);
                }

                // 如果还是没有，默认加载第一个可用的文档
                if (!markdownFile || !markdownFile.endsWith('.md')) {
                    // 尝试从配置中获取第一个文档
                    if (ALL_DOCS && ALL_DOCS.length > 0) {
                        markdownFile = ALL_DOCS[0].filename || ALL_DOCS[0].path;
                        console.log('使用配置中的第一个文档:', markdownFile);
	                    } else {
	                        // 如果没有配置，使用已知的文档
	                        markdownFile = 'Modder入门/DPapyru-从这里开始.md';
	                        console.log('使用默认文档:', markdownFile);
	                    }
	                }

                console.log(`site/pages/viewer.html: 准备加载Markdown文件: ${markdownFile}`);

                // 延迟加载，确保所有脚本都已初始化
                setTimeout(function () {
                    // 直接使用本地加载函数，避免main.js中的路径处理问题
                    console.log('site/pages/viewer.html: 使用本地loadMarkdownDirectly函数');
                    loadMarkdownDirectly(markdownFile);
                }, 200);
            });

	            // 初始化下拉菜单
	            initializeDropdownMenu();

			            // 初始化手机端导航
			            initializeMobileNavigation();
			        });

	        async function initializeMarkedRender() {
	            console.log('初始化MD渲染器...');

	            const escapeHtml = function (text) {
	                return String(text)
	                    .replace(/&/g, '&amp;')
	                    .replace(/</g, '&lt;')
	                    .replace(/>/g, '&gt;')
	                    .replace(/"/g, '&quot;')
	                    .replace(/'/g, '&#39;');
	            };

	            const normalizeMarkedArgs = function (href, title, text) {
	                if (href && typeof href === 'object') {
	                    return {
	                        href: href.href,
	                        title: href.title,
	                        text: href.text || href.raw || ''
	                    };
	                }
	                return { href, title, text };
	            };

	            const isSafeUrl = function (href) {
	                if (!href) return true;
	                const trimmed = String(href).trim().toLowerCase();
	                return !(
	                    trimmed.startsWith('javascript:') ||
	                    trimmed.startsWith('data:') ||
	                    trimmed.startsWith('vbscript:')
	                );
	            };

	            try {
	                const renderer = (marked.Renderer && typeof marked.Renderer === 'function')
	                    ? new marked.Renderer()
	                    : null;

		                if (renderer) {
	                    // 禁止在 Markdown 中渲染原始 HTML（防止 XSS）
	                    renderer.html = (html) => escapeHtml(html);

	                    // 过滤危险链接协议
	                    renderer.link = (href, title, text) => {
	                        const normalized = normalizeMarkedArgs(href, title, text);
	                        if (!isSafeUrl(normalized.href)) return escapeHtml(normalized.text || '');

	                        const rawHref = String(normalized.href || '');
	                        const safeText = normalized.text || '';
	                        const safeTitle = normalized.title ? ` title="${escapeHtml(normalized.title)}"` : '';

	                        if (rawHref.startsWith('#')) {
	                            return `<a href="${escapeHtml(rawHref)}"${safeTitle}>${safeText}</a>`;
	                        }

	                        const hashIndex = rawHref.indexOf('#');
	                        const hash = hashIndex >= 0 ? rawHref.slice(hashIndex) : '';
	                        const baseHref = hashIndex >= 0 ? rawHref.slice(0, hashIndex) : rawHref;

	                        if (!baseHref) return escapeHtml(safeText);

	                        if (
	                            baseHref.includes('.html') ||
	                            baseHref.startsWith('?') ||
	                            baseHref.includes('viewer.html') ||
	                            baseHref.includes('folder.html') ||
	                            /^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(baseHref)
	                        ) {
	                            return `<a href="${escapeHtml(rawHref)}"${safeTitle}>${safeText}</a>`;
	                        }

	                        const resolvedDoc = resolveDocLinkPath(baseHref, CURRENT_DOC_PATH);
	                        if (resolvedDoc) {
	                            const finalHref = `viewer.html?file=${encodeURIComponent(resolvedDoc)}${hash}`;
	                            return `<a href="${escapeHtml(finalHref)}"${safeTitle}>${safeText}</a>`;
	                        }

	                        const resolvedRelative = resolveRelativeHref(baseHref, CURRENT_DOC_PATH);
	                        const finalHref = `viewer.html?file=${encodeURIComponent(resolvedRelative)}${hash}`;
	                        return `<a href="${escapeHtml(finalHref)}"${safeTitle}>${safeText}</a>`;
	                    };

		                    renderer.image = (href, title, text) => {
	                        const normalized = normalizeMarkedArgs(href, title, text);
	                        if (!isSafeUrl(normalized.href)) return '';
	                        const resolvedSrc = resolveRelativeHref(normalized.href, CURRENT_DOC_PATH);
	                        const rawHrefNoQuery = String(normalized.href || '').split('#')[0].split('?')[0];
	                        const resolvedSrcNoQuery = String(resolvedSrc || '').split('#')[0].split('?')[0];
	                        const isVideo = /\.(mp4|webm)$/i.test(rawHrefNoQuery) || /\.(mp4|webm)$/i.test(resolvedSrcNoQuery);
	                        if (isVideo) {
	                            const previewMediaDataUrl = resolveStudioPreviewMediaDataUrl(resolvedSrc);
	                            const safeVideoSrc = escapeHtml(previewMediaDataUrl || resolvedSrc);
	                            const safeTitle = normalized.title ? ` title="${escapeHtml(normalized.title)}"` : '';
	                            const mimeType = /\.webm$/i.test(rawHrefNoQuery) || /\.webm$/i.test(resolvedSrcNoQuery) ? 'video/webm' : 'video/mp4';
	                            return `<video controls preload="metadata" playsinline${safeTitle}><source src="${safeVideoSrc}" type="${mimeType}" />您的浏览器不支持视频播放。</video>`;
	                        }
	                        const previewDataUrl = resolveStudioPreviewImageDataUrl(resolvedSrc);
	                        const safeSrc = escapeHtml(previewDataUrl || resolvedSrc);
	                        const safeAlt = escapeHtml(normalized.text || '');
	                        const safeTitle = normalized.title ? ` title="${escapeHtml(normalized.title)}"` : '';
	                        return `<img src="${safeSrc}" alt="${safeAlt}"${safeTitle} loading="lazy" decoding="async" />`;
		                    };

		                    renderer.code = (code, lang) => {
		                        // marked 版本差异兼容：有的版本传入 (code, lang)，有的版本传入 token 对象
		                        if (code && typeof code === 'object') {
		                            lang = code.lang;
		                            code = code.text || code.raw || '';
		                        }

		                        let language = String(lang || '').trim().toLowerCase();
		                        if (language === 'c#' || language === 'cs' || language === 'dotnet') {
		                            language = 'csharp';
		                        }
		                        const safeCode = escapeHtml(code || '');

                        if (language === 'animcs') {
                            const raw = String(code || '').split('\n').map(line => String(line || '').trim()).find(line => line) || '';
                            let src = raw;
                            try { src = decodeURIComponent(raw); } catch (_) { src = raw; }
                            src = String(src).trim().replace(/^\.?\//, '').replace(/^docs\//, '');
                            const normalized = normalizePath(src);

                            if (!normalized.startsWith('anims/') || !/\.cs$/i.test(normalized)) {
                                return `<pre><code class="language-plaintext">${escapeHtml('animcs 代码块第一行必须是 anims/*.cs 路径')}</code></pre>`;
                            }

                            return `<div class="animts-embed animcs-embed" data-animcs-src="${escapeHtml(normalized)}"></div>`;
                        }

		                        if (language === 'mermaid') {
		                            return `<div class="flowchart mermaid">${safeCode}</div>`;
		                        }

		                        if (language) {
		                            return `<pre><code class="language-${escapeHtml(language)}">${safeCode}</code></pre>`;
		                        }
		                        return `<pre><code>${safeCode}</code></pre>`;
		                    };
		                }

	                // 配置 marked.js 选项（GitHub Pages 纯静态环境）
	                marked.setOptions({
	                    renderer: renderer || undefined,
	                    highlight: function (code, lang) {
	                        let language = String(lang || '').trim().toLowerCase();
	                        if (language === 'c#' || language === 'cs' || language === 'dotnet') {
	                            language = 'csharp';
	                        }
	                        if (typeof Prism !== 'undefined' && language && Prism.languages[language]) {
	                            return Prism.highlight(code, Prism.languages[language], language);
	                        }
	                        return code;
	                    },
	                    breaks: true,
	                    gfm: true,
	                    tables: true,
	                    smartLists: true,
	                    smartypants: true,
	                    mangle: true,
	                    headerIds: true,
	                    xhtml: false,
	                    pedantic: false
	                });
	                console.log('MD渲染器初始化完毕!');
	            } catch (error) {
	                console.error('初始化MD渲染器失败:', error);
	            }
	        }

        // 初始化文档配置
        async function initializeDocumentConfig() {
            try {
                console.log('viewer.html: 正在加载配置文件，当前路径:', window.location.pathname);
                if (window.SiteConfig && typeof window.SiteConfig.load === 'function') {
                    VIEWER_DOC_CONFIG = await window.SiteConfig.load();
                } else {
                    const configResponse = await fetch('/site/content/config.json', { cache: 'no-store' });
                    if (!configResponse.ok) throw new Error('无法加载config.json: ' + configResponse.status);
                    VIEWER_DOC_CONFIG = await configResponse.json();
                }
                console.log('成功加载配置文件:', VIEWER_DOC_CONFIG);
                    
                    // 从配置文件中提取分类、主题和路径映射
                    const categories = VIEWER_DOC_CONFIG.categories || {};
                    MAIN_CATEGORIES = {};
                    
                    // 转换分类格式以匹配viewer.html的期望
                    Object.keys(categories).forEach(categoryKey => {
                        const category = categories[categoryKey];
                        const isSpecial = ["怎么贡献", "Modder入门"].includes(categoryKey);
                        
                        MAIN_CATEGORIES[categoryKey] = {
                            title: category.title,
                            description: category.description,
                            icon: getCategoryIcon(categoryKey),
                            color: getCategoryColor(categoryKey),
                            order: getCategoryOrder(categoryKey),
                            special: isSpecial
                        };
                    });
                    
                    TOPIC_AREAS = VIEWER_DOC_CONFIG.topics || {};
                    VIEWER_PATH_REDIRECTS =
                        VIEWER_DOC_CONFIG.pathMappings ||
                        (VIEWER_DOC_CONFIG.settings && VIEWER_DOC_CONFIG.settings.pathMappings) ||
                        window.PATH_REDIRECTS ||
                        {};
                    
                    console.log('加载的分类:', MAIN_CATEGORIES);
                    console.log('加载的主题:', TOPIC_AREAS);
                    console.log('加载的路径映射:', VIEWER_PATH_REDIRECTS);
            } catch (error) {
                console.warn('加载配置文件失败，使用默认配置:', error);
                VIEWER_DOC_CONFIG = generateDefaultConfig();
                // 使用默认配置初始化分类、主题和路径映射
                MAIN_CATEGORIES = getDefaultCategories();
                TOPIC_AREAS = getDefaultTopics();
                VIEWER_PATH_REDIRECTS = window.PATH_REDIRECTS || {};
            }

            // 扫描所有文档文件
            await scanAllDocuments();
        }

        // 获取分类图标 - 优先从配置文件读取，否则使用默认值
        function getCategoryIcon(categoryKey) {
            // 首先尝试从配置文件中获取图标
            if (VIEWER_DOC_CONFIG && VIEWER_DOC_CONFIG.categories && VIEWER_DOC_CONFIG.categories[categoryKey] && VIEWER_DOC_CONFIG.categories[categoryKey].icon) {
                return VIEWER_DOC_CONFIG.categories[categoryKey].icon;
            }
            
            // 默认图标映射
            const iconMap = {
                '入门': '🚀',
                '进阶': '📚',
                '高级': '🔥',
                '个人分享': '💡',
                '怎么贡献': '🤝',
                'Modder入门': '🎮'
            };
            return iconMap[categoryKey] || '📄';
        }

        // 获取分类颜色 - 优先从配置文件读取，否则使用默认值
        function getCategoryColor(categoryKey) {
            // 首先尝试从配置文件中获取颜色
            if (VIEWER_DOC_CONFIG && VIEWER_DOC_CONFIG.categories && VIEWER_DOC_CONFIG.categories[categoryKey] && VIEWER_DOC_CONFIG.categories[categoryKey].color) {
                return VIEWER_DOC_CONFIG.categories[categoryKey].color;
            }
            
            // 默认颜色映射
            const colorMap = {
                '入门': '#4CAF50',
                '进阶': '#2196F3',
                '高级': '#FF5722',
                '个人分享': '#FFC107',
                '怎么贡献': '#9C27B0',
                'Modder入门': '#00BCD4'
            };
            return colorMap[categoryKey] || '#28a745';
        }

        // 获取分类排序 - 优先从配置文件读取，否则使用默认值
        function getCategoryOrder(categoryKey) {
            // 首先尝试从配置文件中获取排序
            if (VIEWER_DOC_CONFIG && VIEWER_DOC_CONFIG.categories && VIEWER_DOC_CONFIG.categories[categoryKey] && VIEWER_DOC_CONFIG.categories[categoryKey].order !== undefined) {
                return VIEWER_DOC_CONFIG.categories[categoryKey].order;
            }
            
            // 默认排序映射
            const orderMap = {
                '入门': 1,
                '进阶': 2,
                '高级': 3,
                '个人分享': 4,
                '怎么贡献': 5,
                'Modder入门': 6
            };
            return orderMap[categoryKey] || 999;
        }

        // 获取默认分类配置
        function getDefaultCategories() {
            return {
                "入门": {
                    "title": "入门",
                    "description": "适合初学者的基础教程",
                    "icon": "🚀",
                    "color": "#4CAF50",
                    "order": 1
                },
                "进阶": {
                    "title": "进阶",
                    "description": "有一定基础后的进阶教程",
                    "icon": "📚",
                    "color": "#2196F3",
                    "order": 2
                },
                "高级": {
                    "title": "高级",
                    "description": "面向有经验开发者的高级教程",
                    "icon": "🔥",
                    "color": "#FF5722",
                    "order": 3
                },
                "个人分享": {
                    "title": "个人分享",
                    "description": "社区成员的个人经验和技巧分享",
                    "icon": "💡",
                    "color": "#FFC107",
                    "order": 4
                },
                "怎么贡献": {
                    "title": "怎么贡献",
                    "description": "介绍贡献者应该怎么贡献文章",
                    "icon": "🤝",
                    "color": "#9C27B0",
                    "order": 5,
                    "special": true
                },
                "Modder入门": {
                    "title": "Modder入门",
                    "description": "Modder入门相关的教程",
                    "icon": "🎮",
                    "color": "#00BCD4",
                    "order": 6,
                    "special": true
                }
            };
        }

        // 获取默认主题配置
        function getDefaultTopics() {
            return {
                "mod-basics": {
                    "title": "Mod基础",
                    "description": "Mod开发的基础概念和核心API",
                    "icon": "📖",
                    "order": 1
                },
                "env": {
                    "title": "环境配置",
                    "description": "开发环境搭建和配置",
                    "icon": "🛠️",
                    "order": 2
                },
                "items": {
                    "title": "物品系统",
                    "description": "物品、武器和装备的开发",
                    "icon": "⚔️",
                    "order": 3
                },
                "npcs": {
                    "title": "NPC系统",
                    "description": "NPC的创建和行为定制",
                    "icon": "👥",
                    "order": 4
                },
                "world-gen": {
                    "title": "世界生成",
                    "description": "世界生成和地形修改",
                    "icon": "🌍",
                    "order": 5
                },
                "ui": {
                    "title": "UI界面",
                    "description": "用户界面和交互设计",
                    "icon": "🎨",
                    "order": 6
                },
                "networking": {
                    "title": "网络功能",
                    "description": "多人游戏和网络通信",
                    "icon": "🌐",
                    "order": 7
                },
                "advanced": {
                    "title": "高级功能",
                    "description": "高级开发技巧和优化",
                    "icon": "🔧",
                    "order": 8
                }
            };
        }

        // 生成默认配置（当config.json不存在时）
        function generateDefaultConfig() {
            const config = {
                _metadata: {
                    version: "2.0.0",
                    schema: "tmodloader-docs-v2",
                    created: new Date().toISOString().split('T')[0],
                    lastUpdated: new Date().toISOString().split('T')[0],
                    description: "泰拉瑞亚Mod制作教程配置文件 - 默认配置"
                },
                globalSettings: {
                    language: "zh",
                    theme: "default",
                    siteName: "泰拉瑞亚Mod制作教程",
                    siteDescription: "全面的泰拉瑞亚Mod开发教程资源",
                    baseUrl: "",
                    enableSearch: true,
                    enableDarkMode: true,
                    defaultOrder: 999,
                    dateFormat: "YYYY-MM-DD"
                },
                categories: {},
                topics: {},
                authors: {},
                all_files: [],
                pathMappings: {},
                settings: {
                    defaultCategory: "入门",
                    defaultTopic: "mod-basics",
                    specialCategories: ["怎么贡献", "Modder入门"]
                }
            };

            // 初始化分类结构
            const defaultCategories = getDefaultCategories();
            Object.keys(defaultCategories).forEach(categoryKey => {
                config.categories[categoryKey] = {
                    ...defaultCategories[categoryKey],
                    topics: {
                        "mod-basics": {
                            title: "Mod基础",
                            description: "Mod开发的基础概念和核心API",
                            files: []
                        }
                    }
                };
            });

            // 初始化主题结构
            const defaultTopics = getDefaultTopics();
            Object.keys(defaultTopics).forEach(topicKey => {
                config.topics[topicKey] = defaultTopics[topicKey];
            });

            return config;
        }

        // 扫描所有文档文件
        async function scanAllDocuments() {
            console.log('=== scanAllDocuments() 诊断开始 ===');
            try {
                // 完全依赖配置文件，因为部署时会调用 generate-index.js 生成新的 config.json
                try {
                    const config = VIEWER_DOC_CONFIG || (window.SiteConfig ? await window.SiteConfig.load() : null);
                    if (config) {
                        console.log('成功加载配置文件:', config);

                        // 从配置文件中提取文档列表
                        ALL_DOCS = config.all_files || [];
                        console.log('从配置文件加载的文档数量:', ALL_DOCS.length);
                        console.log('从配置文件加载的文档:', ALL_DOCS);

	                        // 如果配置文件中有文档，直接使用
	                        if (ALL_DOCS.length > 0) {
	                            // 确保每个文档都有必要的属性
	                            ALL_DOCS = ALL_DOCS.map(doc => {
	                                return {
	                                    ...doc,
	                                    path: doc.path || doc.filename,
	                                    title: doc.title || doc.filename.replace('.md', ''),
	                                    author: doc.author || '未知',
	                                    category: doc.category || '入门',
	                                    topic: doc.topic || 'mod-basics',
	                                    order: parseInt(doc.order) || 999,
	                                    description: doc.description || '',
	                                    last_updated: doc.last_updated || '未知'
	                                };
	                            });

                            console.log('处理后的文档列表:', ALL_DOCS);
                            console.log('=== scanAllDocuments() 诊断结束 ===');
                            buildDocLookupMap();
                            return;
                        } else {
                            console.warn('配置文件中没有找到文档');
                        }
                    } else {
                        console.warn('无法获取配置文件，文档列表为空');
                    }
                } catch (configError) {
                    console.warn('加载配置文件失败:', configError);
                }

                // 如果配置文件加载失败或没有文档，尝试扫描常见的文档文件
                console.warn('配置文件不可用，尝试扫描常见文档文件');
		                const commonFiles = [
		                    'Modder入门/DPapyru-从这里开始.md',
		                    '怎么贡献/教学文章写作指南.md',
		                    '怎么贡献/TopicSystem使用指南.md',
		                    '螺线翻译tml教程/0-开始/0-Home 主页.md'
		                ];

                ALL_DOCS = [];

                for (const filename of commonFiles) {
                    try {
                        console.log(`尝试处理文档: ${filename}`);
                        // 获取文档内容和元数据
                        const docUrl = `./${filename}`;
                        const docResponse = await fetch(docUrl, { cache: 'no-store' });

                        if (docResponse.ok) {
                            const content = await docResponse.text();
                            const { metadata } = parseFrontMatter(content);

                            // 处理分类映射
                            let category = metadata.category || '入门';
                            if (category && MAIN_CATEGORIES[category] && MAIN_CATEGORIES[category].mapsTo) {
                                const oldCategory = category;
                                category = MAIN_CATEGORIES[category].mapsTo;
                                console.log(`文档 ${filename} 的分类从 ${oldCategory} 映射到 ${category}`);
                            }

	                            const docInfo = {
	                                filename: filename,
	                                title: metadata.title || filename.replace('.md', ''),
	                                author: metadata.author || '未知',
	                                category: category,
	                                topic: metadata.topic || 'mod-basics',
	                                order: parseOrder(metadata.order),
	                                description: metadata.description || ''
	                            };

                            ALL_DOCS.push(docInfo);
                            console.log('成功添加文档:', docInfo.title);
                        } else {
                            console.warn(`文档 ${filename} 请求失败: ${docResponse.status} ${docResponse.statusText}`);
                        }
                    } catch (error) {
                        console.warn(`无法处理文档 ${filename}:`, error);
                    }
                }

                // 按分类和排序
	                ALL_DOCS.sort((a, b) => {
	                    if (a.category !== b.category) {
	                        return (MAIN_CATEGORIES[a.category]?.order ?? 999) - (MAIN_CATEGORIES[b.category]?.order ?? 999);
	                    }
	                    return a.order - b.order;
	                });

                console.log('扫描到的文档数量:', ALL_DOCS.length);
                console.log('扫描到的文档:', ALL_DOCS);
                console.log('=== scanAllDocuments() 诊断结束 ===');
                buildDocLookupMap();

            } catch (error) {
                console.error('扫描文档失败:', error);
                console.log('=== scanAllDocuments() 因错误结束 ===');
                // 提供一些默认文档
		                ALL_DOCS = [
		                    {
		                        filename: 'Modder入门/DPapyru-从这里开始.md',
		                        path: 'Modder入门/DPapyru-从这里开始.md',
		                        title: '从这里开始：Modder 入门总览',
		                        author: 'DPapyru',
		                        category: 'Modder入门',
	                        topic: 'mod-basics',
	                        order: 1,
	                        description: '解释 Modder入门的阅读方式，并按 C#/tML 熟练度与偏好给出建议入口',
	                        last_updated: '未知'
	                    }
	                ];
                console.log('使用默认文档配置');
                buildDocLookupMap();
            }
        }

        function buildDocLookupMap() {
            const map = new Map();

            function addKey(key, value) {
                if (!key || !value) return;
                const strKey = String(key);
                map.set(strKey, value);
                const lower = strKey.toLowerCase();
                if (!map.has(lower)) map.set(lower, value);
            }

            function slugFromFilename(filename) {
                const base = String(filename || '').replace(/\.md$/i, '');
                if (!base) return '';
                const firstToken = base.split(' ')[0];
                return firstToken.replace(/^\d+-/, '');
            }

            (ALL_DOCS || []).forEach(doc => {
                const resolvedPath = doc && (doc.path || doc.filename);
                if (!resolvedPath) return;

                addKey(resolvedPath, resolvedPath);
                addKey(resolvedPath.replace(/\.md$/i, ''), resolvedPath);

                if (doc.filename) {
                    addKey(doc.filename, resolvedPath);
                    addKey(String(doc.filename).replace(/\.md$/i, ''), resolvedPath);

                    const slug = slugFromFilename(doc.filename);
                    addKey(slug, resolvedPath);
                    addKey(`${slug}.md`, resolvedPath);
                }

                if (doc.originalPath) {
                    addKey(doc.originalPath, resolvedPath);
                    addKey(String(doc.originalPath).replace(/\.md$/i, ''), resolvedPath);
                }
            });

            DOC_LOOKUP_MAP = map;
        }

        function normalizePath(inputPath) {
            const parts = String(inputPath || '').split('/');
            const stack = [];
            for (const part of parts) {
                if (!part || part === '.') continue;
                if (part === '..') {
                    if (stack.length) stack.pop();
                    continue;
                }
                stack.push(part);
            }
            return stack.join('/');
        }

        function resolveRelativeHref(rawHref, currentDocPath) {
            if (!currentDocPath) return rawHref;
            if (!rawHref) return rawHref;

            const hrefStr = String(rawHref);
            if (
                hrefStr.startsWith('#') ||
                hrefStr.startsWith('/') ||
                /^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(hrefStr)
            ) {
                return rawHref;
            }

            const hashIndex = hrefStr.indexOf('#');
            const baseHref = hashIndex >= 0 ? hrefStr.slice(0, hashIndex) : hrefStr;
            const hash = hashIndex >= 0 ? hrefStr.slice(hashIndex) : '';

            let decoded = baseHref;
            try {
                decoded = decodeURIComponent(baseHref);
            } catch {
                decoded = baseHref;
            }

            const baseDir = String(currentDocPath).split('/').slice(0, -1).join('/');
            if (!baseDir) return rawHref;

            const joined = normalizePath(`${baseDir}/${decoded.replace(/^\.?\//, '')}`);
            return `${joined}${hash}`;
        }

	        function resolveDocLinkPath(href, currentDocPath) {
	            if (!href) return null;

            const hrefStr = String(href);
            if (hrefStr.startsWith('/') || /^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(hrefStr)) return null;

            let decodedPath = hrefStr;
            try {
                decodedPath = decodeURIComponent(hrefStr);
            } catch {
                decodedPath = hrefStr;
            }

            decodedPath = decodedPath.replace(/^\.?\//, '').replace(/^docs\//, '');

            const candidates = [];
            if (decodedPath) {
                candidates.push(decodedPath);
                candidates.push(decodedPath.replace(/\.md$/i, ''));
                if (!decodedPath.endsWith('.md') && !decodedPath.includes('.')) {
                    candidates.push(`${decodedPath}.md`);
                }
            }

	            // 特例：Modder入门的“文章使用内容索引”希望在任意子目录都能用同一种短写法
	            // 例如在 `Modder入门/1-入门/...` 中写 `文章使用内容索引/...` 时，应解析为 `Modder入门/文章使用内容索引/...`
	            if (currentDocPath && decodedPath && decodedPath.startsWith('文章使用内容索引/')) {
	                const root = String(currentDocPath).split('/')[0];
	                if (root === 'Modder入门') {
	                    const anchored = normalizePath(`${root}/${decodedPath}`);
	                    candidates.unshift(anchored);
	                    candidates.unshift(anchored.replace(/\.md$/i, ''));
	                    if (!anchored.endsWith('.md') && !anchored.includes('.')) {
	                        candidates.unshift(`${anchored}.md`);
	                    }
	                }
	            }

            if (currentDocPath && decodedPath) {
                const baseDir = String(currentDocPath).split('/').slice(0, -1).join('/');
                if (baseDir) {
                    const joined = normalizePath(`${baseDir}/${decodedPath}`);
                    candidates.unshift(joined);
                    candidates.unshift(joined.replace(/\.md$/i, ''));
                    if (!joined.endsWith('.md') && !joined.includes('.')) {
                        candidates.unshift(`${joined}.md`);
                    }
                }
            }

            const lookup = DOC_LOOKUP_MAP;
            if (!lookup) return null;

            for (const c of candidates) {
                if (!c) continue;
                const hit = lookup.get(c) || lookup.get(String(c).toLowerCase());
                if (hit) return hit;
            }

	            return null;
	        }

	        const TRANSCLUSION_DIRECTIVE_RE = /^\s*\{\{([a-zA-Z]+)\s*:\s*([^}\n\r]+)\}\}\s*$/;
	        const TRANSCLUSION_MAX_DEPTH = 4;
	        const TRANSCLUSION_MAX_FILES = 30;
	        const TRANSCLUSION_CACHE = new Map();
	        const LEARNING_AUTHOR_MODE_KEY = 'learningAuthorMode';

	        // 作者模式已下线：清理旧偏好并强制关闭。
	        (function clearLearningAuthorModePreference() {
	            try {
	                window.localStorage.removeItem(LEARNING_AUTHOR_MODE_KEY);
	            } catch (e) {
	                // ignore localStorage failures
	            }
	        })();

	        function escapeHtmlAttribute(value) {
	            return String(value || '')
	                .replace(/&/g, '&amp;')
	                .replace(/</g, '&lt;')
	                .replace(/>/g, '&gt;')
	                .replace(/"/g, '&quot;')
	                .replace(/'/g, '&#39;');
	        }

	        function setCurrentLearningDiagnostics(diag) {
	            window.CURRENT_RENDER_DIAGNOSTICS = diag || null;
	        }

	        function getCurrentLearningDiagnostics() {
	            return window.CURRENT_RENDER_DIAGNOSTICS || null;
	        }

	        function isIndexedDocPath(docPath, currentDocPath) {
	            if (!docPath) return false;
	            const raw = String(docPath);
            const cleaned = raw
                .replace(/^\.?\//, '')
                .replace(/^site\/content\//, '')
                .replace(/^content\//, '');
	            const lookup = DOC_LOOKUP_MAP;

	            if (lookup) {
	                const candidates = [
	                    cleaned,
	                    cleaned.toLowerCase(),
	                    cleaned.replace(/\.md$/i, ''),
	                    cleaned.replace(/\.md$/i, '').toLowerCase()
	                ];
	                for (const c of candidates) {
	                    if (!c) continue;
	                    if (lookup.get(c)) return true;
	                }
	            }

	            if (ALL_DOCS && Array.isArray(ALL_DOCS) && ALL_DOCS.length) {
	                const hit = ALL_DOCS.find(d => {
	                    const p = d && (d.path || d.filename);
	                    return p === cleaned || d.filename === cleaned || d.path === cleaned || p === raw;
	                });
	                if (hit) return true;
	            }

	            if (currentDocPath) {
	                const resolved = resolveDocLinkPath(cleaned, currentDocPath);
	                if (resolved && resolved !== cleaned) return true;
	            }

	            return false;
	        }

        function clampLearningLevel(value) {
            const n = Number.parseInt(value, 10);
            if (!Number.isFinite(n)) return 0;
            return Math.max(0, Math.min(2, n));
        }

	        function getLearningConditionContext() {
	            try {
	                const raw = window.localStorage.getItem('learningProfile');
	                if (!raw) return { C: 0, T: 0 };
	                const parsed = JSON.parse(raw);
	                if (!parsed || typeof parsed !== 'object') return { C: 0, T: 0 };
	                return {
	                    C: clampLearningLevel(parsed.c),
	                    T: clampLearningLevel(parsed.t)
	                };
	            } catch (e) {
	                return { C: 0, T: 0 };
	            }
	        }

	        function getLearningRenderContext() {
	            const base = getLearningConditionContext();
	            const ctx = {
	                C: base.C,
	                T: base.T,
	                AUTHOR: 0
	            };

	            return {
	                ctx: ctx,
	                authorMode: false
	            };
	        }

                function initializeViewerFocusMode() {
                    const btn = document.getElementById('focus-mode-toggle');
                    if (!btn) return;
                    const key = 'viewer_focus_mode';

                    function apply(enabled) {
                        document.body.classList.toggle('focus-mode', !!enabled);
                        btn.setAttribute('aria-pressed', enabled ? 'true' : 'false');
                        btn.textContent = enabled ? '退出焦点' : '焦点模式';
                    }

                    try {
                        const stored = window.localStorage ? window.localStorage.getItem(key) : null;
                        apply(stored === '1');
                    } catch (e) {
                        apply(false);
                    }

                    btn.addEventListener('click', function () {
                        const enabled = !document.body.classList.contains('focus-mode');
                        apply(enabled);
                        try {
                            if (window.localStorage) window.localStorage.setItem(key, enabled ? '1' : '0');
                        } catch (e) {}
                    });
                }

	                function initializeSidebarQuickSearch() {
	                    const input = document.getElementById('sidebar-quick-search');
	                    const root = document.getElementById('category-sidebar');
	                    if (!input || !root) return;

	                    function normalize(s) {
	                        return String(s || '').trim().toLowerCase();
	                    }

	                    function setCollapsed(folderEl, collapsed) {
	                        if (!folderEl) return;
	                        folderEl.dataset.collapsed = collapsed ? '1' : '0';
	                        const toggleBtn = folderEl.querySelector(':scope > .learn-tree-row .learn-tree-toggle');
	                        if (toggleBtn) toggleBtn.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
	                    }

	                    function getCollapsedStateOrNull(type, key) {
	                        try {
	                            const storageKey = `docsViewerSidebar${type.charAt(0).toUpperCase() + type.slice(1)}${key.charAt(0).toUpperCase() + key.slice(1)}`;
	                            const state = localStorage.getItem(storageKey);
	                            if (state === null) return null;
	                            return state === 'true';
	                        } catch (error) {
	                            return null;
	                        }
	                    }

	                    function apply() {
	                        const q = normalize(input.value);
	                        const folderEls = Array.from(root.querySelectorAll('.learn-tree-folder'));
	                        const fileEls = Array.from(root.querySelectorAll('.learn-tree-file'));

	                        if (!q) {
	                            fileEls.forEach(function (li) { li.style.display = ''; });
	                            folderEls.forEach(function (folder) {
	                                folder.style.display = '';
	                                const key = folder.dataset.folderKey || '';
	                                const storedCollapsed = key ? getCollapsedStateOrNull('folder', key) : null;
	                                const defaultCollapsed = Number(folder.dataset.depth || 0) >= 1;
	                                const forceOpen = !!folder.querySelector('.learn-tree-link.active');
	                                setCollapsed(folder, (storedCollapsed === null ? defaultCollapsed : storedCollapsed) && !forceOpen);
	                            });
	                            return;
	                        }

		                        fileEls.forEach(function (li) {
		                            const link = li.querySelector('.learn-tree-link');
		                            const titleEl = li.querySelector('.learn-tree-link-label');
		                            const text = normalize(titleEl ? titleEl.textContent : (link ? link.textContent : ''));
		                            const hit = !!text && text.indexOf(q) !== -1;
		                            li.style.display = hit ? '' : 'none';
		                            li.dataset.match = hit ? '1' : '0';
		                        });

	                        // 由深到浅，确保父节点根据子节点显隐更新
	                        folderEls.sort(function (a, b) {
	                            return Number(b.dataset.depth || 0) - Number(a.dataset.depth || 0);
	                        });

	                        folderEls.forEach(function (folder) {
	                            const label = folder.querySelector(':scope > .learn-tree-row .learn-tree-label');
	                            const labelText = normalize(label ? label.textContent : '');
	                            const selfMatch = !!labelText && labelText.indexOf(q) !== -1;

	                            if (selfMatch) {
	                                folder.style.display = '';
	                                folder.querySelectorAll('.learn-tree-folder, .learn-tree-file').forEach(function (n) {
	                                    n.style.display = '';
	                                });
	                                setCollapsed(folder, false);
	                                return;
	                            }

	                            const directChildren = Array.from(folder.querySelectorAll(':scope > .learn-tree-children > li'));
	                            const hasVisibleChild = directChildren.some(function (li) { return li.style.display !== 'none'; });
	                            folder.style.display = hasVisibleChild ? '' : 'none';
	                            if (hasVisibleChild) setCollapsed(folder, false);
	                        });
	                    }

	                    input.addEventListener('input', apply);
	                    input.addEventListener('search', apply);
	                }

	        function updateLearningHintsVisibility() {
	            const container = document.getElementById('learning-hints');
	            if (!container) return;
	            const nodes = [
	                document.getElementById('learning-hint-recommendation'),
	                document.getElementById('learning-hint-prefs')
	            ].filter(Boolean);
	            const hasAny = nodes.some(function (n) { return n.innerHTML && String(n.innerHTML).trim(); });
	            container.style.display = hasAny ? 'block' : 'none';
	        }

	        function renderLearningRecommendationHint(metadata, model) {
	            const node = document.getElementById('learning-hint-recommendation');
	            if (!node) return;

	            const minC = (metadata && typeof metadata.min_c === 'number') ? metadata.min_c : null;
	            const minT = (metadata && typeof metadata.min_t === 'number') ? metadata.min_t : null;

	            if (minC == null && minT == null) {
	                node.innerHTML = '';
	                updateLearningHintsVisibility();
	                return;
	            }

	            const ctx = (model && model.ctx) ? model.ctx : getLearningConditionContext();
	            const parts = [];
	            if (minC != null) parts.push('C≥' + String(minC));
	            if (minT != null) parts.push('T≥' + String(minT));

	            const current = '当前：C' + Number(ctx.C || 0) + '/T' + Number(ctx.T || 0);
	            const below =
	                (minC != null && Number(ctx.C || 0) < Number(minC)) ||
	                (minT != null && Number(ctx.T || 0) < Number(minT));

	            node.innerHTML = [
	                '<div class="learning-hint-card learning-recommend-card' + (below ? ' low' : '') + '">',
	                '<div class="learning-hint-title">建议阅读门槛</div>',
	                '<div class="learning-hint-text">建议 ' + parts.join(' · ') + '。' + current + '（不影响阅读）</div>',
	                '</div>'
	            ].join('');

	            updateLearningHintsVisibility();
	        }

	        function rerenderCurrentDocPreserveScroll() {
	            const file = CURRENT_DOC_PATH || (new URL(window.location.href)).searchParams.get('file');
	            if (!file || typeof loadMarkdownDirectly !== 'function') return;
	            const y = window.scrollY || 0;
	            loadMarkdownDirectly(file);
	            const restore = function () {
	                window.scrollTo(0, y);
	                document.removeEventListener('viewer:content-ready', restore);
	            };
	            document.addEventListener('viewer:content-ready', restore);
	        }

	        function isUnsafeTransclusionTarget(target) {
		            const value = String(target || '');
		            return (
		                !value ||
		                value.includes('\0') ||
		                value.includes('\\') ||
		                value.startsWith('/') ||
		                /^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(value)
		            );
		        }

	        function splitHash(href) {
	            const raw = String(href || '');
	            const hashIndex = raw.indexOf('#');
	            if (hashIndex < 0) return { base: raw, hash: '' };
	            return { base: raw.slice(0, hashIndex), hash: raw.slice(hashIndex) };
	        }

	        function parseTransclusionDirective(line) {
	            const match = String(line || '').match(TRANSCLUSION_DIRECTIVE_RE);
	            if (!match) return null;

	            const kind = String(match[1] || '').trim().toLowerCase();
	            const rawPayload = String(match[2] || '').trim();
	            if (!rawPayload) return null;

	            if (kind === 'anim') {
	                return { kind, target: rawPayload, title: '' };
	            }

            if (kind !== 'cs') return null;

	            const pipeIndex = rawPayload.indexOf('|');
	            if (pipeIndex < 0) {
	                return { kind, target: rawPayload, title: '' };
	            }

	            const target = rawPayload.slice(0, pipeIndex).trim();
	            const title = rawPayload.slice(pipeIndex + 1).trim();
	            if (!target) return null;
	            return { kind, target, title };
	        }

	        function extractMarkdownSectionByHeading(markdown, selector) {
	            const selRaw = String(selector || '').trim();
	            if (!selRaw) return null;
	            const sel = String(selRaw)
	                .replace(/!\[([^\]]*)\]\([^)]+\)/g, '$1')
	                .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
	                .replace(/[`*_~]/g, '')
	                .replace(/\s+/g, ' ')
	                .trim()
	                .toLowerCase();
	            if (!sel) return null;

	            const lines = String(markdown || '').split(/\r?\n/);
	            let inFence = false;
	            let fenceChar = '';

	            let startIndex = -1;
	            let startLevel = 0;

	            for (let i = 0; i < lines.length; i++) {
	                const line = lines[i];
	                const fenceMatch = line.match(/^\s*(```+|~~~+)\s*/);
	                if (fenceMatch) {
	                    const currentFence = fenceMatch[1][0];
	                    if (!inFence) {
	                        inFence = true;
	                        fenceChar = currentFence;
	                    } else if (fenceChar === currentFence) {
	                        inFence = false;
	                        fenceChar = '';
	                    }
	                    continue;
	                }
	                if (inFence) continue;

	                const headingMatch = line.match(/^(#{1,6})\s+(.*)$/);
	                if (!headingMatch) continue;

	                const level = headingMatch[1].length;
	                const rawText = String(headingMatch[2] || '').trim().replace(/\s+#*$/, '').trim();
	                const normalized = String(rawText)
	                    .replace(/!\[([^\]]*)\]\([^)]+\)/g, '$1')
	                    .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
	                    .replace(/[`*_~]/g, '')
	                    .replace(/\s+/g, ' ')
	                    .trim()
	                    .toLowerCase();
	                if (!normalized) continue;

	                if (startIndex < 0) {
	                    if (normalized === sel) {
	                        startIndex = i + 1; // exclude the heading line itself
	                        startLevel = level;
	                    }
	                    continue;
	                }

	                if (level <= startLevel) {
	                    const chunk = lines.slice(startIndex, i).join('\n');
	                    return chunk.replace(/^\s*\n+/, '').replace(/\n+\s*$/, '');
	                }
	            }

	            if (startIndex >= 0) {
	                const chunk = lines.slice(startIndex).join('\n');
	                return chunk.replace(/^\s*\n+/, '').replace(/\n+\s*$/, '');
	            }

	            return null;
	        }

	        function stripLeadingTitleHeading(markdown, titles) {
	            const titleSet = new Set(
	                (titles || [])
	                    .map(t => String(t || '').trim())
	                    .filter(Boolean)
	                    .map(t => t.toLowerCase())
	            );
	            if (!titleSet.size) return markdown;

	            const lines = String(markdown || '').split(/\r?\n/);
	            let i = 0;
	            while (i < lines.length && !lines[i].trim()) i++;
	            if (i >= lines.length) return markdown;

	            const m = lines[i].match(/^#\s+(.*)$/);
	            if (!m) return markdown;

	            const headingText = String(m[1] || '').trim().toLowerCase();
	            if (!titleSet.has(headingText)) return markdown;

	            lines.splice(i, 1);
	            while (i < lines.length && !lines[i].trim()) lines.splice(i, 1);
	            return lines.join('\n');
	        }

	        function shiftMarkdownHeadings(markdown, shift) {
	            const delta = Number.isFinite(shift) ? shift : 0;
	            if (delta <= 0) return markdown;

	            const lines = String(markdown || '').split(/\r?\n/);
	            let inFence = false;
	            let fenceChar = '';

	            for (let i = 0; i < lines.length; i++) {
	                const line = lines[i];
	                const fenceMatch = line.match(/^\s*(```+|~~~+)\s*/);
	                if (fenceMatch) {
	                    const currentFence = fenceMatch[1][0];
	                    if (!inFence) {
	                        inFence = true;
	                        fenceChar = currentFence;
	                    } else if (fenceChar === currentFence) {
	                        inFence = false;
	                        fenceChar = '';
	                    }
	                    continue;
	                }

	                if (inFence) continue;
	                const headingMatch = line.match(/^(#{1,6})(\s+.*)$/);
	                if (!headingMatch) continue;

	                const current = headingMatch[1].length;
	                const next = Math.min(6, current + delta);
	                lines[i] = `${'#'.repeat(next)}${headingMatch[2]}`;
	            }

	            return lines.join('\n');
	        }

	        function getMarkdownMinHeadingLevel(markdown) {
	            const lines = String(markdown || '').split(/\r?\n/);
	            let inFence = false;
	            let fenceChar = '';
	            let minLevel = 0;

	            for (let i = 0; i < lines.length; i++) {
	                const line = lines[i];
	                const fenceMatch = line.match(/^\s*(```+|~~~+)\s*/);
	                if (fenceMatch) {
	                    const currentFence = fenceMatch[1][0];
	                    if (!inFence) {
	                        inFence = true;
	                        fenceChar = currentFence;
	                    } else if (fenceChar === currentFence) {
	                        inFence = false;
	                        fenceChar = '';
	                    }
	                    continue;
	                }
	                if (inFence) continue;

	                const headingMatch = line.match(/^(#{1,6})\s+.*$/);
	                if (!headingMatch) continue;
	                const level = headingMatch[1].length;
	                if (!minLevel || level < minLevel) minLevel = level;
	                if (minLevel === 1) return 1;
	            }

	            return minLevel;
	        }

	        function demoteMarkdownHeadingsToBold(markdown) {
	            const lines = String(markdown || '').split(/\r?\n/);
	            let inFence = false;
	            let fenceChar = '';

	            for (let i = 0; i < lines.length; i++) {
	                const line = lines[i];
	                const fenceMatch = line.match(/^\s*(```+|~~~+)\s*/);
	                if (fenceMatch) {
	                    const currentFence = fenceMatch[1][0];
	                    if (!inFence) {
	                        inFence = true;
	                        fenceChar = currentFence;
	                    } else if (fenceChar === currentFence) {
	                        inFence = false;
	                        fenceChar = '';
	                    }
	                    continue;
	                }
	                if (inFence) continue;

	                const headingMatch = line.match(/^(#{1,6})\s+(.*)$/);
	                if (!headingMatch) continue;
	                const text = String(headingMatch[2] || '').trim().replace(/\s+#*$/, '').trim();
	                if (!text) continue;
	                lines[i] = `**${text}**`;
	            }

	            return lines.join('\n');
	        }

	        function rewriteTranscludedLinksAndImages(markdown, includeDocPath) {
	            const lines = String(markdown || '').split(/\r?\n/);
	            let inFence = false;
	            let fenceChar = '';

	            function resolveImageAbsolute(src) {
	                if (!src) return src;
	                const raw = String(src);
	                if (
	                    raw.startsWith('#') ||
	                    raw.startsWith('/') ||
	                    /^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(raw)
	                ) return raw;

	                const resolved = resolveRelativeHref(raw, includeDocPath);
	                if (!resolved) return raw;

                const cleaned = String(resolved).replace(/^\.?\//, '');
                if (cleaned.startsWith('assets/')) return `/site/${cleaned}`;
                return `/site/content/${cleaned}`;
            }

	            function rewriteInlineLink(line) {
	                // 图片：![alt](src "title")
	                line = line.replace(/!\[([^\]]*)\]\(([^)\s]+)(\s+\"[^\"]*\")?\)/g, (m, alt, href, title) => {
	                    const fixed = resolveImageAbsolute(href);
	                    return `![${alt}](${fixed}${title || ''})`;
	                });

	                // 链接：[text](href "title")
	                line = line.replace(/(^|[^!])\[([^\]]+)\]\(([^)\s]+)(\s+\"[^\"]*\")?\)/g, (m, prefix, text, href, title) => {
	                    const hrefStr = String(href || '');
	                    const { base, hash } = splitHash(hrefStr);
	                    const resolved = resolveDocLinkPath(base, includeDocPath);
	                    if (!resolved) return m;
	                    return `${prefix}[${text}](${resolved}${hash}${title || ''})`;
	                });

	                return line;
	            }

	            for (let i = 0; i < lines.length; i++) {
	                const line = lines[i];
	                const fenceMatch = line.match(/^\s*(```+|~~~+)\s*/);
	                if (fenceMatch) {
	                    const currentFence = fenceMatch[1][0];
	                    if (!inFence) {
	                        inFence = true;
	                        fenceChar = currentFence;
	                    } else if (fenceChar === currentFence) {
	                        inFence = false;
	                        fenceChar = '';
	                    }
	                    continue;
	                }

	                if (inFence) continue;
	                lines[i] = rewriteInlineLink(line);
	            }

	            return lines.join('\n');
	        }

	        async function fetchMarkdownDocText(docPath) {
	            const key = String(docPath || '');
	            if (!key) throw new Error('空的文档路径');

            if (!TRANSCLUSION_CACHE.has(key)) {
                const fetchUrl = `/site/content/${key.replace(/^\.?\//, '').replace(/^site\/content\//, '').replace(/^content\//, '')}`;
	                const p = fetch(encodeURI(fetchUrl), { cache: 'no-store' }).then(async response => {
	                    if (!response.ok) {
	                        throw new Error(`HTTP ${response.status} ${response.statusText}`);
	                    }
	                    return await response.text();
	                });
	                TRANSCLUSION_CACHE.set(key, p);
	            }
	        	    return await TRANSCLUSION_CACHE.get(key);
	        }

	        function buildFencedCodeBlock(language, code) {
	            const text = String(code || '');
	            const lang = String(language || '').trim();
	            const matches = text.match(/`+/g) || [];
	            let longest = 0;
	            matches.forEach(m => { if (m.length > longest) longest = m.length; });
	            const fenceLen = Math.max(3, longest + 1);
	            const fence = '`'.repeat(fenceLen);
	            return `${fence}${lang ? lang : ''}\n${text.replace(/\r\n?/g, '\n')}\n${fence}`;
	        }

	        function dedentCodeBlockText(code) {
	            const raw = String(code || '').replace(/\r\n?/g, '\n');
	            const lines = raw.split('\n');
	
	            function countIndentCols(line) {
	                let cols = 0;
	                for (let i = 0; i < line.length; i++) {
	                    const ch = line[i];
	                    if (ch === ' ') cols += 1;
	                    else if (ch === '\t') cols += 4;
	                    else break;
	                }
	                return cols;
	            }

	            function removeIndentCols(line, colsToRemove) {
	                let cols = colsToRemove;
	                let i = 0;
	                while (i < line.length && cols > 0) {
	                    const ch = line[i];
	                    if (ch === ' ') {
	                        cols -= 1;
	                        i += 1;
	                        continue;
	                    }
	                    if (ch === '\t') {
	                        cols -= 4;
	                        i += 1;
	                        continue;
	                    }
	                    break;
	                }
	                return line.slice(i);
	            }

	            let minIndent = Infinity;
	            for (let i = 0; i < lines.length; i++) {
	                const line = lines[i];
	                if (!line || !line.trim()) continue;
	                const indent = countIndentCols(line);
	                if (indent < minIndent) minIndent = indent;
	            }
	
	            if (!Number.isFinite(minIndent) || minIndent <= 0) return raw;
	            for (let i = 0; i < lines.length; i++) {
	                if (!lines[i] || !lines[i].trim()) continue;
	                lines[i] = removeIndentCols(lines[i], minIndent);
	            }
	            return lines.join('\n');
	        }

	        function parseCSharpSnippetSelector(hashText) {
	            const raw = String(hashText || '').trim();
	            if (!raw || raw === '#') return null;
	            const text = raw.startsWith('#') ? raw.slice(1) : raw;
	            if (!text.startsWith('cs:')) return null;
	            const rest = text.slice(3);
	            const firstColon = rest.indexOf(':');
	            if (firstColon < 0) return null;
	            const kind = rest.slice(0, firstColon).trim();
	            const selector = rest.slice(firstColon + 1).trim();
	            if (!kind || !selector) return null;
	            if (!/^[mtpfce]$/.test(kind)) return null;
	            return { kind, selector };
	        }

	        function getCSharpFullTypeNameFromSelector(kind, selector) {
	            const k = String(kind || '').trim();
	            const s = String(selector || '').trim();
	            if (!k || !s) return '';
	            if (k === 't') return s;
	            if (k === 'm') {
	                const parenIndex = s.indexOf('(');
	                if (parenIndex < 0) return '';
	                const head = s.slice(0, parenIndex).trim();
	                const dotIndex = head.lastIndexOf('.');
	                if (dotIndex < 0) return '';
	                return head.slice(0, dotIndex).trim();
	            }
	            const dotIndex = s.lastIndexOf('.');
	            if (dotIndex < 0) return '';
	            return s.slice(0, dotIndex).trim();
	        }

	        function normalizeSignatureTypesText(text) {
	            return String(text || '').replace(/\s+/g, '');
	        }

	        function splitCSharpCommaList(text) {
	            const s = String(text || '');
	            const parts = [];
	            let buf = '';
	            let angle = 0;
	            let bracket = 0;
	            let paren = 0;
	            for (let i = 0; i < s.length; i++) {
	                const ch = s[i];
	                if (ch === '<') angle += 1;
	                else if (ch === '>') angle = Math.max(0, angle - 1);
	                else if (ch === '[') bracket += 1;
	                else if (ch === ']') bracket = Math.max(0, bracket - 1);
	                else if (ch === '(') paren += 1;
	                else if (ch === ')') paren = Math.max(0, paren - 1);
	
	                if (ch === ',' && angle === 0 && bracket === 0 && paren === 0) {
	                    parts.push(buf);
	                    buf = '';
	                    continue;
	                }
	                buf += ch;
	            }
	            parts.push(buf);
	            return parts;
	        }

	        function stripCSharpAttributes(text) {
	            const s = String(text || '');
	            let out = '';
	            let depth = 0;
	            for (let i = 0; i < s.length; i++) {
	                const ch = s[i];
	                if (ch === '[') {
	                    depth += 1;
	                } else if (ch === ']') {
	                    depth = Math.max(0, depth - 1);
	                } else if (depth === 0) {
	                    out += ch;
	                }
	            }
	            return out;
	        }

	        function normalizeCSharpParamTypeForSig(paramText) {
	            let s = String(paramText || '');
	            s = stripCSharpAttributes(s);
	
	            // drop default value
	            const eqIndex = s.indexOf('=');
	            if (eqIndex >= 0) s = s.slice(0, eqIndex);
	
	            s = s.trim();
	            if (!s) return '';

	            // drop common modifiers
	            s = s.replace(/^\s*(this|ref|out|in|params|scoped)\b\s*/g, '');
	            s = s.trim();
	            if (!s) return '';

	            // remove trailing parameter name (keep type only)
	            // heuristic: if there's whitespace, last token is parameter name
	            const m = s.match(/^(.*\S)\s+([$_\p{L}][$_\p{L}\p{N}]*)\s*$/u);
	            if (m) s = m[1];

	            return normalizeSignatureTypesText(s);
	        }

	        function normalizeCSharpSignatureTypes(sigText) {
	            const raw = String(sigText || '').trim();
	            if (!raw) return [];
	            return splitCSharpCommaList(raw)
	                .map(p => normalizeCSharpParamTypeForSig(p))
	                .filter(Boolean);
	        }

	        function buildCSharpCodeMask(sourceText) {
	            const src = String(sourceText || '');
	            const out = src.split('');
	            let i = 0;
	            let state = 'code';
	            while (i < src.length) {
	                const ch = src[i];
	                const next = i + 1 < src.length ? src[i + 1] : '';
	
	                if (state === 'code') {
	                    if (ch === '/' && next === '/') {
	                        out[i] = ' ';
	                        out[i + 1] = ' ';
	                        i += 2;
	                        state = 'line';
	                        continue;
	                    }
	                    if (ch === '/' && next === '*') {
	                        out[i] = ' ';
	                        out[i + 1] = ' ';
	                        i += 2;
	                        state = 'block';
	                        continue;
	                    }
	                    if (ch === '\'' ) {
	                        out[i] = ' ';
	                        i += 1;
	                        state = 'char';
	                        continue;
	                    }
	                    if (ch === '"') {
	                        out[i] = ' ';
	                        i += 1;
	                        state = 'string';
	                        continue;
	                    }
	                    if (ch === '@' && next === '"') {
	                        out[i] = ' ';
	                        out[i + 1] = ' ';
	                        i += 2;
	                        state = 'verbatim';
	                        continue;
	                    }
	                    if (ch === '$' && next === '"') {
	                        out[i] = ' ';
	                        out[i + 1] = ' ';
	                        i += 2;
	                        state = 'string';
	                        continue;
	                    }
	                    if (ch === '$' && next === '@' && (i + 2 < src.length) && src[i + 2] === '"') {
	                        out[i] = ' ';
	                        out[i + 1] = ' ';
	                        out[i + 2] = ' ';
	                        i += 3;
	                        state = 'verbatim';
	                        continue;
	                    }
	                    if (ch === '@' && next === '$' && (i + 2 < src.length) && src[i + 2] === '"') {
	                        out[i] = ' ';
	                        out[i + 1] = ' ';
	                        out[i + 2] = ' ';
	                        i += 3;
	                        state = 'verbatim';
	                        continue;
	                    }
	                    i += 1;
	                    continue;
	                }

	                if (state === 'line') {
	                    if (ch === '\n') {
	                        i += 1;
	                        state = 'code';
	                        continue;
	                    }
	                    out[i] = ' ';
	                    i += 1;
	                    continue;
	                }

	                if (state === 'block') {
	                    if (ch === '*' && next === '/') {
	                        out[i] = ' ';
	                        out[i + 1] = ' ';
	                        i += 2;
	                        state = 'code';
	                        continue;
	                    }
	                    out[i] = ' ';
	                    i += 1;
	                    continue;
	                }

	                if (state === 'string') {
	                    if (ch === '\\') {
	                        out[i] = ' ';
	                        if (i + 1 < src.length) out[i + 1] = ' ';
	                        i += 2;
	                        continue;
	                    }
	                    out[i] = ' ';
	                    if (ch === '"') {
	                        i += 1;
	                        state = 'code';
	                        continue;
	                    }
	                    i += 1;
	                    continue;
	                }

	                if (state === 'verbatim') {
	                    out[i] = ' ';
	                    if (ch === '"') {
	                        if (next === '"') {
	                            out[i + 1] = ' ';
	                            i += 2;
	                            continue;
	                        }
	                        i += 1;
	                        state = 'code';
	                        continue;
	                    }
	                    i += 1;
	                    continue;
	                }

	                if (state === 'char') {
	                    if (ch === '\\') {
	                        out[i] = ' ';
	                        if (i + 1 < src.length) out[i + 1] = ' ';
	                        i += 2;
	                        continue;
	                    }
	                    out[i] = ' ';
	                    if (ch === '\'') {
	                        i += 1;
	                        state = 'code';
	                        continue;
	                    }
	                    i += 1;
	                    continue;
	                }

	                i += 1;
	            }

	            return out.join('');
	        }

	        function findMatchingBraceInMask(mask, openIndex, endIndex) {
	            if (openIndex < 0) return -1;
	            const limit = Number.isFinite(endIndex) ? Math.min(endIndex, mask.length) : mask.length;
	            let depth = 0;
	            for (let i = openIndex; i < limit; i++) {
	                const ch = mask[i];
	                if (ch === '{') depth += 1;
	                else if (ch === '}') {
	                    depth -= 1;
	                    if (depth === 0) return i;
	                }
	            }
	            return -1;
	        }

	        function findMatchingParenInMask(mask, openIndex, endIndex) {
	            if (openIndex < 0) return -1;
	            const limit = Number.isFinite(endIndex) ? Math.min(endIndex, mask.length) : mask.length;
	            let depth = 0;
	            for (let i = openIndex; i < limit; i++) {
	                const ch = mask[i];
	                if (ch === '(') depth += 1;
	                else if (ch === ')') {
	                    depth -= 1;
	                    if (depth === 0) return i;
	                }
	            }
	            return -1;
	        }

	        function findLineStart(text, index) {
	            const i = Math.max(0, Math.min(text.length, index));
	            const p = text.lastIndexOf('\n', i);
	            return p < 0 ? 0 : p + 1;
	        }

	        function skipWs(mask, i, end) {
	            let p = i;
	            const limit = Number.isFinite(end) ? end : mask.length;
	            while (p < limit && /\s/.test(mask[p])) p += 1;
	            return p;
	        }

	        function readIdentifierAt(mask, i) {
	            if (i < 0 || i >= mask.length) return null;
	            const ch = mask[i];
	            if (!/[$_\p{L}]/u.test(ch)) return null;
	            let j = i + 1;
	            while (j < mask.length && /[$_\p{L}\p{N}]/u.test(mask[j])) j += 1;
	            return { text: mask.slice(i, j), end: j };
	        }

	        function findNamespaceRangesInMask(mask) {
	            const text = String(mask || '');
	            const ranges = [];
	            const nsRe = /\bnamespace\s+([$_\p{L}\p{N}.]+)\s*([;{])/gu;
	            let m = null;
	            while (true) {
	                m = nsRe.exec(text);
	                if (!m) break;
	                const name = String(m[1] || '').trim();
	                const terminator = String(m[2] || '');
	                if (!name) continue;
	                if (terminator === ';') {
	                    ranges.push({ name, start: 0, end: text.length });
	                    continue;
	                }
	                const braceIndex = text.indexOf('{', nsRe.lastIndex - 1);
	                if (braceIndex < 0) continue;
	                const closeBrace = findMatchingBraceInMask(text, braceIndex, text.length);
	                if (closeBrace < 0) continue;
	                ranges.push({ name, start: braceIndex + 1, end: closeBrace });
	            }
	            return ranges;
	        }

	        function findTypeRangeByFullName(sourceText, codeMask, fullTypeName) {
	            const source = String(sourceText || '');
	            const mask = String(codeMask || '');
	            const full = String(fullTypeName || '').trim();
	            if (!full) return null;

	            const nsRanges = findNamespaceRangesInMask(mask);
	            let typePath = [];
	            let searchStart = 0;
	            let searchEnd = mask.length;

	            if (nsRanges.length > 0) {
	                let matched = null;
	                for (let i = 0; i < nsRanges.length; i++) {
	                    const nsName = String(nsRanges[i].name || '').trim();
	                    if (!nsName) continue;
	                    if (full === nsName) continue;
	                    if (full.startsWith(nsName + '.')) {
	                        if (!matched || nsName.length > matched.name.length) matched = nsRanges[i];
	                    }
	                }
	                if (matched) {
	                    const rest = full.slice(matched.name.length + 1);
	                    typePath = rest.split('.').filter(Boolean);
	                    searchStart = matched.start;
	                    searchEnd = matched.end;
	                } else {
	                    // No namespace prefix match; treat as global namespace type name
	                    typePath = full.split('.').filter(Boolean);
	                }
	            } else {
	                typePath = full.split('.').filter(Boolean);
	            }

	            if (!typePath.length) return null;

	            function findTypeInRange(rangeStart, rangeEnd, typeName) {
	                const name = String(typeName || '').trim();
	                if (!name) return null;
	
	                const keywordRes = [
	                    'class',
	                    'struct',
	                    'interface',
	                    'enum',
	                    'record'
	                ];
	
	                let i = rangeStart;
	                while (i < rangeEnd) {
	                    const id = readIdentifierAt(mask, i);
	                    if (!id) {
	                        i += 1;
	                        continue;
	                    }
	                    const word = id.text;
	                    const isTypeKw = keywordRes.includes(word);
	                    if (!isTypeKw) {
	                        i = id.end;
	                        continue;
	                    }
	
	                    let p = skipWs(mask, id.end, rangeEnd);
	                    if (word === 'record') {
	                        const nextId = readIdentifierAt(mask, p);
	                        if (nextId && (nextId.text === 'class' || nextId.text === 'struct')) {
	                            p = skipWs(mask, nextId.end, rangeEnd);
	                        }
	                    }
	
	                    const nameId = readIdentifierAt(mask, p);
	                    if (!nameId) {
	                        i = id.end;
	                        continue;
	                    }
	                    if (nameId.text !== name) {
	                        i = id.end;
	                        continue;
	                    }

	                    let openBrace = mask.indexOf('{', nameId.end);
	                    if (openBrace < 0 || openBrace >= rangeEnd) {
	                        i = id.end;
	                        continue;
	                    }
	                    const closeBrace = findMatchingBraceInMask(mask, openBrace, rangeEnd);
	                    if (closeBrace < 0) {
	                        i = id.end;
	                        continue;
	                    }
	
	                    return {
	                        declStart: i,
	                        openBrace,
	                        closeBrace
	                    };
	                }
	
	                return null;
	            }

	            let current = { start: searchStart, end: searchEnd };
	            for (let idx = 0; idx < typePath.length; idx++) {
	                const seg = typePath[idx];
	                const found = findTypeInRange(current.start, current.end, seg);
	                if (!found) return null;
	                current = { start: found.openBrace + 1, end: found.closeBrace };
	                if (idx === typePath.length - 1) return found;
	            }
	
	            return null;
	        }

	        function extractMemberSnippet(sourceText, codeMask, fullTypeName, kind, selector) {
	            const source = String(sourceText || '');
	            const mask = String(codeMask || '');
	
	            const typeInfo = findTypeRangeByFullName(source, mask, fullTypeName);
	            if (!typeInfo) return { ok: false, message: '找不到类型：' + String(fullTypeName || '') };

	            const bodyStart = typeInfo.openBrace + 1;
	            const bodyEnd = typeInfo.closeBrace;
	
	            function scanAtTopLevel(findFn) {
	                let localDepth = 0;
	                for (let i = bodyStart; i < bodyEnd; i++) {
	                    const ch = mask[i];
	                    if (ch === '{') {
	                        localDepth += 1;
	                        continue;
	                    }
	                    if (ch === '}') {
	                        localDepth = Math.max(0, localDepth - 1);
	                        continue;
	                    }
	                    if (localDepth !== 0) continue;
	                    const res = findFn(i);
	                    if (res) return res;
	                }
	                return null;
	            }

	            function parseMethodSelector(text) {
	                const raw = String(text || '').trim();
	                const parenIndex = raw.indexOf('(');
	                const closeIndex = raw.lastIndexOf(')');
	                if (parenIndex < 0 || closeIndex < parenIndex) return null;
	                const head = raw.slice(0, parenIndex).trim();
	                const sig = raw.slice(parenIndex + 1, closeIndex);
	                const dotIndex = head.lastIndexOf('.');
	                if (dotIndex < 0) return null;
	                const typeName = head.slice(0, dotIndex).trim();
	                const methodName = head.slice(dotIndex + 1).trim();
	                if (!typeName || !methodName) return null;
	                return { typeName, methodName, sigTypes: normalizeCSharpSignatureTypes(sig) };
	            }

	            function parseMemberSelector(text) {
	                const raw = String(text || '').trim();
	                const dotIndex = raw.lastIndexOf('.');
	                if (dotIndex < 0) return null;
	                const typeName = raw.slice(0, dotIndex).trim();
	                const memberName = raw.slice(dotIndex + 1).trim();
	                if (!typeName || !memberName) return null;
	                return { typeName, memberName };
	            }

	            if (kind === 't') {
	                const declStart = findLineStart(source, typeInfo.declStart);
	                return { ok: true, snippet: source.slice(declStart, typeInfo.closeBrace + 1) };
	            }

	            if (kind === 'm') {
	                const parsed = parseMethodSelector(selector);
	                if (!parsed) return { ok: false, message: '方法选择器格式错误：' + String(selector || '') };
	                if (parsed.typeName !== fullTypeName) return { ok: false, message: '方法选择器类型不匹配：' + parsed.typeName };

	                    const methodName = parsed.methodName;
	                    const wantSig = Array.isArray(parsed.sigTypes) ? parsed.sigTypes : [];
	                    const found = scanAtTopLevel(function (i) {
	                    if (mask[i] !== methodName[0]) return null;
	                    if (mask.slice(i, i + methodName.length) !== methodName) return null;
	                    const before = i > 0 ? mask[i - 1] : '';
	                    const after = i + methodName.length < mask.length ? mask[i + methodName.length] : '';
	                    if (/[$_\p{L}\p{N}]/u.test(before)) return null;
	                    if (/[$_\p{L}\p{N}]/u.test(after)) return null;
	                    if (before === '.') return null;
	
	                    let p = skipWs(mask, i + methodName.length, bodyEnd);
	                    if (mask[p] !== '(') return null;
	                    const closeParen = findMatchingParenInMask(mask, p, bodyEnd);
	                    if (closeParen < 0) return null;
	                    const rawParamText = source.slice(p + 1, closeParen);
	                    const gotSig = normalizeCSharpSignatureTypes(rawParamText);
	                    if (gotSig.join(',') !== wantSig.join(',')) return null;
	
	                    let q = skipWs(mask, closeParen + 1, bodyEnd);
	                    if (mask[q] === '{') {
	                        const closeBrace = findMatchingBraceInMask(mask, q, bodyEnd);
	                        if (closeBrace < 0) return null;
	                        const start = findLineStart(source, i);
	                        return { start, end: closeBrace + 1 };
	                    }
	                    if (mask[q] === '=' && mask[q + 1] === '>') {
	                        const semi = mask.indexOf(';', q + 2);
	                        if (semi < 0 || semi >= bodyEnd) return null;
	                        const start = findLineStart(source, i);
	                        return { start, end: semi + 1 };
	                    }
	                    return null;
	                });
	
	                if (!found) return { ok: false, message: '找不到方法：' + selector };
	                return { ok: true, snippet: source.slice(found.start, found.end) };
	            }

	            if (kind === 'p') {
	                const parsed = parseMemberSelector(selector);
	                if (!parsed) return { ok: false, message: '属性选择器格式错误：' + String(selector || '') };
	                if (parsed.typeName !== fullTypeName) return { ok: false, message: '属性选择器类型不匹配：' + parsed.typeName };
	                const propName = parsed.memberName;
	
	                const found = scanAtTopLevel(function (i) {
	                    if (mask[i] !== propName[0]) return null;
	                    if (mask.slice(i, i + propName.length) !== propName) return null;
	                    const before = i > 0 ? mask[i - 1] : '';
	                    const after = i + propName.length < mask.length ? mask[i + propName.length] : '';
	                    if (/[$_\p{L}\p{N}]/u.test(before)) return null;
	                    if (/[$_\p{L}\p{N}]/u.test(after)) return null;
	                    if (before === '.') return null;
	
	                    let p = skipWs(mask, i + propName.length, bodyEnd);
	                    if (mask[p] === '(') return null;
	
	                    const start = findLineStart(source, i);
	                    if (mask[p] === '{') {
	                        const closeBrace = findMatchingBraceInMask(mask, p, bodyEnd);
	                        if (closeBrace < 0) return null;
	                        return { start, end: closeBrace + 1 };
	                    }
	                    if (mask[p] === '=' && mask[p + 1] === '>') {
	                        const semi = mask.indexOf(';', p + 2);
	                        if (semi < 0 || semi >= bodyEnd) return null;
	                        return { start, end: semi + 1 };
	                    }
	                    return null;
	                });

	                if (!found) return { ok: false, message: '找不到属性：' + selector };
	                return { ok: true, snippet: source.slice(found.start, found.end) };
	            }

	            if (kind === 'f' || kind === 'c') {
	                const parsed = parseMemberSelector(selector);
	                if (!parsed) return { ok: false, message: '字段选择器格式错误：' + String(selector || '') };
	                if (parsed.typeName !== fullTypeName) return { ok: false, message: '字段选择器类型不匹配：' + parsed.typeName };
	                const fieldName = parsed.memberName;
	
	                const found = scanAtTopLevel(function (i) {
	                    if (mask[i] !== fieldName[0]) return null;
	                    if (mask.slice(i, i + fieldName.length) !== fieldName) return null;
	                    const before = i > 0 ? mask[i - 1] : '';
	                    const after = i + fieldName.length < mask.length ? mask[i + fieldName.length] : '';
	                    if (/[$_\p{L}\p{N}]/u.test(before)) return null;
	                    if (/[$_\p{L}\p{N}]/u.test(after)) return null;
	                    if (before === '.') return null;
	
	                    const start = findLineStart(source, i);
	                    const semi = mask.indexOf(';', i);
	                    if (semi < 0 || semi >= bodyEnd) return null;
	                    return { start, end: semi + 1 };
	                });

	                if (!found) return { ok: false, message: '找不到字段：' + selector };
	                return { ok: true, snippet: source.slice(found.start, found.end) };
	            }

	            if (kind === 'e') {
	                const parsed = parseMemberSelector(selector);
	                if (!parsed) return { ok: false, message: '枚举成员选择器格式错误：' + String(selector || '') };
	                if (parsed.typeName !== fullTypeName) return { ok: false, message: '枚举成员选择器类型不匹配：' + parsed.typeName };
	                const memberName = parsed.memberName;
	
	                const found = scanAtTopLevel(function (i) {
	                    if (mask[i] !== memberName[0]) return null;
	                    if (mask.slice(i, i + memberName.length) !== memberName) return null;
	                    const before = i > 0 ? mask[i - 1] : '';
	                    const after = i + memberName.length < mask.length ? mask[i + memberName.length] : '';
	                    if (/[$_\p{L}\p{N}]/u.test(before)) return null;
	                    if (/[$_\p{L}\p{N}]/u.test(after)) return null;
	
	                    const start = findLineStart(source, i);
	                    for (let j = i; j < bodyEnd; j++) {
	                        if (mask[j] === ',') return { start, end: j + 1 };
	                        if (mask[j] === '}') return { start, end: j };
	                    }
	                    return null;
	                });

	                if (!found) return { ok: false, message: '找不到枚举成员：' + selector };
	                return { ok: true, snippet: source.slice(found.start, found.end) };
	            }

	            return { ok: false, message: '不支持的选择器：' + String(kind || '') };
	        }

        async function expandMarkdownTransclusions(markdown, currentDocPath, depth = 0, stack = [], ctx) {
            const diag = getCurrentLearningDiagnostics();
            if (!markdown) return markdown;
            if (depth > TRANSCLUSION_MAX_DEPTH) return markdown;

            const lines = String(markdown).split(/\r?\n/);
            const matches = [];
            let inFence = false;
            let fenceChar = '';
            let currentHeadingLevel = 1;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const fenceMatch = line.match(/^\s*(```+|~~~+)\s*/);
                if (fenceMatch) {
                    const currentFence = fenceMatch[1][0];
                    if (!inFence) {
                        inFence = true;
                        fenceChar = currentFence;
                    } else if (fenceChar === currentFence) {
                        inFence = false;
                        fenceChar = '';
                    }
                    continue;
                }

                if (inFence) continue;
                const headingMatch = line.match(/^(#{1,6})\s+.*$/);
                if (headingMatch) {
                    currentHeadingLevel = headingMatch[1].length;
                    continue;
                }

                const directive = parseTransclusionDirective(line);
                if (!directive) continue;

                matches.push({
                    lineIndex: i,
                    kind: directive.kind,
                    target: directive.target,
                    title: directive.title,
                    wrapperLevel: Math.min(6, currentHeadingLevel + 1)
                });

                if (matches.length >= TRANSCLUSION_MAX_FILES) break;
            }

            if (diag && diag.transclusion) {
                diag.transclusion.matchedLines += matches.length;
                if (matches.length >= TRANSCLUSION_MAX_FILES) {
                    diag.transclusion.errors.push({
                        from: String(currentDocPath || ''),
                        target: '',
                        message: '引用行数超过上限（仅处理前 ' + TRANSCLUSION_MAX_FILES + ' 个）'
                    });
                }
            }

            if (!matches.length) return markdown;

            function resolveTransclusionDocPath(rawBase) {
                if (!rawBase) return null;
                let resolved = resolveDocLinkPath(rawBase, currentDocPath);
                if (!resolved) {
                    const rel = resolveRelativeHref(rawBase, currentDocPath);
                    resolved = String(rel || '');
                }

                resolved = normalizePath(String(resolved || '').replace(/^\.?\//, '').replace(/^docs\//, ''));
                if (!resolved) return null;

                if (!resolved.endsWith('.md')) resolved += '.md';

                if (
                    resolved.includes('\0') ||
                    resolved.includes('\\\\') ||
                    /(^|\/)\.\.(\/|$)/.test(resolved)
                ) {
                    return null;
                }

                if (!isIndexedDocPath(resolved, currentDocPath)) return null;
                return resolved;
            }

            const replacements = await Promise.all(matches.map(async (m) => {
                if (m.kind === 'anim') {
                    const normalizedAnimPath = normalizePath(String(m.target || '').trim().replace(/^\.?\//, '').replace(/^docs\//, ''));
                    if (
                        !normalizedAnimPath ||
                        normalizedAnimPath.includes('\0') ||
                        normalizedAnimPath.includes('\\\\') ||
                        /(^|\/)\.\.(\/|$)/.test(normalizedAnimPath) ||
                        !normalizedAnimPath.startsWith('anims/') ||
                        !/\.cs$/i.test(normalizedAnimPath)
                    ) {
                        return `\n\n> 无法载入动画：非法路径 \`${m.target}\`\n\n`;
                    }
                    return `\n\n${buildFencedCodeBlock('animcs', normalizedAnimPath)}\n\n`;
                }

                if (isUnsafeTransclusionTarget(m.target)) {
                    if (diag && diag.transclusion) {
                        diag.transclusion.errors.push({
                            from: String(currentDocPath || ''),
                            target: String(m.target || ''),
                            message: '非法路径'
                        });
                    }
                    return `\n\n> 无法载入代码：非法路径 \`${m.target}\`\n\n`;
                }

                const { base, hash } = splitHash(m.target);
                let codeBase = String(base || '').trim();
                if (m.kind === 'cs' && codeBase && !/\.cs$/i.test(codeBase)) {
                    codeBase += '.cs';
                }

                const normalized = normalizeSourceCodePath(codeBase, currentDocPath);
                if (!normalized) {
                    return `\n\n> 无法载入代码：非法路径 \`${m.target}\`\n\n`;
                }

                const fetchUrl = `/site/content/${normalized.replace(/^\/+/, '')}`;
                let selector = null;
                if (hash && hash.startsWith('#')) {
                    let decoded = hash;
                    try {
                        decoded = '#' + decodeURIComponent(hash.slice(1));
                    } catch (_) {
                        decoded = hash;
                    }
                    selector = parseCSharpSnippetSelector(decoded);
                }

                try {
                    const resp = await fetch(encodeURI(fetchUrl), { cache: 'no-store' });
                    if (!resp.ok) throw new Error(`HTTP ${resp.status} ${resp.statusText}`);
                    const sourceText = await resp.text();

                    if (selector) {
                        const mask = buildCSharpCodeMask(sourceText);
                        const fullTypeName = getCSharpFullTypeNameFromSelector(selector.kind, selector.selector);
                        if (!fullTypeName) {
                            return `\n\n> 无法载入代码：\`${normalized}${hash}\`（选择器格式错误）\n\n`;
                        }
                        const result = extractMemberSnippet(sourceText, mask, fullTypeName, selector.kind, selector.selector);
                        if (!result.ok) {
                            return `\n\n> 无法载入代码：\`${normalized}${hash}\`（${String(result.message || '未知错误')}）\n\n`;
                        }
                        return `\n\n${buildFencedCodeBlock('csharp', dedentCodeBlockText(result.snippet))}\n\n`;
                    }

                    return `\n\n${buildFencedCodeBlock('csharp', sourceText)}\n\n`;
                } catch (err) {
                    return `\n\n> 无法载入代码：\`${normalized}\`（${String(err && err.message ? err.message : err)}）\n\n`;
                }
            }));

            const byLine = new Map();
            for (let i = 0; i < matches.length; i++) {
                byLine.set(matches[i].lineIndex, replacements[i]);
            }

            const out = [];
            for (let i = 0; i < lines.length; i++) {
                if (byLine.has(i)) {
                    out.push(byLine.get(i));
                } else {
                    out.push(lines[i]);
                }
            }

            return out.join('\n');
        }


        // 使用文档信息更新配置
        function updateConfigWithDocument(docInfo) {
            const { category, topic } = docInfo;

            // 确保分类存在
            if (!VIEWER_DOC_CONFIG.categories[category]) {
                VIEWER_DOC_CONFIG.categories[category] = {
                    title: category,
                    description: `${category}相关文档`,
                    topics: {}
                };
            }

            // 确保主题存在
            if (!VIEWER_DOC_CONFIG.categories[category].topics[topic]) {
                VIEWER_DOC_CONFIG.categories[category].topics[topic] = {
                    title: TOPIC_AREAS[topic]?.title || topic,
                    description: TOPIC_AREAS[topic]?.description || '',
                    files: []
                };
            }

            // 添加文件到对应主题
            DOC_CONFIG.categories[category].topics[topic].files.push(docInfo);

            // 更新作者信息
            if (!VIEWER_DOC_CONFIG.authors[docInfo.author]) {
                VIEWER_DOC_CONFIG.authors[docInfo.author] = {
                    name: docInfo.author,
                    files: []
                };
            }
            VIEWER_DOC_CONFIG.authors[docInfo.author].files.push(docInfo.filename);

            // 添加到所有文件列表
            VIEWER_DOC_CONFIG.all_files.push(docInfo);
        }
        // 直接加载Markdown内容的备用函数
	        function loadMarkdownDirectly(filePath) {
	            const loadingIndicator = document.getElementById('loading-indicator');
	            const errorMessage = document.getElementById('error-message');
	            const markdownContent = document.getElementById('markdown-content');

                if (loadingIndicator) {
                    loadingIndicator.style.display = 'block';
                    loadingIndicator.setAttribute('aria-busy', 'true');
                }
                if (errorMessage) {
                    errorMessage.style.display = 'none';
                    errorMessage.setAttribute('aria-hidden', 'true');
                }
                if (markdownContent) {
                    markdownContent.style.display = 'none';
                }

            console.log(`=== loadMarkdownDirectly() 诊断开始 ===`);
            console.log(`site/pages/viewer.html: 原始文件路径: ${filePath}`);
            console.log('当前页面位置:', window.location.href);

	            try {
	                // 增强的路径清理逻辑（仅允许加载 config.json 列出的文档，避免路径穿越）
	                let fetchPath = filePath;
	                console.log(`site/pages/viewer.html: 初始fetchPath: ${fetchPath}`);

	                                const studioPreviewTargetPath = getStudioPreviewTargetPath();
                let allowStudioPreviewUnindexed = false;

// 1. URL解码
	                fetchPath = decodeURIComponent(fetchPath);
	                console.log(`site/pages/viewer.html: URL解码后: ${fetchPath}`);
                if (studioPreviewTargetPath && normalizeStudioPreviewPath(fetchPath) === studioPreviewTargetPath) {
                    allowStudioPreviewUnindexed = true;
                }

	                // 1.1 基础安全校验：拒绝路径穿越/反斜杠/空字节
	                if (/(^|\/|\\)\.\.(\/|\\|$)/.test(fetchPath) || fetchPath.includes('\\') || fetchPath.includes('\0')) {
	                    throw new Error('非法路径参数');
	                }

	                // 1.2 旧路径兼容：Modder入门/0-指南 → Modder入门/指南
	                if (fetchPath.startsWith('Modder入门/0-指南/')) {
	                    const candidate = fetchPath.replace(/^Modder入门\/0-指南\//, 'Modder入门/指南/');
	                    if (isIndexedDocPath(candidate)) {
	                        fetchPath = candidate;
	                        console.log(`site/pages/viewer.html: 旧路径兼容重写: ${fetchPath}`);
	                    }
	                }

	            // 2. 尝试通过索引映射解析到真实路径（兼容旧链接/移动文件）
	            if (ALL_DOCS.length > 0) {
                const candidates = [
                    fetchPath,
                    fetchPath.replace(/^\.?\//, ''),
                    fetchPath.replace(/^site\/content\//, ''),
                    fetchPath.replace(/^content\//, ''),
                    fetchPath.replace(/^\.?\//, '').replace(/^site\/content\//, '').replace(/^content\//, '')
                ].filter(Boolean);

	                let resolved = null;
	                if (DOC_LOOKUP_MAP) {
	                    for (const c of candidates) {
	                        resolved = DOC_LOOKUP_MAP.get(c) || DOC_LOOKUP_MAP.get(String(c).toLowerCase());
	                        if (resolved) break;
	                        const noExt = String(c).replace(/\.md$/i, '');
	                        resolved = DOC_LOOKUP_MAP.get(noExt) || DOC_LOOKUP_MAP.get(noExt.toLowerCase());
	                        if (resolved) break;
	                    }
	                }

	                // fallback: category/filename 形式的旧链接（例如 Modder入门/<filename>.md）
	                if (!resolved) {
	                    const tail = String(fetchPath).split('/').pop();
	                    if (tail && tail !== fetchPath) {
	                        const matches = ALL_DOCS.filter(d => d && d.filename === tail);
	                        if (matches.length === 1 && matches[0].path) {
	                            resolved = matches[0].path;
	                        }
	                    }
	                }

	                if (resolved) {
	                    fetchPath = resolved;
	                    console.log(`site/pages/viewer.html: 通过索引映射解析到真实路径: ${fetchPath}`);
	                }
	            }

            // 3. 移除开头的 site/content 前缀
            if (fetchPath.startsWith('site/content/')) {
                fetchPath = fetchPath.substring('site/content/'.length);
                console.log(`site/pages/viewer.html: 移除 site/content 前缀: ${fetchPath}`);
            }
            if (fetchPath.startsWith('content/')) {
                fetchPath = fetchPath.substring('content/'.length);
                console.log(`site/pages/viewer.html: 移除 content 前缀: ${fetchPath}`);
            }

            // 4. 移除开头的斜杠
            if (fetchPath.startsWith('/')) {
                fetchPath = fetchPath.substring(1);
                console.log(`site/pages/viewer.html: 移除开头斜杠: ${fetchPath}`);
            }

            // 4. 检查是否是旧路径格式，进行重定向
            if (VIEWER_PATH_REDIRECTS[fetchPath]) {
                fetchPath = VIEWER_PATH_REDIRECTS[fetchPath];
                console.log(`site/pages/viewer.html: 旧路径重定向: ${fetchPath}`);
            }

	            // 5. 检查是否是已知的分类名或特殊文件
	            const knownCategories = ['01-入门指南', '02-基础概念', '03-内容创建', '04-高级开发', '05-专题主题', '06-资源参考'];
	            const rootFiles = []; // 位于docs根目录的特殊文件列表（如有需要可添加）
	            const defaultDocPath = (ALL_DOCS && ALL_DOCS.length > 0) ? (ALL_DOCS[0].path || ALL_DOCS[0].filename) : null;

            if (knownCategories.includes(fetchPath) || fetchPath.match(/^\d+-[^\/]+$/)) {
                // 如果是分类名，尝试重定向到对应的文档
                console.log(`site/pages/viewer.html: 识别为旧分类名，尝试重定向`);
                // 尝试找到该分类下的第一个文档
	                const firstDoc = ALL_DOCS.find(doc => doc.category === getCategoryFromOldPath(fetchPath));
	                if (firstDoc) {
	                    fetchPath = firstDoc.path || firstDoc.filename;
	                    console.log(`site/pages/viewer.html: 重定向到文档: ${fetchPath}`);
	                } else {
	                    if (!defaultDocPath) throw new Error('未找到可用文档');
	                    fetchPath = defaultDocPath;
	                    console.log(`site/pages/viewer.html: 未找到对应文档，使用默认: ${fetchPath}`);
	                }
	            } else if (rootFiles.includes(fetchPath)) {
                // 如果是根目录下的特殊文件，直接使用
                console.log(`site/pages/viewer.html: 识别为根目录文件: ${fetchPath}`);
            } else if (fetchPath.includes('/')) {
                // 路径已经包含目录，检查是否是旧格式
                if (fetchPath.match(/^\d+-[^\/]+\/.*/)) {
                    // 旧格式路径，尝试重定向
                    console.log(`site/pages/viewer.html: 识别为旧格式路径，尝试重定向`);
                    const filename = fetchPath.split('/').pop();
	                    const doc = ALL_DOCS.find(d => d.filename === filename || d.filename.endsWith(filename));
	                    if (doc) {
	                        fetchPath = doc.path || doc.filename;
	                        console.log(`site/pages/viewer.html: 重定向到文档: ${fetchPath}`);
	                    } else {
	                        if (!defaultDocPath) throw new Error('未找到可用文档');
	                        fetchPath = defaultDocPath;
	                        console.log(`site/pages/viewer.html: 未找到对应文档，使用默认: ${fetchPath}`);
	                    }
	                } else {
                    // 路径已经包含目录，直接使用
                    console.log(`site/pages/viewer.html: 使用完整路径: ${fetchPath}`);
                }
            } else {
                // 如果只是文件名，检查是否存在于文档列表中
	                const doc = ALL_DOCS.find(d => d.filename === fetchPath || d.path === fetchPath || d.filename === `${fetchPath}.md`);
	                if (doc) {
	                    fetchPath = doc.path || doc.filename;
	                    console.log(`site/pages/viewer.html: 找到匹配文档: ${fetchPath}`);
	                } else {
                    if (allowStudioPreviewUnindexed && studioPreviewTargetPath) {
                        fetchPath = studioPreviewTargetPath;
                        console.log(`site/pages/viewer.html: 使用 studio 草稿路径: ${fetchPath}`);
                    } else {
                        if (!defaultDocPath) throw new Error('未找到可用文档');
                        fetchPath = defaultDocPath;
                        console.log(`site/pages/viewer.html: 未找到匹配文档，使用默认: ${fetchPath}`);
                    }
                }
            }

            if (!allowStudioPreviewUnindexed && studioPreviewTargetPath) {
                allowStudioPreviewUnindexed = normalizeStudioPreviewPath(fetchPath) === studioPreviewTargetPath;
            }

            // 6. 最终白名单校验：必须存在于 ALL_DOCS 中
	            if (ALL_DOCS && ALL_DOCS.length > 0) {
                const matches = ALL_DOCS.filter(d => d.path === fetchPath || d.filename === fetchPath);
                if (matches.length === 1) {
                    fetchPath = matches[0].path || matches[0].filename;
                } else if (matches.length === 0) {
                    if (allowStudioPreviewUnindexed && studioPreviewTargetPath) {
                        fetchPath = studioPreviewTargetPath;
                        console.log(`site/pages/viewer.html: 白名单豁免（studio 草稿）: ${fetchPath}`);
                    } else {
                        throw new Error('文档不存在或未被索引（请使用 site/content/config.json 中的路径）');
                    }
                } else {
                    throw new Error('文档名称不唯一，请使用完整路径');
                }
            }

	            // 7. 确保文件以.md结尾
	            if (!fetchPath.endsWith('.md')) {
	                fetchPath += '.md';
	                console.log(`site/pages/viewer.html: 添加.md扩展名: ${fetchPath}`);
	            }

		            console.log(`site/pages/viewer.html: 最终使用路径: ${fetchPath}`);
		            CURRENT_DOC_PATH = fetchPath;
		            if (typeof window.updateGiscusForDoc === 'function') {
		                window.updateGiscusForDoc(fetchPath);
		            }
		
		            // 使用 site/content 作为文档根目录
		            const fetchUrl = `/site/content/${fetchPath.replace(/^\/+/, '')}`;

            console.log(`site/pages/viewer.html: 实际fetch URL: ${fetchUrl}`);
            console.log(`完整请求URL将是: ${window.location.origin}${fetchUrl}`);

	            fetch(encodeURI(fetchUrl), { cache: 'no-store' })
	                .then(response => {
                    console.log(`获取响应状态: ${response.status} ${response.statusText}`);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status} ${response.statusText}`);
                    }
                    return response.text();
                })
                .then(async markdownText => {
                    console.log(`site/pages/viewer.html: 成功获取Markdown内容，长度: ${markdownText.length}`);

                    if (typeof marked !== 'undefined') {
                        console.log('marked.js已加载，开始渲染');

	                        // 解析Front Matter（文档元数据）
	                        const frontMatter = parseFrontMatter(markdownText);
	                        let content = frontMatter.content;
	                        const metadata = frontMatter.metadata;

                        // 补齐缺失的元数据：优先使用 config.json 中的索引信息（不修改 Markdown 原文）
                        const docFromConfig = ALL_DOCS.find(d => {
                            const p = d.path || d.filename;
                            return p === fetchPath || d.filename === fetchPath || d.path === fetchPath;
                        });
	                        if (docFromConfig) {
	                            if (!metadata.title && docFromConfig.title) metadata.title = docFromConfig.title;
	                            if (!metadata.author && docFromConfig.author) metadata.author = docFromConfig.author;
	                            if (!metadata.description && docFromConfig.description) metadata.description = docFromConfig.description;
	                            if (!metadata.category && docFromConfig.category) metadata.category = docFromConfig.category;
	                            if (!metadata.topic && docFromConfig.topic) metadata.topic = docFromConfig.topic;
	                            if (!metadata.difficulty && docFromConfig.difficulty) metadata.difficulty = docFromConfig.difficulty;
	                            if (!metadata.time && docFromConfig.time) metadata.time = docFromConfig.time;
	                            if (!metadata.prev_chapter && docFromConfig.prev_chapter) metadata.prev_chapter = docFromConfig.prev_chapter;
	                            if (!metadata.next_chapter && docFromConfig.next_chapter) metadata.next_chapter = docFromConfig.next_chapter;
	                            if (!metadata.colors && docFromConfig.colors) metadata.colors = docFromConfig.colors;
	                            if (!metadata.colorChange && docFromConfig.colorChange) metadata.colorChange = docFromConfig.colorChange;
	                        }

                        console.log('解析的元数据:', metadata);

	                        // 更新页面元数据（标题、难度、作者等）
	                        updatePageMetadata(metadata, fetchPath);

	                        // 更新当前分类的文档列表
	                        updateCurrentCategoryDocs(fetchPath);

	                        // 如果 Front Matter 指定了 source_cs 字段，则显示对应 C# 源码（允许多个）
	                        renderSourceCodesFromFrontMatter(metadata, fetchPath);

	                        // 作者模式已移除，清理上一轮诊断缓存。
	                        setCurrentLearningDiagnostics(null);

	                        try {
	                            const learningModel = getLearningRenderContext();
	                            window.CURRENT_LEARNING_MODEL = learningModel;

		                            content = await expandMarkdownTransclusions(content, fetchPath, 0, [], learningModel.ctx);

		                            if (typeof renderLearningSidebarPanel === 'function') {
		                                renderLearningSidebarPanel(learningModel);
		                            }
		                            renderLearningRecommendationHint(metadata, learningModel);
		                            if (typeof renderLearningHintsBanner === 'function') {
		                                renderLearningHintsBanner(learningModel);
		                            }
		                            if (typeof renderLearningTopBanner === 'function') {
		                                renderLearningTopBanner(learningModel);
		                            }
	                        } catch (err) {
	                            console.warn('展开引用内容失败，继续渲染原始文档:', err);
	                        }

	                        const renderedHTML = marked.parse(content);
	                        console.log('Markdown渲染完成，HTML长度:', renderedHTML.length);
	                        markdownContent.innerHTML = renderedHTML;

	                        // 移除正文内重复的“章节进度”导航（统一使用页脚导航）
	                        removeDuplicateChapterProgress(markdownContent);

	                        // 清理历史写法中的“（可引用）”标记，避免在目录/标题中出现
	                        stripReferenceMarkersInDom(markdownContent);

	                        // 渲染题目组件（quiz）
	                        if (window.SiteQuiz && typeof window.SiteQuiz.renderQuizzes === 'function') {
	                            window.SiteQuiz.renderQuizzes(markdownContent);
	                        }

	                        // 为 Mermaid 测量提供可布局的容器（display:none 会导致尺寸计算错误/文字截断）
	                        markdownContent.style.display = 'block';
	                        markdownContent.style.visibility = 'hidden';
	                        markdownContent.style.pointerEvents = 'none';

	                        // 渲染流程图（Mermaid）
	                        await renderMermaidFlowcharts(markdownContent);

	                        // 应用代码语法高亮
	                        if (typeof Prism !== 'undefined') {
	                            console.log('应用代码高亮');
	                            Prism.highlightAllUnder(markdownContent);
                                document.dispatchEvent(new CustomEvent('viewer:content-ready', {
                                    detail: { container: markdownContent }
                                }));
                        } else {
                            console.warn('Prism.js未加载，跳过代码高亮');
                            document.dispatchEvent(new CustomEvent('viewer:content-ready', {
                                detail: { container: markdownContent }
                            }));
                        }

	                        // 自动生成文档目录
	                        generateTableOfContents(markdownContent);

	                        // 显示内容，隐藏加载指示器
	                        if (loadingIndicator) {
                            loadingIndicator.style.display = 'none';
                            loadingIndicator.setAttribute('aria-busy', 'false');
                        }
                        markdownContent.style.display = 'block';
                        markdownContent.style.visibility = 'visible';
                        markdownContent.style.pointerEvents = '';
                        document.getElementById('table-of-contents').style.display = 'block';
                        if (errorMessage) errorMessage.setAttribute('aria-hidden', 'true');

                        // 初始化图片缩放
                        initImageZoom();

                    } else {
                        throw new Error('marked.js未加载');
                    }
                })
	                .catch(error => {
                    console.error('site/pages/viewer.html: 加载Markdown失败:', error);
                    if (loadingIndicator) {
                        loadingIndicator.style.display = 'none';
                        loadingIndicator.setAttribute('aria-busy', 'false');
                    }
                    if (errorMessage) {
                        errorMessage.style.display = 'block';
                        errorMessage.setAttribute('aria-hidden', 'false');
                        document.getElementById('error-text').textContent = `无法加载文件 "${fetchPath}": ${error.message}`;
                    }
	                });
	            } catch (error) {
	                console.error('site/pages/viewer.html: 无法解析/加载文档:', error);
	                if (loadingIndicator) {
	                    loadingIndicator.style.display = 'none';
                        loadingIndicator.setAttribute('aria-busy', 'false');
	                }
	                if (errorMessage) {
	                    errorMessage.style.display = 'block';
                        errorMessage.setAttribute('aria-hidden', 'false');
	                    document.getElementById('error-text').textContent = `无法加载文件 "${filePath}": ${error.message}`;
	                }
	            }
	        }

        // 分类映射函数：将旧分类系统映射到新分类系统
        function mapCategoryToNewSystem(oldCategory) {
            console.log(`映射分类: ${oldCategory}`);

            // 如果分类已经存在于新系统中，直接返回
            if (MAIN_CATEGORIES[oldCategory]) {
                console.log(`分类 ${oldCategory} 已存在于新系统中`);
                return oldCategory;
            }

            // 如果配置文件中有分类映射，使用映射
            if (VIEWER_DOC_CONFIG && VIEWER_DOC_CONFIG.categoryMappings && VIEWER_DOC_CONFIG.categoryMappings[oldCategory]) {
                const newCategory = VIEWER_DOC_CONFIG.categoryMappings[oldCategory];
                console.log(`分类 ${oldCategory} 映射到 ${newCategory}`);
                return newCategory;
            }

            // 尝试从旧路径中提取分类
            const pathMap = {
                '00-测试文档': '入门',
                '01-入门指南': '入门',
                '02-基础概念': '入门',
                '03-内容创建': '进阶',
                '04-高级开发': '高级',
                '05-专题主题': '高级',
                '06-资源参考': '个人分享',
                '0-开始': '入门',
                '1-基础': '入门',
                '2-中阶': '进阶',
                '3-高阶': '高级',
                '4-专家': '高级'
            };

            const mappedCategory = pathMap[oldCategory] || '入门';
            console.log(`通过路径映射，分类 ${oldCategory} 映射到 ${mappedCategory}`);
            return mappedCategory;
        }

        // 从旧路径获取对应的分类
	        function getCategoryFromOldPath(oldPath) {
	            console.log(`从旧路径获取分类: ${oldPath}`);
	            const category = mapCategoryToNewSystem(oldPath);
	            console.log(`映射结果: ${category}`);
	            return category;
	        }

	        function parseOrder(value, fallback = 999) {
	            const parsed = Number.parseInt(value, 10);
	            return Number.isFinite(parsed) ? parsed : fallback;
	        }

	        // 解析Front Matter（文档开头的元数据部分）
	        function parseFrontMatter(text) {
            const frontMatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/;
            const match = text.match(frontMatterRegex);

            if (match) {
                const yamlText = match[1];
                const content = match[2];

                // 更强大的YAML解析器
                const metadata = parseYaml(yamlText);

                return {
                    metadata: metadata,
                    content: content
                };
            }

            return {
                metadata: {},
                content: text
            };
        }

        // 简单的YAML解析器，支持嵌套对象和数组
	        function parseYaml(yamlText) {
            // 移除开头和结尾的空白行
            const lines = yamlText.trim().split('\n');
            const result = {};

            // 简单的栈结构跟踪当前对象和缩进级别
            const stack = [{ obj: result, indent: -1 }];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (!line.trim()) continue;

                // 计算实际缩进（空格数）
                const indent = line.search(/\S/);
                const trimmedLine = line.trim();

                // 移除比当前缩进级别更深的所有对象
                while (stack.length > 1 && stack[stack.length - 1].indent >= indent) {
                    stack.pop();
                }

                const current = stack[stack.length - 1];
                const currentObj = current.obj;

                // 处理数组项（以-开头）
                if (trimmedLine.startsWith('-')) {
                    const content = trimmedLine.substring(1).trim();

                    // 检查是否是键值对形式 (- key: value)
                    if (content.includes(':')) {
                        const colonIndex = content.indexOf(':');
                        const key = content.substring(0, colonIndex).trim();
                        const value = content.substring(colonIndex + 1).trim();

                        // 处理带引号的字符串
                        let finalValue = value;
                        if ((value.startsWith('"') && value.endsWith('"')) ||
                            (value.startsWith("'") && value.endsWith("'"))) {
                            finalValue = value.substring(1, value.length - 1);
                        }

                        // 如果当前对象是数组，则推入新对象
                        if (Array.isArray(currentObj)) {
                            const newObj = {};
                            newObj[key] = finalValue;
                            currentObj.push(newObj);
                        } else {
                            // 否则创建数组并添加第一个元素
                            const arrayKey = Object.keys(currentObj).pop();
                            if (!Array.isArray(currentObj[arrayKey])) {
                                currentObj[arrayKey] = [];
                            }
                            const newObj = {};
                            newObj[key] = finalValue;
                            currentObj[arrayKey].push(newObj);
                        }
                    } else {
                        // 简单值形式 (- value)
                        let finalValue = content;
                        if ((content.startsWith('"') && content.endsWith('"')) ||
                            (content.startsWith("'") && content.endsWith("'"))) {
                            finalValue = content.substring(1, content.length - 1);
                        }

                        // 确保当前上下文是数组
                        const parent = stack[stack.length - 2];
                        if (parent) {
                            const parentObj = parent.obj;
                            const arrayKey = Object.keys(parentObj).pop();

                            if (!Array.isArray(parentObj[arrayKey])) {
                                parentObj[arrayKey] = [];
                            }
                            parentObj[arrayKey].push(finalValue);
                        }
                    }
                }
                // 处理键值对 (key: value)
                else if (trimmedLine.includes(':')) {
                    const colonIndex = trimmedLine.indexOf(':');
                    const key = trimmedLine.substring(0, colonIndex).trim();
                    const value = trimmedLine.substring(colonIndex + 1).trim();

                    // 如果值为空，这是一个嵌套对象
                    if (!value) {
                        const newObj = {};
                        currentObj[key] = newObj;
                        stack.push({ obj: newObj, indent: indent });
                    }
                    // 如果值不为空，是简单键值对
                    else {
                        // 处理带引号的字符串
                        let finalValue = value;
                        if ((value.startsWith('"') && value.endsWith('"')) ||
                            (value.startsWith("'") && value.endsWith("'"))) {
                            finalValue = value.substring(1, value.length - 1);
                        }
                        // 处理颜色值等特殊格式
                        else if (value.startsWith('#')) {
                            finalValue = value;
                        }
                        // 尝试转换数字
                        else if (!isNaN(value) && !isNaN(parseFloat(value))) {
                            finalValue = parseFloat(value);
                        }
                        // 处理布尔值
                        else if (value.toLowerCase() === 'true') {
                            finalValue = true;
                        }
                        else if (value.toLowerCase() === 'false') {
                            finalValue = false;
                        }

                        currentObj[key] = finalValue;
                    }
                }
                // 处理数组开始的情况 ([key]:)
                else if (trimmedLine.endsWith(':')) {
                    const key = trimmedLine.slice(0, -1).trim();
                    const newArray = [];
                    currentObj[key] = newArray;
                    stack.push({ obj: newArray, indent: indent });
                }
            }

	            return result;
	        }

	        // Front Matter 源代码展示：从元数据读取并加载 *.cs 源码（允许多个）
	        function getSourceCodeMetaPaths(metadata) {
	            if (!metadata) return [];
	            const candidates = [
	                metadata.source_cs,
	                metadata.sourceCs,
	                metadata.source_code,
	                metadata.sourceCode,
	                metadata.cs_source,
	                metadata.csSource
	            ];
	
	            for (let i = 0; i < candidates.length; i++) {
	                const v = candidates[i];
	                if (!v) continue;
	                if (Array.isArray(v)) return v;
	                if (typeof v === 'string' || typeof v === 'number') return [String(v)];
	            }
	
	            return [];
	        }

	        function normalizeSourceCodePath(raw, currentDocPath) {
	            let text = String(raw || '').trim();
	            if (!text) return '';

	            // URL 解码（容错）
	            try { text = decodeURIComponent(text); } catch (_) { /* ignore */ }
	
	            // 基础安全校验：禁止协议/绝对路径/路径穿越/反斜杠/空字节
	            if (/^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(text)) return '';
	            if (text.startsWith('/') || text.startsWith('#')) return '';
	            if (/(^|\/|\\)\.\.(\/|\\|$)/.test(text) || text.includes('\\') || text.includes('\u0000')) return '';
	
	            // 兼容写法：允许带 site/content 或 content 前缀
	            text = text.replace(/^\.\/?/, '');
	            text = text.replace(/^site\/content\//, '');
	            text = text.replace(/^content\//, '');
	
	            // 相对路径解析（相对当前 Markdown 目录）
	            const resolved = resolveRelativeHref(text, currentDocPath || CURRENT_DOC_PATH || '');
	            const noHash = String(resolved || '').split('#')[0];
	            const normalized = normalizePath(noHash);
	
	            if (!normalized || !/\.cs$/i.test(normalized)) return '';
	            if (/(^|\/|\\)\.\.(\/|\\|$)/.test(normalized) || normalized.includes('\\') || normalized.includes('\u0000')) return '';
	
	            return normalized;
	        }

	        function resetSourceCodeSection() {
	            const section = document.getElementById('source-code-section');
	            const list = document.getElementById('source-code-list');
	
	            if (list) list.innerHTML = '';
	            if (section) {
	                section.style.display = 'none';
	                section.setAttribute('aria-hidden', 'true');
	            }
	        }

	        function createSourceCodeDetailsItem(normalizedPath) {
	            const details = document.createElement('details');
	            details.className = 'source-code-details';
	
	            const summary = document.createElement('summary');
	            const fileName = String(normalizedPath || '').split('/').pop() || '源代码';
	            summary.textContent = `源代码: ${fileName}`;
	
	            const toolbar = document.createElement('div');
	            toolbar.className = 'source-code-toolbar';
	            toolbar.setAttribute('aria-label', '源代码工具');
	
	            const openEl = document.createElement('a');
	            openEl.className = 'btn btn-small btn-outline';
	            openEl.textContent = '打开源文件';
	            openEl.target = '_blank';
	            openEl.rel = 'noopener noreferrer';
	
	            const copyBtn = document.createElement('button');
	            copyBtn.className = 'btn btn-small btn-secondary';
	            copyBtn.type = 'button';
	            copyBtn.textContent = '复制';
	
	            toolbar.appendChild(openEl);
	            toolbar.appendChild(copyBtn);
	
	            const errorEl = document.createElement('div');
	            errorEl.className = 'source-code-error';
	            errorEl.style.display = 'none';
	            errorEl.setAttribute('role', 'status');
	            errorEl.setAttribute('aria-live', 'polite');
	
	            const pre = document.createElement('pre');
	            const codeEl = document.createElement('code');
	            codeEl.className = 'language-csharp';
	            pre.appendChild(codeEl);
	
	            details.appendChild(summary);
	            details.appendChild(toolbar);
	            details.appendChild(errorEl);
	            details.appendChild(pre);
	
	            return { details, openEl, copyBtn, errorEl, codeEl };
	        }

	        async function copyTextToClipboard(text) {
	            const value = String(text || '');
	            if (!value) return false;
	            if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
	                await navigator.clipboard.writeText(value);
	                return true;
	            }
	            const ta = document.createElement('textarea');
	            ta.value = value;
	            ta.setAttribute('readonly', '');
	            ta.style.position = 'fixed';
	            ta.style.left = '-9999px';
	            document.body.appendChild(ta);
	            ta.select();
	            document.execCommand('copy');
	            document.body.removeChild(ta);
	            return true;
	        }

	        async function renderSourceCodesFromFrontMatter(metadata, currentDocPath) {
	            resetSourceCodeSection();

	            const rawList = getSourceCodeMetaPaths(metadata);
	            if (!rawList || rawList.length === 0) return;

	            const normalizedList = [];
	            for (let i = 0; i < rawList.length; i++) {
	                const normalized = normalizeSourceCodePath(rawList[i], currentDocPath || CURRENT_DOC_PATH);
	                if (!normalized) continue;
	                if (normalizedList.includes(normalized)) continue;
	                normalizedList.push(normalized);
	            }
	
	            if (normalizedList.length === 0) return;
	
	            const section = document.getElementById('source-code-section');
	            const list = document.getElementById('source-code-list');
	            if (!section || !list) return;
	
	            section.style.display = 'block';
	            section.setAttribute('aria-hidden', 'false');

	            for (let i = 0; i < normalizedList.length; i++) {
	                const normalizedPath = normalizedList[i];
	                const item = createSourceCodeDetailsItem(normalizedPath);
	                list.appendChild(item.details);

	                const fetchUrl = `/site/content/${normalizedPath.replace(/^\/+/, '')}`;
	                item.openEl.setAttribute('href', fetchUrl);

	                item.copyBtn.addEventListener('click', async function () {
	                    const text = item.codeEl ? String(item.codeEl.textContent || '') : '';
	                    if (!text) return;
	                    item.copyBtn.disabled = true;
	                    const original = item.copyBtn.textContent;
	                    item.copyBtn.textContent = '复制中...';
	                    try {
	                        await copyTextToClipboard(text);
	                        item.copyBtn.textContent = '已复制';
	                    } catch (_) {
	                        item.copyBtn.textContent = '复制失败';
	                    }
	                    setTimeout(function () {
	                        item.copyBtn.textContent = original;
	                        item.copyBtn.disabled = false;
	                    }, 900);
	                });

	                try {
	                    const resp = await fetch(encodeURI(fetchUrl), { cache: 'no-store' });
	                    if (!resp.ok) throw new Error(`HTTP ${resp.status} ${resp.statusText}`);
	                    const sourceText = await resp.text();
	                    item.codeEl.textContent = sourceText;
	                    if (typeof Prism !== 'undefined' && Prism && typeof Prism.highlightElement === 'function') {
	                        Prism.highlightElement(item.codeEl);
	                    }
	                } catch (err) {
	                    item.errorEl.style.display = 'block';
	                    item.errorEl.textContent = '源码加载失败：' + (err && err.message ? err.message : String(err));
	                }
	            }
	        }

	        // 更新页面元数据（标题、难度、时间、作者）
	        function updatePageMetadata(metadata, filePath) {
	            const title = metadata.title || filePath.replace('.md', '');
	            const difficulty = metadata.difficulty;
	            const time = metadata.time;
	            const author = metadata.author || '未知';
	            const prevChapter = metadata.prev_chapter || null;
	            const nextChapter = metadata.next_chapter || null;
		            const colors = metadata.colors || metadata.colorLD || null;
		            const colorChange = metadata.colorChange || null;
		
	            console.log('更新页面元数据:', { title, difficulty, time, author, prevChapter, nextChapter, colors, colorChange });

	            document.title = `${title} - 泰拉瑞亚Mod制作教程`;

	            const currentNameEl = document.getElementById('current-doc-name');
	            if (currentNameEl) currentNameEl.textContent = title;

	            const titleEl = document.getElementById('doc-title');
	            if (titleEl) titleEl.textContent = title;

	            function normalizeDifficultyForUi(value) {
	                const raw = String(value || '').trim();
	                if (raw === '简单' || raw.toLowerCase() === 'easy' || raw.toLowerCase() === 'beginner') return { key: 'easy', label: '简单' };
	                if (raw === '普通' || raw.toLowerCase() === 'normal' || raw.toLowerCase() === 'intermediate') return { key: 'normal', label: '普通' };
	                if (raw === '困难' || raw.toLowerCase() === 'hard' || raw.toLowerCase() === 'advanced') return { key: 'hard', label: '困难' };
	                return { key: 'unknown', label: raw || '未知' };
	            }

	            function formatTimeForUi(value) {
	                if (typeof value === 'number' && Number.isFinite(value)) return String(value);
	                const text = String(value || '').trim();
	                return text || '未知';
	            }

	            const difficultyEl = document.getElementById('doc-difficulty');
	            if (difficultyEl) {
	                const d = normalizeDifficultyForUi(difficulty);
	                difficultyEl.textContent = d.label;
	                difficultyEl.className = `difficulty-badge difficulty-${d.key}`;
	            }

	            const timeEl = document.getElementById('doc-time');
	            if (timeEl) timeEl.textContent = formatTimeForUi(time);

	            const authorEl = document.getElementById('doc-author');
	            if (authorEl) authorEl.textContent = author;

	            // 更新特殊颜色
		            updateColorStyle(colors, colorChange);

            // 更新面包屑导航
            updateBreadcrumbNavigation(metadata, filePath);

            // 更新导航按钮
	            updateNavigationButtons(prevChapter, nextChapter, filePath);

            // 更新 SEO 元标签（canonical/OG/Twitter/description）
            updateSeoMeta({
                title,
                description: metadata.description || metadata.summary || '',
                filePath
            });
        }

        function setMetaContent(selector, content) {
            const el = document.querySelector(selector);
            if (el && content) el.setAttribute('content', content);
        }

        function setCanonical(href) {
            let link = document.querySelector('link[rel="canonical"]');
            if (!link) {
                link = document.createElement('link');
                link.setAttribute('rel', 'canonical');
                document.head.appendChild(link);
            }
            link.setAttribute('href', href);
        }

        function updateSeoMeta({ title, description, filePath }) {
            const baseUrl = 'https://dpapyru.github.io/site/pages/viewer.html';
            const url = filePath ? `${baseUrl}?file=${encodeURIComponent(filePath)}` : baseUrl;

            const safeTitle = title ? `${title} - 泰拉瑞亚Mod制作教程` : '文档查看器 - 泰拉瑞亚Mod制作教程';
            const safeDescription = (description && String(description).trim())
                ? String(description).trim()
                : '泰拉瑞亚Mod制作教程文档阅读页面，支持目录、代码高亮与分类导航。';

            setCanonical(url);
            setMetaContent('meta[name="description"]', safeDescription);
            setMetaContent('meta[property="og:title"]', safeTitle);
            setMetaContent('meta[property="og:description"]', safeDescription);
            setMetaContent('meta[property="og:url"]', url);
            setMetaContent('meta[name="twitter:title"]', safeTitle);
            setMetaContent('meta[name="twitter:description"]', safeDescription);
        }

	        function updateColorStyle(colorsConfig, colorChangeConfig) {
	            const existing = document.getElementById('dynamic-color-style');
	            if (existing) existing.remove();

	            const style = document.createElement('style');
	            style.id = 'dynamic-color-style';

	            // 文字颜色变量（单色）
	            let colors = '';
	            if (!colorsConfig) {
	                console.warn('没有设置文字颜色变量!跳过文字颜色的设置!');
	            } else {
	                colors = colorStyle(colorsConfig);
	            }

	            // 颜色动画
	            let colorChange = '';
	            if (!colorChangeConfig) {
	                console.warn('没有设置颜色转换变量!跳过颜色转换变量的设置!');
	            } else {
	                colorChange = colorChangeStyle(colorChangeConfig) || '';
	            }

	            style.textContent = `
	                        ${colorChange}
	                        :root{
	                            ${colors}
	                        }
	                    `;
	            document.head.appendChild(style);
	        }

	        function colorStyle(colorsConfig) {
	            try {
	                if (!colorsConfig) {
	                    console.error('特殊字体颜色配置失效！');
	                    return '';
	                }

	                let styleText = '';
	                Object.entries(colorsConfig).forEach(([name, value]) => {
	                    let resolved = '';
	                    if (Array.isArray(value)) {
	                        resolved = (value.length > 1 ? value[1] : value[0]) || '';
	                    } else if (typeof value === 'string') {
	                        resolved = value;
	                    }

	                    if (!resolved) return;
	                    styleText = styleText.concat(`
	                            --marked-text-color-${name}:${resolved};
	                        `).trim();
	                });

	                return styleText;
	            } catch (error) {
	                console.error('创建css时候出现严重问题!问题:', error);
	            }
	        }

        /**
         * 根据颜色变化数组生成CSS动画样式
         * @param {Array} colorChangeArray - 颜色变化配置数组，每个元素包含动画名称和颜色值数组
         * @returns {void}
         */
        function colorChangeStyle(colorChangeArray) {
            try {
                const forEach_color = colorChangeArray; // 颜色动画的数组
                let style_text = ''; // 输出的内容
                if (forEach_color) { // 如果有颜色数组
                    // 遍历颜色改变数组
                    Object.entries(forEach_color).forEach(colorName => {
                        // colorName0是名字
                        // colorName1是颜色数组

                        const colorArray = [];
                        // 遍历每个变量名
                        colorName[1].forEach(color => {
                            colorArray.push(color);
                        });
                        const colorLength = colorArray.length;
                        let useColor = '';
                        // 构建关键帧动画的颜色变化部分
                        for (let i = 0; i < colorLength; i++) {
                            const colorPercent = (i / colorLength) * 100;
                            useColor = useColor.concat(`${colorPercent.toFixed(0)}% {color:${colorArray[i]};}\n`);
                        }
                        useColor = useColor.concat(`100% {color:${colorArray[0]};}\n`);
                        // 添加样式
                        style_text = style_text.concat(`
                            @keyframes colorChange-${colorName[0]}{
                                ${useColor}
                            }
                        `);
                    });
                    return style_text;
                }
                else {
                    console.error('特殊字体颜色配置失效！');
                }
            } catch (error) {
                console.error('创建css时候出现严重问题!问题:', error);
            }
        }

        // 更新面包屑导航
        function updateBreadcrumbNavigation(metadata, filePath) {
            const breadcrumb = document.querySelector('.breadcrumb');
            if (!breadcrumb) return;

            // 查找当前文档信息
            const currentDoc = ALL_DOCS.find(doc => doc.filename === filePath || doc.path === filePath);

            // 清空现有面包屑
            breadcrumb.innerHTML = '';

            // 添加首页链接
            const homeLink = document.createElement('a');
            homeLink.href = '../index.html';
            homeLink.textContent = '首页';
            breadcrumb.appendChild(homeLink);

            // 添加分隔符
            const separator1 = document.createElement('span');
            separator1.className = 'breadcrumb-separator';
            separator1.textContent = ' > ';
            breadcrumb.appendChild(separator1);

            // 添加文档列表链接
            const docsLink = document.createElement('a');
            docsLink.href = 'index.html';
            docsLink.textContent = '文档';
            breadcrumb.appendChild(docsLink);

            // 如果找到当前文档信息，添加分类和主题路径
            if (currentDoc) {
                // 添加分隔符
                const separator2 = document.createElement('span');
                separator2.className = 'breadcrumb-separator';
                separator2.textContent = ' > ';
                breadcrumb.appendChild(separator2);

                // 添加分类链接
                const category = MAIN_CATEGORIES[currentDoc.category];
                if (category) {
                    const categoryLink = document.createElement('a');
                    categoryLink.href = `folder.html?path=${encodeURIComponent(currentDoc.category)}`;
                    categoryLink.textContent = category.title;
                    breadcrumb.appendChild(categoryLink);

                    // 主题信息仅展示为文本（当前站点不支持按 topic 过滤跳转）
                    if (currentDoc.topic && VIEWER_DOC_CONFIG && VIEWER_DOC_CONFIG.topics && VIEWER_DOC_CONFIG.topics[currentDoc.topic]) {
                        const separator3 = document.createElement('span');
                        separator3.className = 'breadcrumb-separator';
                        separator3.textContent = ' > ';
                        breadcrumb.appendChild(separator3);

                        const topicSpan = document.createElement('span');
                        topicSpan.className = 'breadcrumb-topic';
                        topicSpan.textContent = VIEWER_DOC_CONFIG.topics[currentDoc.topic].title;
                        breadcrumb.appendChild(topicSpan);

                        const separator4 = document.createElement('span');
                        separator4.className = 'breadcrumb-separator';
                        separator4.textContent = ' > ';
                        breadcrumb.appendChild(separator4);
                    }
                }
            }

            // 添加当前文档标题
            const currentSpan = document.createElement('span');
            currentSpan.className = 'current';
            currentSpan.textContent = metadata.title || filePath.replace('.md', '');
            breadcrumb.appendChild(currentSpan);
        }

	        // 更新导航按钮
		        function updateNavigationButtons(prevChapter, nextChapter, currentDocPath) {
	            const navigationContainer = document.querySelector('.tutorial-navigation');
	            if (!navigationContainer) {
	                console.warn('找不到导航容器');
	                return;
	            }

            // 清空现有导航内容
            navigationContainer.innerHTML = '';

	            // 添加返回文档列表按钮
	            const backToListBtn = document.createElement('a');
	            backToListBtn.href = 'index.html';
	            backToListBtn.className = 'btn btn-outline prev-tutorial';
		            backToListBtn.textContent = '← 返回文档列表';
		            navigationContainer.appendChild(backToListBtn);

	            function findDocByPath(docPath) {
	                const p = String(docPath || '');
	                if (!p || !Array.isArray(ALL_DOCS)) return null;
	                return ALL_DOCS.find(d => d && (d.path === p || d.filename === p)) || null;
	            }

	            function getDocTitle(docPath) {
	                const doc = findDocByPath(docPath);
	                if (doc && doc.title) return String(doc.title);
	                const tail = String(docPath || '').split('/').pop() || '';
	                return tail.replace(/\.md$/i, '') || String(docPath || '');
	            }

	            function resolveNavPath(raw) {
	                if (!raw) return null;
	                const href = String(raw).trim();
	                if (!href) return null;
	                const resolved = resolveDocLinkPath(href, currentDocPath || CURRENT_DOC_PATH);
	                if (resolved) return resolved;
	                const fallback = resolveRelativeHref(href, currentDocPath || CURRENT_DOC_PATH);
	                if (!fallback) return href;
	                return String(fallback).replace(/^\.?\//, '').replace(/^docs\//, '');
	            }

	            function appendNavButton(kind, resolvedPath) {
	                const title = getDocTitle(resolvedPath);
	                const btn = document.createElement('a');
	                btn.href = `?file=${encodeURIComponent(resolvedPath)}`;
	                btn.className = kind === 'prev'
	                    ? 'btn btn-secondary prev-tutorial'
	                    : 'btn btn-primary next-tutorial';

	                const label = document.createElement('span');
	                label.className = 'tutorial-nav-label';
	                label.textContent = kind === 'prev' ? '← 上一章' : '下一章 →';

	                const sep = document.createElement('span');
	                sep.className = 'tutorial-nav-sep';
	                sep.textContent = '：';

	                const t = document.createElement('span');
	                t.className = 'tutorial-nav-title';
	                t.textContent = title;

	                if (kind === 'prev') {
	                    btn.appendChild(label);
	                    btn.appendChild(sep);
	                    btn.appendChild(t);
	                } else {
	                    const arrow = document.createElement('span');
	                    arrow.className = 'tutorial-nav-arrow';
	                    arrow.textContent = '→';
	                    label.textContent = '下一章';
	                    btn.appendChild(label);
	                    btn.appendChild(sep);
	                    btn.appendChild(t);
	                    btn.appendChild(document.createTextNode(' '));
	                    btn.appendChild(arrow);
	                }

	                navigationContainer.appendChild(btn);
	            }

	            // 添加上一章按钮（如果存在）
		            if (prevChapter) {
		                const resolvedPrev = resolveNavPath(prevChapter);
		                if (resolvedPrev) appendNavButton('prev', resolvedPrev);
		            }

	            // 添加下一章按钮（如果存在）
		            if (nextChapter) {
		                const resolvedNext = resolveNavPath(nextChapter);
		                if (resolvedNext) appendNavButton('next', resolvedNext);
		            }

	            console.log('导航按钮已更新:', { prevChapter, nextChapter });
	        }

	        function removeDuplicateChapterProgress(container) {
	            const root = container || document.getElementById('markdown-content');
	            if (!root) return;
	            const blockquotes = root.querySelectorAll('blockquote');
	            blockquotes.forEach(function (bq) {
	                const text = String(bq.textContent || '').replace(/\s+/g, ' ').trim();
	                if (!text) return;
	                if (!text.includes('章节进度')) return;
	                if (!(text.includes('上一章') && text.includes('下一章'))) return;
	                bq.remove();
	            });
	        }

        // 将难度代码转换为中文文本
        function getDifficultyText(difficulty) {
            // 首先尝试从配置文件中获取难度映射
            if (VIEWER_DOC_CONFIG && VIEWER_DOC_CONFIG.extensions && VIEWER_DOC_CONFIG.extensions.customFields &&
                VIEWER_DOC_CONFIG.extensions.customFields.difficulty && VIEWER_DOC_CONFIG.extensions.customFields.difficulty.options) {
                const difficultyOptions = VIEWER_DOC_CONFIG.extensions.customFields.difficulty.options;
                const difficultyMap = {
                    'beginner': '初级',
                    'intermediate': '中级',
                    'advanced': '高级'
                };
                
                // 如果配置中有自定义映射，使用配置中的映射
                if (difficultyOptions.includes(difficulty)) {
                    return difficultyMap[difficulty] || difficulty;
                }
            }
            
            // 默认难度映射
            const defaultDifficultyMap = {
                'beginner': '初级',
                'intermediate': '中级',
                'advanced': '高级'
            };
            return defaultDifficultyMap[difficulty] || difficulty;
        }

        // 生成文档目录（基于标题h1-h6）
        function stripReferenceMarkerText(text) {
            return String(text || '')
                .replace(/（可引用）/g, '')
                .replace(/\(可引用\)/g, '')
                .replace(/\s+/g, ' ')
                .trim();
        }

        function stripReferenceMarkersInDom(container) {
            const root = container || document.getElementById('markdown-content');
            if (!root) return;

            function rewriteTextNodes(node) {
                const walker = document.createTreeWalker(node, NodeFilter.SHOW_TEXT);
                const nodes = [];
                while (walker.nextNode()) nodes.push(walker.currentNode);
                nodes.forEach(function (n) {
                    const next = stripReferenceMarkerText(n.nodeValue);
                    if (next !== n.nodeValue) n.nodeValue = next;
                });
            }

            const headings = root.querySelectorAll('h1, h2, h3, h4, h5, h6');
            headings.forEach(function (h) {
                rewriteTextNodes(h);
            });
        }

        function generateTableOfContents(contentElement) {
            const tableOfContents = document.getElementById('table-of-contents');
            const tocList = document.getElementById('toc-list');

            if (!tableOfContents || !tocList || !contentElement) {
                return;
            }

            const headings = contentElement.querySelectorAll('h1, h2, h3, h4, h5, h6');
            console.log(`找到 ${headings.length} 个标题用于生成目录`);

            if (headings.length === 0) {
                tableOfContents.style.display = 'none';
                return;
            }

            tocList.innerHTML = '';

            headings.forEach((heading, index) => {
                // 为没有ID的标题自动生成ID
                if (!heading.id) {
                    heading.id = `heading-${index}`;
                }

                // 创建目录项
                const li = document.createElement('li');
                const a = document.createElement('a');
                a.href = `#${heading.id}`;
                a.textContent = stripReferenceMarkerText(heading.textContent);

                // 根据标题级别设置缩进
                const level = parseInt(heading.tagName.substring(1));
                a.style.paddingLeft = `${(level - 1) * 15}px`;

                li.appendChild(a);
                tocList.appendChild(li);

                // 添加平滑滚动效果
                a.addEventListener('click', function (e) {
                    e.preventDefault();
                    const targetElement = document.getElementById(heading.id);
                    if (targetElement) {
                        // 计算滚动位置，考虑固定头部高度
                        const headerHeight = document.querySelector('.site-header').offsetHeight;
                        const targetPosition = targetElement.offsetTop - headerHeight - 20;

                        window.scrollTo({
                            top: targetPosition,
                            behavior: 'smooth'
                        });
                    }
                });
            });

            tableOfContents.style.display = 'block';
            console.log('目录生成完成');
        }

        // 检查分类是否有文档
	        function categoryHasDocuments(categoryKey) {
	            console.log(`检查分类 ${categoryKey} 是否有文档`);

            // 首先检查ALL_DOCS中是否有该分类的文档
            if (ALL_DOCS && ALL_DOCS.length > 0) {
                const docsInCategory = ALL_DOCS.filter(doc => doc.category === categoryKey);
                if (docsInCategory.length > 0) {
                    console.log(`在ALL_DOCS中找到 ${docsInCategory.length} 个 ${categoryKey} 分类的文档`);
                    return true;
                }
            }

            // 如果ALL_DOCS中没有，检查配置文件
            if (!VIEWER_DOC_CONFIG || !VIEWER_DOC_CONFIG.categories || !VIEWER_DOC_CONFIG.categories[categoryKey]) {
                console.log(`配置文件中没有找到分类 ${categoryKey}`);
                return false;
            }

            const categoryTopics = VIEWER_DOC_CONFIG.categories[categoryKey].topics || {};
            console.log(`分类 ${categoryKey} 下的主题:`, Object.keys(categoryTopics));

            // 检查该分类下是否有任何主题包含文档
            for (const topicKey in categoryTopics) {
                const topic = categoryTopics[topicKey];
                if (topic.files && topic.files.length > 0) {
                    console.log(`主题 ${topicKey} 下有 ${topic.files.length} 个文档`);
                    return true;
                }
            }

	            console.log(`分类 ${categoryKey} 没有找到任何文档`);
	            return false;
	        }

	        // Learn 风格：按 site/content/ 文件夹结构生成树形导航（桌面侧边栏 + 移动端导航共用）
	        function renderLearnFolderTreeNavigation(rootUl, options) {
	            const opts = options || {};
	            const docs = Array.isArray(opts.docs) ? opts.docs : ALL_DOCS;
	            const onLinkClick = typeof opts.onLinkClick === 'function' ? opts.onLinkClick : null;
	            const defaultCollapseDepth = Number.isFinite(opts.defaultCollapseDepth) ? opts.defaultCollapseDepth : 1;

	            if (!rootUl) return;
	            rootUl.innerHTML = '';
	            rootUl.classList.add('learn-tree-root');

	            function normalizePath(p) {
	                return String(p || '')
	                    .replace(/\\/g, '/')
	                    .replace(/^\.\//, '')
	                    .replace(/^\/+/, '')
	                    .trim();
	            }

	            function compareName(a, b) {
	                try {
	                    return String(a).localeCompare(String(b), 'zh-Hans-CN', { numeric: true, sensitivity: 'base' });
	                } catch (e) {
	                    return String(a).localeCompare(String(b));
	                }
	            }

	            function getCurrentFileParam() {
	                try {
	                    const url = new URL(window.location.href);
	                    const raw = url.searchParams.get('file') || '';
	                    return normalizePath(decodeURIComponent(raw));
	                } catch (e) {
	                    return '';
	                }
	            }

	            function getCollapsedStateOrNull(type, key) {
	                try {
	                    const storageKey = `docsViewerSidebar${type.charAt(0).toUpperCase() + type.slice(1)}${key.charAt(0).toUpperCase() + key.slice(1)}`;
	                    const state = localStorage.getItem(storageKey);
	                    if (state === null) return null;
	                    return state === 'true';
	                } catch (error) {
	                    return null;
	                }
	            }

	            const currentFilePath = normalizePath(opts.currentFilePath || getCurrentFileParam());
	            const activeAncestors = new Set();
	            if (currentFilePath) {
	                const parts = currentFilePath.split('/').filter(Boolean);
	                if (parts.length > 1) {
	                    let acc = '';
	                    for (let i = 0; i < parts.length - 1; i++) {
	                        acc = acc ? (acc + '/' + parts[i]) : parts[i];
	                        activeAncestors.add(acc);
	                    }
	                }
	            }

	            function createTreeNode(name, type) {
	                return {
	                    name: name,
	                    type: type,
	                    children: Object.create(null),
	                    doc: null
	                };
	            }

	            function buildFolderTree(list) {
	                const root = createTreeNode('', 'root');
	                (list || []).forEach(function (doc) {
	                    const rawPath = normalizePath((doc && (doc.path || doc.filename)) || '');
	                    if (!rawPath) return;
	                    const parts = rawPath.split('/').filter(Boolean);
	                    if (parts.length === 0) return;

	                    let node = root;
	                    for (let i = 0; i < parts.length; i++) {
	                        const part = parts[i];
	                        const isLeaf = i === parts.length - 1;
	                        if (isLeaf) {
	                            const fileNode = createTreeNode(part, 'file');
	                            fileNode.doc = doc;
	                            if (fileNode.doc) fileNode.doc.__normalizedPath = rawPath;
	                            node.children[part] = fileNode;
	                        } else {
	                            if (!node.children[part]) {
	                                node.children[part] = createTreeNode(part, 'folder');
	                            }
	                            node = node.children[part];
	                        }
	                    }
	                });
	                return root;
	            }

	            function setFolderCollapsedDom(folderLi, collapsed, persist) {
	                folderLi.dataset.collapsed = collapsed ? '1' : '0';
	                const toggleBtn = folderLi.querySelector(':scope > .learn-tree-row .learn-tree-toggle');
	                if (toggleBtn) toggleBtn.setAttribute('aria-expanded', collapsed ? 'false' : 'true');

	                if (persist) {
	                    const folderKey = folderLi.dataset.folderKey || '';
	                    if (folderKey) setCollapsedState('folder', folderKey, collapsed);
	                }
	            }

	            function appendTreeGuides(container, ancestorLast, isLast, depth) {
	                if (!container || !depth) return;
	                const ancestor = Array.isArray(ancestorLast) ? ancestorLast : [];
	                const ancestorCols = Math.max(depth - 1, 0);

	                for (let i = 0; i < ancestorCols; i++) {
	                    const col = document.createElement('span');
	                    col.className = 'learn-tree-guide' + (ancestor[i] ? '' : ' has-vertical');
	                    container.appendChild(col);
	                }

	                const current = document.createElement('span');
	                current.className = 'learn-tree-guide current has-vertical' + (isLast ? ' is-last' : '');
	                container.appendChild(current);
	            }

	            function renderTree(parentUl, treeNode, parentPath, depth, ancestorLast) {
	                const ancestor = Array.isArray(ancestorLast) ? ancestorLast : [];
	                const names = Object.keys(treeNode.children || {}).sort(compareName);
	                const folderNames = names.filter(function (n) { return treeNode.children[n].type === 'folder'; });
	                const fileNames = names.filter(function (n) { return treeNode.children[n].type === 'file'; });

	                folderNames.forEach(function (folderName) {
	                    const isLast = (folderName === folderNames[folderNames.length - 1]) && fileNames.length === 0;
	                    const folderNode = treeNode.children[folderName];
	                    const folderPath = parentPath ? (parentPath + '/' + folderName) : folderName;
	                    const folderKey = encodeURIComponent(folderPath);

	                    const li = document.createElement('li');
	                    li.className = 'learn-tree-folder';
	                    li.dataset.folderPath = folderPath;
	                    li.dataset.folderKey = folderKey;
	                    li.dataset.depth = String(depth);

	                    const row = document.createElement('div');
	                    row.className = 'learn-tree-row learn-tree-folder-row';

	                    const label = document.createElement('span');
	                    label.className = 'learn-tree-label';
	                    label.textContent = folderName;

	                    const guides = document.createElement('span');
	                    guides.className = 'learn-tree-guides';
	                    guides.setAttribute('aria-hidden', 'true');
	                    appendTreeGuides(guides, ancestor, isLast, depth);

                    const toggle = document.createElement('button');
                    toggle.type = 'button';
                    toggle.className = 'learn-tree-toggle';
                    toggle.setAttribute('aria-label', '展开/收起');
                    toggle.textContent = '';

	                    const item = document.createElement('span');
	                    item.className = 'learn-tree-item';
	                    item.appendChild(toggle);
	                    item.appendChild(label);

	                    row.appendChild(guides);
	                    row.appendChild(item);
	                    li.appendChild(row);

	                    const childrenUl = document.createElement('ul');
	                    childrenUl.className = 'learn-tree-children';
	                    li.appendChild(childrenUl);

	                    renderTree(childrenUl, folderNode, folderPath, depth + 1, ancestor.concat([isLast]));

	                    const storedCollapsed = getCollapsedStateOrNull('folder', folderKey);
	                    const collapsed = (storedCollapsed === null ? depth >= defaultCollapseDepth : storedCollapsed) && !activeAncestors.has(folderPath);
	                    setFolderCollapsedDom(li, collapsed, false);

	                    function onToggle(e) {
	                        if (e) e.stopPropagation();
	                        const nowCollapsed = li.dataset.collapsed !== '1';
	                        setFolderCollapsedDom(li, nowCollapsed, true);
	                    }

	                    row.addEventListener('click', onToggle);
	                    toggle.addEventListener('click', onToggle);

	                    parentUl.appendChild(li);
	                });

		                fileNames.forEach(function (fileName) {
		                    var isLast = fileName === fileNames[fileNames.length - 1];
		                    const fileNode = treeNode.children[fileName];
		                    const doc = (fileNode && fileNode.doc) || {};
		                    const docPath = normalizePath(doc.__normalizedPath || doc.path || doc.filename);
		                    if (!docPath) return;

	                    const li = document.createElement('li');
	                    li.className = 'learn-tree-file';
	                    li.dataset.depth = String(depth);

	                    const link = document.createElement('a');
	                    link.className = 'learn-tree-link';
	                    link.href = `?file=${encodeURIComponent(docPath)}`;

	                    const guides = document.createElement('span');
	                    guides.className = 'learn-tree-guides';
	                    guides.setAttribute('aria-hidden', 'true');
	                    appendTreeGuides(guides, ancestor, isLast, depth);

	                    const label = document.createElement('span');
	                    label.className = 'learn-tree-link-label';
	                    label.textContent = doc.title || fileName.replace(/\.md$/i, '');

		                    const spacer = document.createElement('span');
		                    spacer.className = 'learn-tree-toggle-spacer';
		                    spacer.setAttribute('aria-hidden', 'true');

		                    const item = document.createElement('span');
		                    item.className = 'learn-tree-item';

		                    const text = document.createElement('span');
		                    text.className = 'learn-tree-link-text';
		                    text.appendChild(label);

		                    const normalizedDocPath = normalizePath(docPath).replace(/^docs\//, '');
		                    const shouldShowDesc = normalizedDocPath.startsWith('Modder入门/');
		                    const descText = shouldShowDesc ? String(doc.description || '') : '';
		                    if (descText) {
		                        const desc = document.createElement('span');
		                        desc.className = 'learn-tree-link-desc';
		                        desc.textContent = descText;
		                        text.appendChild(desc);
		                    }

		                    item.appendChild(spacer);
		                    item.appendChild(text);

	                    link.appendChild(guides);
	                    link.appendChild(item);

	                    link.title = `${doc.author || '未知作者'} - ${doc.description || doc.title || link.textContent}`;

	                    if (currentFilePath && normalizePath(docPath) === currentFilePath) {
	                        link.classList.add('active');
	                    }

	                    if (onLinkClick) {
	                        link.addEventListener('click', function () {
	                            onLinkClick();
	                        });
	                    }

		                    li.appendChild(link);
		                    parentUl.appendChild(li);
		                });
		            }

	            const tree = buildFolderTree(docs);
	            renderTree(rootUl, tree, '', 0);
	        }

	        // 初始化分类导航
	        function initializeCategoryNavigation() {
	            console.log('=== initializeCategoryNavigation() 开始 ===');
	            const categorySidebar = document.getElementById('category-sidebar');

            if (!categorySidebar) {
                console.error('找不到分类侧边栏元素');
                return;
            }

            // 清空现有导航
            categorySidebar.innerHTML = '';

	            // 等待配置加载完成
	            if (!VIEWER_DOC_CONFIG || !ALL_DOCS || ALL_DOCS.length === 0) {
	                console.warn('文档配置尚未加载，稍后重试');
	                setTimeout(initializeCategoryNavigation, 100);
	                return;
	            }

	            // Learn 风格：按 site/content/ 文件夹结构生成树形导航
	            if (window.__FORCE_LEARN_TREE_NAV !== false) {
	                renderLearnFolderTreeNavigation(categorySidebar, { docs: ALL_DOCS, defaultCollapseDepth: 1 });
	            } else {

            console.log('DOC_CONFIG已加载，开始生成分类导航');
            console.log('ALL_DOCS数量:', ALL_DOCS.length);
            console.log('可用分类:', Object.keys(MAIN_CATEGORIES));

            // 添加分割线
            const divider = document.createElement('div');
            divider.className = 'sidebar-divider';
            categorySidebar.appendChild(divider);

            // 生成分类导航
            let visibleCategories = 0;
            Object.keys(MAIN_CATEGORIES).forEach(categoryKey => {
                const category = MAIN_CATEGORIES[categoryKey];
                console.log(`处理分类: ${categoryKey} (${category.title})`);

                // 检查该分类是否有文档，如果没有则跳过
                if (!categoryHasDocuments(categoryKey)) {
                    console.log(`跳过空分类: ${categoryKey}`);
                    return; // 跳过空分类
                }

                visibleCategories++;
                console.log(`显示分类: ${categoryKey}`);

                // 创建分类导航项
                const categoryItem = document.createElement('li');
                categoryItem.className = 'category-item';

                // 创建分类标题
                const categoryHeader = document.createElement('h4');
                categoryHeader.className = 'category-header';

                // 添加分类标题文本
                const titleSpan = document.createElement('span');
                titleSpan.className = 'category-title-text';
                titleSpan.textContent = category.title;
                categoryHeader.appendChild(titleSpan);

                // 添加展开/收起按钮
                const toggleBtn = document.createElement('button');
                toggleBtn.className = 'category-toggle';
                toggleBtn.setAttribute('aria-label', '展开/收起分类');
                toggleBtn.innerHTML = '▼';
                categoryHeader.appendChild(toggleBtn);

                categoryItem.appendChild(categoryHeader);

                // 创建主题子菜单
                const topicList = document.createElement('ul');
                topicList.className = 'topic-list';

                // 获取该分类下的所有主题
                const categoryTopics = VIEWER_DOC_CONFIG.categories[categoryKey]?.topics || {};

                if (Object.keys(categoryTopics).length > 0) {
                    Object.keys(categoryTopics).forEach(topicKey => {
                        const topic = categoryTopics[topicKey];

                        // 检查主题是否有文档，如果没有则跳过
                        if (!topic.files || topic.files.length === 0) {
                            return; // 跳过空主题
                        }

                        // 创建主题标题
                        const topicHeader = document.createElement('h5');
                        topicHeader.className = 'topic-header';

                        // 添加主题标题文本
                        const topicTitleSpan = document.createElement('span');
                        topicTitleSpan.className = 'topic-title-text';
                        topicTitleSpan.textContent = topic.title;
                        topicHeader.appendChild(topicTitleSpan);

                        // 添加展开/收起按钮
                        const topicToggleBtn = document.createElement('button');
                        topicToggleBtn.className = 'topic-toggle';
                        topicToggleBtn.setAttribute('aria-label', '展开/收起主题');
                        topicToggleBtn.innerHTML = '▼';
                        topicHeader.appendChild(topicToggleBtn);

                        // 为主题标题添加点击事件
                        topicHeader.addEventListener('click', function () {
                            toggleTopic(categoryKey, topicKey, topicHeader, topicHeader.nextElementSibling);
                        });

                        // 为主题标题的按钮添加点击事件
                        topicToggleBtn.addEventListener('click', function (e) {
                            e.stopPropagation();
                            toggleTopic(categoryKey, topicKey, topicHeader, topicHeader.nextElementSibling);
                        });

                        topicList.appendChild(topicHeader);

                        // 创建文档列表
                        const fileList = document.createElement('ul');
                        fileList.className = 'file-list';

                        // 确保topic.files存在且是数组
                        const files = topic.files || [];
                        files.forEach(file => {
                            const fileItem = document.createElement('li');
                            fileItem.className = 'file-item';

	                            const fileLink = document.createElement('a');
	                            fileLink.href = `?file=${encodeURIComponent(file.path || file.filename)}`;
	                            fileLink.textContent = file.title;
	                            fileLink.title = `${file.author || '未知'} - ${file.description || file.title}`;

                            fileItem.appendChild(fileLink);
                            fileList.appendChild(fileItem);
                        });

                        topicList.appendChild(fileList);
                    });
                }

                categoryItem.appendChild(topicList);
                categorySidebar.appendChild(categoryItem);

                // 为分类标题添加点击事件
                categoryHeader.addEventListener('click', function () {
                    toggleCategory(categoryKey, categoryHeader, topicList);
                });

                // 为分类标题的按钮添加点击事件
                toggleBtn.addEventListener('click', function (e) {
                    e.stopPropagation();
                    toggleCategory(categoryKey, categoryHeader, topicList);
                });

                // 恢复分类的展开/收起状态
                const isCollapsed = getCollapsedState('category', categoryKey);
                if (isCollapsed) {
                    topicList.classList.add('collapsed');
                    toggleBtn.classList.add('collapsed');
                    // toggleBtn.innerHTML = '▶';
                } else {
                    toggleBtn.innerHTML = '▼';
                }
            });

            // 添加分割线
            const allDocsDivider = document.createElement('div');
            allDocsDivider.className = 'sidebar-divider';
            categorySidebar.appendChild(allDocsDivider);

            // 添加"所有文档"部分
            const allDocsItem = document.createElement('li');
            allDocsItem.className = 'category-item all-docs';

            const allDocsHeader = document.createElement('h4');
            allDocsHeader.className = 'category-header';

            // 添加"所有文档"标题文本
            const allDocsTitleSpan = document.createElement('span');
            allDocsTitleSpan.className = 'category-title-text';
            allDocsTitleSpan.textContent = '所有文档';
            allDocsHeader.appendChild(allDocsTitleSpan);

            // 添加展开/收起按钮
            const allDocsToggleBtn = document.createElement('button');
            allDocsToggleBtn.className = 'category-toggle';
            allDocsToggleBtn.setAttribute('aria-label', '展开/收起所有文档');
            allDocsToggleBtn.innerHTML = '▼';
            allDocsHeader.appendChild(allDocsToggleBtn);

            allDocsItem.appendChild(allDocsHeader);

            const allDocsList = document.createElement('ul');
            allDocsList.className = 'file-list';

            // 确保ALL_DOCS存在且是数组
            const allDocs = ALL_DOCS || [];
            if (allDocs.length === 0) {
                // 如果没有文档，显示提示信息
                const noDocsItem = document.createElement('li');
                noDocsItem.className = 'no-docs';
                noDocsItem.textContent = '未找到任何文档';
                allDocsList.appendChild(noDocsItem);
            } else {
                // 按分类和排序组织文档
                const sortedDocs = [...allDocs].sort((a, b) => {
                    // 先按分类排序
                    const categoryOrderA = MAIN_CATEGORIES[a.category]?.order ?? 999;
                    const categoryOrderB = MAIN_CATEGORIES[b.category]?.order ?? 999;
                    if (categoryOrderA !== categoryOrderB) {
                        return categoryOrderA - categoryOrderB;
                    }
                    // 同一分类内按排序值排序
                    return (a.order ?? 999) - (b.order ?? 999);
                });

                sortedDocs.forEach(doc => {
                    const docItem = document.createElement('li');
                    docItem.className = 'file-item';

	                    const docLink = document.createElement('a');
	                    docLink.href = `?file=${encodeURIComponent(doc.path || doc.filename)}`;
	                    docLink.textContent = doc.title;

                    // 添加更详细的标题信息
                    const categoryTitle = MAIN_CATEGORIES[doc.category]?.title || doc.category;
                    const topicTitle = VIEWER_DOC_CONFIG.topics[doc.topic]?.title || doc.topic;
                    const pathInfo = doc.path && doc.path !== doc.filename ? ` [路径: ${doc.path}]` : '';
                    docLink.title = `${doc.author || '未知作者'} - ${doc.description || doc.title} [${categoryTitle} - ${topicTitle}]${pathInfo}`;

                    docItem.appendChild(docLink);
                    allDocsList.appendChild(docItem);
                });
            }

            allDocsItem.appendChild(allDocsList);
            categorySidebar.appendChild(allDocsItem);

            // 为"所有文档"标题添加点击事件
            allDocsHeader.addEventListener('click', function () {
                toggleAllDocs(allDocsHeader, allDocsList);
            });

            // 为"所有文档"标题的按钮添加点击事件
            allDocsToggleBtn.addEventListener('click', function (e) {
                e.stopPropagation();
                toggleAllDocs(allDocsHeader, allDocsList);
            });

            // 恢复"所有文档"的展开/收起状态
	            const isAllDocsCollapsed = getCollapsedState('all-docs', 'all-docs');
	            if (isAllDocsCollapsed) {
	                allDocsList.classList.add('collapsed');
	                allDocsToggleBtn.classList.add('collapsed');
	                // allDocsToggleBtn.innerHTML = '▶';
	            } else {
	                allDocsToggleBtn.innerHTML = '▼';
	            }
	            }
	        }

        // 展开/收起分类
        function toggleCategory(categoryKey, categoryHeader, topicList) {
            const isCollapsed = topicList.classList.contains('collapsed');
            const toggleBtn = categoryHeader.querySelector('.category-toggle');

            if (isCollapsed) {
                // 展开
                topicList.classList.remove('collapsed');
                toggleBtn.classList.remove('collapsed');
                toggleBtn.innerHTML = '▼';
                setCollapsedState('category', categoryKey, false);
            } else {
                // 收起
                topicList.classList.add('collapsed');
                toggleBtn.classList.add('collapsed');
                // toggleBtn.innerHTML = '▶';
                setCollapsedState('category', categoryKey, true);
            }
        }

        // 展开/收起主题
        function toggleTopic(categoryKey, topicKey, topicHeader, fileList) {
            const isCollapsed = fileList.classList.contains('collapsed');
            const toggleBtnArray = topicHeader.querySelectorAll('.topic-toggle');

            for (let i = 0; i < toggleBtnArray.length; i++) {
                const toggleBtn = toggleBtnArray[i];
                if (isCollapsed) {
                    // 展开
                    fileList.classList.remove('collapsed');
                    toggleBtn.classList.remove('collapsed');
                    toggleBtn.innerHTML = '▼';  // 添加这行
                    setCollapsedState('topic', `${categoryKey}-${topicKey}`, false);
                } else {
                    // 收起
                    fileList.classList.add('collapsed');
                    toggleBtn.classList.add('collapsed');
                    // toggleBtn.innerHTML = '▶';  // 添加这行
                    setCollapsedState('topic', `${categoryKey}-${topicKey}`, true);
                }
            }
        }

        // 展开/收起"所有文档"
        function toggleAllDocs(allDocsHeader, allDocsList) {
            const isCollapsed = allDocsList.classList.contains('collapsed');
            const toggleBtn = allDocsHeader.querySelector('.category-toggle');

            if (isCollapsed) {
                // 展开
                allDocsList.classList.remove('collapsed');
                toggleBtn.classList.remove('collapsed');
                toggleBtn.innerHTML = '▼';  // 添加这行
                setCollapsedState('all-docs', 'all-docs', false);
            } else {
                // 收起
                allDocsList.classList.add('collapsed');
                toggleBtn.classList.add('collapsed');
                // toggleBtn.innerHTML = '▶';  // 添加这行
                setCollapsedState('all-docs', 'all-docs', true);
            }
        }



        // 从localStorage获取展开/收起状态
        function getCollapsedState(type, key) {
            try {
                const storageKey = `docsViewerSidebar${type.charAt(0).toUpperCase() + type.slice(1)}${key.charAt(0).toUpperCase() + key.slice(1)}`;
                const state = localStorage.getItem(storageKey);
                return state === 'true';
            } catch (error) {
                console.warn('无法从localStorage获取展开/收起状态:', error);
                return false;
            }
        }

        // 保存展开/收起状态到localStorage
        function setCollapsedState(type, key, isCollapsed) {
            try {
                const storageKey = `docsViewerSidebar${type.charAt(0).toUpperCase() + type.slice(1)}${key.charAt(0).toUpperCase() + key.slice(1)}`;
                localStorage.setItem(storageKey, isCollapsed.toString());
            } catch (error) {
                console.warn('无法保存展开/收起状态到localStorage:', error);
            }
        }

        // 初始化下拉菜单
        function initializeDropdownMenu() {
            const dropdownToggle = document.querySelector('.dropdown-toggle');
            const dropdownMenu = document.querySelector('.dropdown-menu');

            if (!dropdownToggle || !dropdownMenu) return;

            // 点击切换下拉菜单
            dropdownToggle.addEventListener('click', function (e) {
                e.preventDefault();
                dropdownMenu.classList.toggle('show');
            });

            // 点击其他地方关闭下拉菜单
            document.addEventListener('click', function (e) {
                if (!dropdownToggle.contains(e.target) && !dropdownMenu.contains(e.target)) {
                    dropdownMenu.classList.remove('show');
                }
            });
        }

        // 更新当前分类的文档列表
		        function updateCurrentCategoryDocs(filePath) {
	            const currentCategoryTitle = document.getElementById('current-category-title');
	            const currentCategoryDocs = document.getElementById('current-category-docs');

            if (!currentCategoryTitle || !currentCategoryDocs) return;

            // 等待配置加载完成
            if (!VIEWER_DOC_CONFIG || !ALL_DOCS || ALL_DOCS.length === 0) {
                console.warn('文档配置尚未加载，稍后重试');
                setTimeout(() => updateCurrentCategoryDocs(filePath), 100);
                return;
            }

	            function normalizePath(p) {
	                return String(p || '')
	                    .replace(/\\/g, '/')
	                    .replace(/^\.\//, '')
	                    .replace(/^\/+/, '')
	                    .trim();
	            }

	            function getFolderOfPath(p) {
	                const parts = normalizePath(p).split('/').filter(Boolean);
	                if (parts.length <= 1) return '';
	                return parts.slice(0, -1).join('/');
	            }

	            function compareName(a, b) {
	                try {
	                    return String(a).localeCompare(String(b), 'zh-Hans-CN', { numeric: true, sensitivity: 'base' });
	                } catch (e) {
	                    return String(a).localeCompare(String(b));
	                }
	            }

	            const normalizedFilePath = normalizePath(filePath);

		            // 查找当前文档信息（支持 filename 或 path）
		            const currentDoc = ALL_DOCS.find(doc => {
		                const p = normalizePath(doc.path || doc.filename);
		                return p === normalizedFilePath;
		            });

	            if (!currentDoc) {
	                // 如果找不到文档，显示所有文档
	                currentCategoryTitle.textContent = '所有文档';
	                currentCategoryDocs.innerHTML = '';

	                // 按路径 + 标题组织文档（与文件夹树一致）
	                const sortedDocs = [...ALL_DOCS].sort((a, b) => {
	                    const ap = normalizePath(a.path || a.filename);
	                    const bp = normalizePath(b.path || b.filename);
	                    if (ap !== bp) return compareName(ap, bp);
	                    return compareName(a.title || '', b.title || '');
	                });

		                sortedDocs.forEach(doc => {
		                    const li = document.createElement('li');
		                    const link = document.createElement('a');
			                    link.href = `?file=${encodeURIComponent(normalizePath(doc.path || doc.filename))}`;

			                    const titleSpan = document.createElement('span');
			                    titleSpan.className = 'sidebar-doc-title';
			                    titleSpan.textContent = doc.title;
			                    link.appendChild(titleSpan);

			                    const docPath = normalizePath(doc.path || doc.filename);
			                    const shouldShowDesc = docPath.replace(/^docs\//, '').startsWith('Modder入门/');
			                    const descText = shouldShowDesc ? String(doc.description || '') : '';
			                    if (descText) {
			                        const descSpan = document.createElement('span');
			                        descSpan.className = 'sidebar-doc-desc';
			                        descSpan.textContent = descText;
			                        link.appendChild(descSpan);
			                    }

			                    link.title = `${doc.author || '未知作者'} - ${doc.description || doc.title}`;

			                    if (docPath === normalizedFilePath) {
			                        link.classList.add('active');
			                    }

	                    li.appendChild(link);
	                    currentCategoryDocs.appendChild(li);
                });

                return;
            }

	            // Learn 风格：显示“当前文件夹”的同级文档
	            const currentDocPath = normalizePath(currentDoc.path || currentDoc.filename);
	            const currentFolder = getFolderOfPath(currentDocPath);
	            const folderLabel = currentFolder ? currentFolder : '根目录';
	            currentCategoryTitle.textContent = `当前文件夹：${folderLabel}`;

	            // 清空现有列表
	            currentCategoryDocs.innerHTML = '';

	            const siblingDocs = ALL_DOCS.filter(function (doc) {
	                const p = normalizePath(doc.path || doc.filename);
	                return getFolderOfPath(p) === currentFolder;
	            }).sort(function (a, b) {
	                const orderA = a.order ?? 999;
	                const orderB = b.order ?? 999;
	                if (orderA !== orderB) return orderA - orderB;
	                return compareName(a.title || '', b.title || '');
	            });

	            if (siblingDocs.length === 0) {
	                const li = document.createElement('li');
	                li.textContent = '本文件夹暂无其它文档';
	                currentCategoryDocs.appendChild(li);
	                return;
	            }

		            siblingDocs.forEach(doc => {
		                const li = document.createElement('li');
		                const link = document.createElement('a');
		                const docPath = normalizePath(doc.path || doc.filename);
		                link.href = `?file=${encodeURIComponent(docPath)}`;

		                const titleSpan = document.createElement('span');
		                titleSpan.className = 'sidebar-doc-title';
		                titleSpan.textContent = doc.title;
		                link.appendChild(titleSpan);

		                const shouldShowDesc = docPath.replace(/^docs\//, '').startsWith('Modder入门/');
		                const descText = shouldShowDesc ? String(doc.description || '') : '';
		                if (descText) {
		                    const descSpan = document.createElement('span');
		                    descSpan.className = 'sidebar-doc-desc';
		                    descSpan.textContent = descText;
		                    link.appendChild(descSpan);
		                }

		                link.title = `${doc.author || '未知作者'} - ${doc.description || doc.title}`;

	                if (docPath === normalizedFilePath) {
	                    link.classList.add('active');
	                }

	                li.appendChild(link);
	                currentCategoryDocs.appendChild(li);
	            });
	        }

        // 初始化手机端导航
	        function initializeMobileNavigation() {
            const mobileNavToggle = document.getElementById('mobile-nav-toggle');
            const mobileNavOverlay = document.getElementById('mobile-nav-overlay');
            const mobileNavClose = document.getElementById('mobile-nav-close');
            const mobileNavBack = document.getElementById('mobile-nav-back');
            const mobileNavSections = document.getElementById('mobile-nav-sections');

            if (!mobileNavToggle || !mobileNavOverlay || !mobileNavClose || !mobileNavBack || !mobileNavSections) {
                return;
            }

            mobileNavToggle.setAttribute('aria-expanded', 'false');
            mobileNavOverlay.setAttribute('aria-hidden', 'true');

	            let lastFocusedElement = null;
	            let previousBodyOverflow = '';
	            let previousHtmlOverflow = '';

            function getFocusableElements(container) {
                const selectors = [
                    'a[href]',
                    'button:not([disabled])',
                    'input:not([disabled])',
                    'select:not([disabled])',
                    'textarea:not([disabled])',
                    '[tabindex]:not([tabindex="-1"])'
                ];
                return Array.from(container.querySelectorAll(selectors.join(','))).filter(el => {
                    return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
                });
            }

            function trapFocus(event) {
                if (!mobileNavOverlay.classList.contains('active')) return;
                if (event.key !== 'Tab') return;

                const focusable = getFocusableElements(mobileNavOverlay);
                if (focusable.length === 0) return;

                const first = focusable[0];
                const last = focusable[focusable.length - 1];
                const active = document.activeElement;

                if (event.shiftKey) {
                    if (active === first || !mobileNavOverlay.contains(active)) {
                        event.preventDefault();
                        last.focus();
                    }
                } else {
                    if (active === last) {
                        event.preventDefault();
                        first.focus();
                    }
                }
            }

            // 检查是否为移动设备
            function isMobileDevice() {
                return window.innerWidth <= 768;
            }

            // 设置初始显示状态
            updateMobileNavVisibility();

            // 确保在移动设备上也能正常工作
            if (isMobileDevice()) {
                console.log('检测到移动设备，初始化手机端导航');
            }

            // 生成手机端导航内容
            function generateMobileNavContent() {
                if (!VIEWER_DOC_CONFIG || ALL_DOCS.length === 0) {
                    console.warn('文档配置尚未加载，稍后重试');
                    setTimeout(generateMobileNavContent, 100);
                    return;
                }

	                mobileNavSections.innerHTML = '';

	                // Learn 风格：移动端也使用文件夹树导航（与桌面侧边栏一致）
	                const treeRoot = document.createElement('ul');
	                mobileNavSections.appendChild(treeRoot);
	                renderLearnFolderTreeNavigation(treeRoot, {
	                    docs: ALL_DOCS,
	                    defaultCollapseDepth: 1,
	                    onLinkClick: closeMobileNav
	                });
	            }

	            // 打开手机端导航
		            function openMobileNav() {
		                lastFocusedElement = document.activeElement;
		                previousBodyOverflow = document.body.style.overflow || '';
		                previousHtmlOverflow = document.documentElement.style.overflow || '';
		                mobileNavOverlay.classList.add('active');
		                // 防止背景滚动（移动端需要同时锁定 html/body 才更稳定）
		                document.body.style.overflow = 'hidden';
		                document.documentElement.style.overflow = 'hidden';
		                generateMobileNavContent();
		                mobileNavToggle.setAttribute('aria-expanded', 'true');
		                mobileNavOverlay.setAttribute('aria-hidden', 'false');
		                mobileNavClose.focus();
		                document.addEventListener('keydown', trapFocus, true);
		            }

	            // 关闭手机端导航
	            function closeMobileNav() {
	                mobileNavOverlay.classList.remove('active');
	                document.body.style.overflow = previousBodyOverflow; // 恢复滚动
	                document.documentElement.style.overflow = previousHtmlOverflow;
	                mobileNavToggle.setAttribute('aria-expanded', 'false');
	                mobileNavOverlay.setAttribute('aria-hidden', 'true');
	                document.removeEventListener('keydown', trapFocus, true);
	                if (lastFocusedElement && typeof lastFocusedElement.focus === 'function') {
	                    lastFocusedElement.focus();
                } else {
                    mobileNavToggle.focus();
                }
            }

            // 绑定事件监听器
            mobileNavToggle.addEventListener('click', openMobileNav);
            mobileNavClose.addEventListener('click', closeMobileNav);
            mobileNavBack.addEventListener('click', closeMobileNav);

            document.addEventListener('keydown', function (event) {
                if (event.key === 'Escape' && mobileNavOverlay.classList.contains('active')) {
                    closeMobileNav();
                }
            });

            // 点击覆盖层背景关闭导航（除了返回区域）
            mobileNavOverlay.addEventListener('click', function (e) {
                if (e.target === mobileNavOverlay) {
                    closeMobileNav();
                }
            });

            // 更新手机端导航可见性
            function updateMobileNavVisibility() {
                if (isMobileDevice()) {
                    mobileNavToggle.style.display = 'flex';
                } else {
                    mobileNavToggle.style.display = 'none';
                    closeMobileNav(); // 在非移动设备上关闭导航
                }
            }

            // 监听窗口大小变化
            window.addEventListener('resize', updateMobileNavVisibility);
        }

        function shouldRenderMobileTopicToggle(categoryKey, topicCount) {
            return topicCount > 1;
        }

        // 移动端分类展开/收起功能
        function toggleMobileCategory(categoryKey, categoryDiv, toggleBtn) {
            const isCollapsed = categoryDiv.classList.contains('collapsed');

            if (isCollapsed) {
                // 展开
                categoryDiv.classList.remove('collapsed');
                toggleBtn.classList.remove('collapsed');
                toggleBtn.innerHTML = '▼';
                setMobileCollapsedState('category', categoryKey, false);
            } else {
                // 收起
                categoryDiv.classList.add('collapsed');
                toggleBtn.classList.add('collapsed');
                // toggleBtn.innerHTML = '▶';
                setMobileCollapsedState('category', categoryKey, true);
            }
        }

        // 移动端主题展开/收起功能
        function toggleMobileTopic(categoryKey, topicKey, topicDiv, toggleBtn) {
            const isCollapsed = topicDiv.classList.contains('collapsed');

            if (isCollapsed) {
                // 展开
                topicDiv.classList.remove('collapsed');
                if (toggleBtn) {
                    toggleBtn.classList.remove('collapsed');
                    toggleBtn.innerHTML = '▼';
                }
                setMobileCollapsedState('topic', `${categoryKey}-${topicKey}`, false);
            } else {
                // 收起
                topicDiv.classList.add('collapsed');
                if (toggleBtn) {
                    toggleBtn.classList.add('collapsed');
                }
                // toggleBtn.innerHTML = '▶';
                setMobileCollapsedState('topic', `${categoryKey}-${topicKey}`, true);
            }
        }

        // 移动端"所有文档"展开/收起功能
        function toggleMobileAllDocs(allDocsDiv, toggleBtn) {
            const isCollapsed = allDocsDiv.classList.contains('collapsed');

            if (isCollapsed) {
                // 展开
                allDocsDiv.classList.remove('collapsed');
                toggleBtn.classList.remove('collapsed');
                toggleBtn.innerHTML = '▼';
                setMobileCollapsedState('all-docs', 'all-docs', false);
            } else {
                // 收起
                allDocsDiv.classList.add('collapsed');
                toggleBtn.classList.add('collapsed');
                // toggleBtn.innerHTML = '▶';
                setMobileCollapsedState('all-docs', 'all-docs', true);
            }
        }

        // 从localStorage获取移动端展开/收起状态
        function getMobileCollapsedState(type, key) {
            try {
                const storageKey = `mobileNav${type.charAt(0).toUpperCase() + type.slice(1)}${key.charAt(0).toUpperCase() + key.slice(1)}`;
                const state = localStorage.getItem(storageKey);
                return state === 'true';
            } catch (error) {
                console.warn('无法从localStorage获取移动端展开/收起状态:', error);
                return false;
            }
        }

        // 保存移动端展开/收起状态到localStorage
        function setMobileCollapsedState(type, key, isCollapsed) {
            try {
                const storageKey = `mobileNav${type.charAt(0).toUpperCase() + type.slice(1)}${key.charAt(0).toUpperCase() + key.slice(1)}`;
                localStorage.setItem(storageKey, isCollapsed.toString());
            } catch (error) {
                console.warn('无法保存移动端展开/收起状态到localStorage:', error);
            }
        }

        // 初始化侧边栏滚动功能
        function initializeSidebarScrolling() {
            const sidebar = document.querySelector('.sidebar');
            if (!sidebar) return;

            let isScrolling = false;
            let scrollTimeout;

            // 滚动事件处理
            sidebar.addEventListener('scroll', function () {
                if (!isScrolling) {
                    sidebar.classList.add('scrolling');
                    isScrolling = true;
                }

                // 清除之前的超时
                clearTimeout(scrollTimeout);

                // 设置新的超时，在停止滚动后移除类
                scrollTimeout = setTimeout(function () {
                    sidebar.classList.remove('scrolling');
                    isScrolling = false;
                }, 150);
            });

            // 为侧边栏内的链接添加平滑滚动效果
            const sidebarLinks = sidebar.querySelectorAll('a[href^="#"]');
            sidebarLinks.forEach(link => {
                link.addEventListener('click', function (e) {
                    e.preventDefault();
                    const targetId = this.getAttribute('href').substring(1);
                    const targetElement = document.getElementById(targetId);

                    if (targetElement) {
                        // 计算滚动位置，考虑固定头部高度
                        const headerHeight = document.querySelector('.site-header').offsetHeight;
                        const targetPosition = targetElement.offsetTop - headerHeight - 20;

                        window.scrollTo({
                            top: targetPosition,
                            behavior: 'smooth'
                        });
                    }
                });
            });

            // 添加键盘导航支持
            sidebar.addEventListener('keydown', function (e) {
                // 上下箭头键滚动
                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    sidebar.scrollTop -= 30;
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    sidebar.scrollTop += 30;
                }
                // Home键滚动到顶部
                else if (e.key === 'Home') {
                    e.preventDefault();
                    sidebar.scrollTop = 0;
                }
                // End键滚动到底部
                else if (e.key === 'End') {
                    e.preventDefault();
                    sidebar.scrollTop = sidebar.scrollHeight;
                }
            });

            // 确保侧边栏可以获得焦点以支持键盘导航
            sidebar.setAttribute('tabindex', '0');

            // 添加滚动指示器（可选）
            addScrollIndicator(sidebar);
        }

        // 添加滚动指示器
        function addScrollIndicator(sidebar) {
            // 检查是否需要滚动指示器
            function checkScrollNeeded() {
                const needsScroll = sidebar.scrollHeight > sidebar.clientHeight;

                // 如果需要滚动且没有指示器，则添加一个
                if (needsScroll && !sidebar.querySelector('.scroll-indicator')) {
                    const indicator = document.createElement('div');
                    indicator.className = 'scroll-indicator';
                    indicator.innerHTML = '↓';
                    indicator.style.cssText = `
                        position: absolute;
                        bottom: 10px;
                        right: 10px;
	                        background: rgba(40, 167, 69, 0.7);
                        color: white;
                        width: 24px;
                        height: 24px;
                        border-radius: 50%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 12px;
                        opacity: 0.7;
                        pointer-events: none;
                        transition: opacity 0.3s ease;
                        z-index: 10;
                    `;

                    // 将指示器添加到侧边栏内容区域
                    const sidebarContent = sidebar.querySelector('.sidebar-content');
                    if (sidebarContent) {
                        sidebarContent.style.position = 'relative';
                        sidebarContent.appendChild(indicator);

                        // 监听滚动，当用户开始滚动时隐藏指示器
                        let hideTimeout;
                        sidebar.addEventListener('scroll', function () {
                            indicator.style.opacity = '0';

                            // 清除之前的超时
                            clearTimeout(hideTimeout);

                            // 如果滚动到顶部，重新显示指示器
                            if (sidebar.scrollTop <= 10) {
                                hideTimeout = setTimeout(() => {
                                    indicator.style.opacity = '0.7';
                                }, 1000);
                            }
                        });
                    }
                }
                // 如果不需要滚动且有指示器，则移除它
                else if (!needsScroll) {
                    const indicator = sidebar.querySelector('.scroll-indicator');
                    if (indicator) {
                        indicator.remove();
                    }
                }
            }

            // 初始检查
            checkScrollNeeded();

            // 窗口大小变化时重新检查
            window.addEventListener('resize', checkScrollNeeded);

            // 内容变化时重新检查（使用MutationObserver）
            const observer = new MutationObserver(checkScrollNeeded);
            observer.observe(sidebar, { childList: true, subtree: true });
        }
    </script>
    <script>
        (function () {
            'use strict';

            const VIEWER_AUTH_WORKER_ORIGIN = 'https://greenhome-pr.3577415213.workers.dev';
            const VIEWER_AI_ENDPOINT = 'https://jjktycjjcsbulyunqlqe.supabase.co/functions/v1/ai-chat';
            const VIEWER_AI_COOLDOWN_SECONDS = 60;
            const VIEWER_AI_COOLDOWN_STORAGE_KEY = 'viewerAiCooldownUntil.v1';
            const VIEWER_AI_FAB_POSITION_STORAGE_KEY = 'viewerAiFabPosition.v1';
            const VIEWER_AUTH_TOKEN_KEY = 'articleStudioOAuthToken.v1';
            const VIEWER_AUTH_USER_KEY = 'articleStudioOAuthUser.v1';

            const dom = {
                root: document.getElementById('viewer-ai-root'),
                fab: document.getElementById('viewer-ai-fab'),
                panel: document.getElementById('viewer-ai-panel'),
                close: document.getElementById('viewer-ai-close'),
                endpoint: document.getElementById('viewer-ai-endpoint'),
                input: document.getElementById('viewer-ai-input'),
                send: document.getElementById('viewer-ai-send'),
                cooldown: document.getElementById('viewer-ai-cooldown'),
                output: document.getElementById('viewer-ai-output'),
                login: document.getElementById('viewer-ai-login'),
                logout: document.getElementById('viewer-ai-logout'),
                authStatus: document.getElementById('viewer-ai-auth-status')
            };

            if (!dom.root || !dom.fab || !dom.panel) {
                return;
            }

            const state = {
                authToken: '',
                githubUser: '',
                aiBusy: false,
                aiCooldownUntil: 0,
                fabDragging: false
            };

            let cooldownTimer = 0;

            function parsePx(value) {
                if (value == null) return null;
                const parsed = Number.parseFloat(String(value));
                if (!Number.isFinite(parsed)) return null;
                return parsed;
            }

            function clampFabPosition(left, top) {
                const viewportW = window.innerWidth || document.documentElement.clientWidth || 0;
                const viewportH = window.innerHeight || document.documentElement.clientHeight || 0;
                const rootRect = dom.root.getBoundingClientRect();
                const fallbackFabRect = dom.fab.getBoundingClientRect();
                const rootWidth = Math.max(rootRect.width || 0, fallbackFabRect.width || 0);
                const rootHeight = Math.max(rootRect.height || 0, fallbackFabRect.height || 0);
                const maxLeft = Math.max(0, viewportW - rootWidth);
                const maxTop = Math.max(0, viewportH - rootHeight);

                const clampedTop = Math.max(0, Math.min(Number(top || 0), maxTop));
                const clampedLeft = Math.max(0, Math.min(Number(left || 0), maxLeft));

                return {
                    left: clampedLeft,
                    top: clampedTop
                };
            }

            function updatePanelAlignByFabPosition() {
                const viewportW = window.innerWidth || document.documentElement.clientWidth || 0;
                const fabRect = dom.fab.getBoundingClientRect();
                const centerX = fabRect.left + fabRect.width / 2;
                const align = centerX < viewportW / 2 ? 'left' : 'right';
                dom.root.setAttribute('data-panel-align', align);
            }

            function applyFabPosition(left, top, persist) {
                const clamped = clampFabPosition(left, top);
                dom.root.style.left = `${Math.round(clamped.left)}px`;
                dom.root.style.top = `${Math.round(clamped.top)}px`;
                dom.root.style.right = 'auto';
                dom.root.style.bottom = 'auto';

                updatePanelAlignByFabPosition();

                if (persist) {
                    try {
                        localStorage.setItem(VIEWER_AI_FAB_POSITION_STORAGE_KEY, JSON.stringify({
                            left: Math.round(clamped.left),
                            top: Math.round(clamped.top)
                        }));
                    } catch (_) {
                        // ignore local storage failures
                    }
                }
            }

            function setFabDefaultPosition() {
                const viewportW = window.innerWidth || document.documentElement.clientWidth || 0;
                const viewportH = window.innerHeight || document.documentElement.clientHeight || 0;
                const fabRect = dom.fab.getBoundingClientRect();
                const left = Math.max(0, viewportW - fabRect.width - 18);
                const top = Math.max(0, viewportH - fabRect.height - 20);
                applyFabPosition(left, top, false);
            }

            function snapFabToEdge(left, top, persist) {
                const viewportW = window.innerWidth || document.documentElement.clientWidth || 0;
                const safeLeft = parsePx(left);
                const safeTop = parsePx(top);

                if (safeLeft == null || safeTop == null) {
                    return;
                }

                const rootRect = dom.root.getBoundingClientRect();
                const fallbackFabRect = dom.fab.getBoundingClientRect();
                const rootWidth = Math.max(rootRect.width || 0, fallbackFabRect.width || 0);
                const maxLeft = Math.max(0, viewportW - rootWidth);
                const midpoint = maxLeft / 2;
                const clamped = clampFabPosition(safeLeft, safeTop);
                const targetLeft = clamped.left <= midpoint ? 0 : maxLeft;

                applyFabPosition(targetLeft, clamped.top, !!persist);
            }

            function restoreFabPosition() {
                try {
                    const raw = localStorage.getItem(VIEWER_AI_FAB_POSITION_STORAGE_KEY);
                    if (!raw) {
                        setFabDefaultPosition();
                        return;
                    }

                    const parsed = JSON.parse(raw);
                    if (!parsed || typeof parsed !== 'object') {
                        setFabDefaultPosition();
                        return;
                    }

                    const left = parsePx(parsed.left);
                    const top = parsePx(parsed.top);
                    if (left == null || top == null) {
                        setFabDefaultPosition();
                        return;
                    }

                    snapFabToEdge(left, top, false);
                } catch (_) {
                    setFabDefaultPosition();
                }
            }

            function setupFabDrag() {
                if (!dom.fab) return;

                let pointerId = null;
                let startX = 0;
                let startY = 0;
                let originLeft = 0;
                let originTop = 0;
                let moved = false;

                function onPointerMove(event) {
                    if (pointerId == null || event.pointerId !== pointerId) return;

                    const dx = event.clientX - startX;
                    const dy = event.clientY - startY;

                    if (!moved && (Math.abs(dx) > 3 || Math.abs(dy) > 3)) {
                        moved = true;
                        state.fabDragging = true;
                        dom.fab.classList.add('viewer-ai-fab--dragging');
                    }

                    if (!moved) return;

                    event.preventDefault();
                    applyFabPosition(originLeft + dx, originTop + dy, false);
                }

                function endDrag(event) {
                    if (pointerId == null || event.pointerId !== pointerId) return;

                    if (moved) {
                        const left = parsePx(dom.root.style.left);
                        const top = parsePx(dom.root.style.top);
                        if (left != null && top != null) {
                            snapFabToEdge(left, top, true);
                        }
                    }

                    pointerId = null;
                    moved = false;
                    state.fabDragging = false;
                    dom.fab.classList.remove('viewer-ai-fab--dragging');

                    window.removeEventListener('pointermove', onPointerMove);
                    window.removeEventListener('pointerup', endDrag);
                    window.removeEventListener('pointercancel', endDrag);
                }

                dom.fab.addEventListener('pointerdown', function (event) {
                    if (event.button !== 0) return;

                    pointerId = event.pointerId;
                    moved = false;
                    startX = event.clientX;
                    startY = event.clientY;

                    const currentLeft = parsePx(dom.root.style.left);
                    const currentTop = parsePx(dom.root.style.top);
                    originLeft = currentLeft == null ? dom.root.getBoundingClientRect().left : currentLeft;
                    originTop = currentTop == null ? dom.root.getBoundingClientRect().top : currentTop;

                    if (typeof dom.fab.setPointerCapture === 'function') {
                        dom.fab.setPointerCapture(pointerId);
                    }

                    window.addEventListener('pointermove', onPointerMove, { passive: false });
                    window.addEventListener('pointerup', endDrag);
                    window.addEventListener('pointercancel', endDrag);
                });
            }

            function isStudioEmbedModeEnabled() {
                const attrFlag = document.documentElement.getAttribute('data-studio-embed') === '1';
                if (attrFlag) return true;

                try {
                    const url = new URL(window.location.href);
                    const flag = String(url.searchParams.get('studio_embed') || '').trim().toLowerCase();
                    const requested = flag === '1' || flag === 'true' || flag === 'yes';
                    if (requested && window.parent !== window) return true;
                } catch (_) {
                    // ignore url parse errors
                }

                return false;
            }

            function normalizeAiApiUrl(input) {
                let value = String(input || '').trim();
                if (!value) return '';

                if (!/^https?:\/\//i.test(value)) {
                    value = `https://${value}`;
                }

                return value.replace(/\/+$/, '');
            }

            function renderAiMarkdown(markdownText) {
                const source = String(markdownText || '').trim();
                if (!source) return '等待提问...';

                if (!window.marked || typeof window.marked.parse !== 'function') {
                    return source
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/\n/g, '<br>');
                }

                try {
                    return window.marked.parse(source);
                } catch (_) {
                    return source
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/\n/g, '<br>');
                }
            }

            function setAiOutput(text, options) {
                if (!dom.output) return;
                const opts = options && typeof options === 'object' ? options : {};
                const useMarkdown = !!opts.markdown;

                if (useMarkdown) {
                    dom.output.classList.add('viewer-ai-output--markdown');
                    dom.output.innerHTML = renderAiMarkdown(text);
                    return;
                }

                dom.output.classList.remove('viewer-ai-output--markdown');
                dom.output.textContent = String(text || '') || '等待提问...';
            }

            function getCurrentArticleContextForAi(maxChars) {
                const limit = Number.isFinite(Number(maxChars))
                    ? Math.max(400, Math.floor(Number(maxChars)))
                    : 2400;
                const titleEl = document.getElementById('doc-title');
                const articleTitle = titleEl ? String(titleEl.textContent || '').trim() : '';
                const articlePath = String(CURRENT_DOC_PATH || '').trim();

                let articleText = '';
                const markdownEl = document.getElementById('markdown-content');
                if (markdownEl) {
                    articleText = String(markdownEl.textContent || '').replace(/\s+/g, ' ').trim();
                }

                if (articleText.length > limit) {
                    articleText = `${articleText.slice(0, limit)}...`;
                }

                return {
                    title: articleTitle || '未命名文章',
                    path: articlePath || '未知路径',
                    text: articleText || '当前文章正文暂不可用'
                };
            }

            function buildTutorialIndexRecords() {
                if (!Array.isArray(ALL_DOCS) || ALL_DOCS.length === 0) {
                    return [];
                }

                const records = [];
                for (const doc of ALL_DOCS) {
                    if (!doc || typeof doc !== 'object') continue;
                    const path = String(doc.path || doc.filename || '').trim();
                    if (!path) continue;

                    records.push({
                        path: path,
                        href: `viewer.html?file=${encodeURIComponent(path)}`,
                        title: String(doc.title || doc.filename || path).trim() || path,
                        category: String(doc.category || '未分类').trim() || '未分类',
                        description: String(doc.description || '').replace(/\s+/g, ' ').trim(),
                        order: Number(doc.order || 9999)
                    });
                }

                records.sort(function (left, right) {
                    const categoryCompare = left.category.localeCompare(right.category, 'zh-Hans-CN');
                    if (categoryCompare !== 0) return categoryCompare;

                    const orderCompare = left.order - right.order;
                    if (orderCompare !== 0) return orderCompare;

                    return left.title.localeCompare(right.title, 'zh-Hans-CN');
                });

                return records;
            }

            function collectIndexIntentTokens(prompt) {
                const text = String(prompt || '').toLowerCase();
                if (!text) return [];

                const groups = [
                    { label: '入门', keys: ['入门', '新手', '基础', '从零', '刚开始', '初学'] },
                    { label: 'C#', keys: ['c#', 'csharp', '语法', '变量', '函数', '类'] },
                    { label: 'tModLoader', keys: ['tmodloader', '模组', 'mod', '环境', '安装'] },
                    { label: 'UI', keys: ['ui', '界面', '按钮', '面板'] },
                    { label: '网络', keys: ['网络', '联机', '同步', '多人'] },
                    { label: '物品', keys: ['物品', '武器', '掉落', '装备'] },
                    { label: 'NPC', keys: ['npc', '怪物', '敌怪', '生物群系'] }
                ];

                const tokens = [];
                groups.forEach(function (group) {
                    if (group.keys.some(function (key) { return text.includes(String(key).toLowerCase()); })) {
                        tokens.push(group.label);
                    }
                });

                const asciiWords = text
                    .replace(/[^a-z0-9#.+\-\s]/g, ' ')
                    .split(/\s+/)
                    .map(function (item) { return item.trim(); })
                    .filter(function (item) { return item.length >= 2; })
                    .slice(0, 8);

                asciiWords.forEach(function (word) {
                    if (!tokens.includes(word)) {
                        tokens.push(word);
                    }
                });

                return tokens.slice(0, 10);
            }

            function buildLocalIndexRecommendationMarkdown(prompt) {
                const records = buildTutorialIndexRecords();
                if (records.length === 0) {
                    return [
                        '> AI 生成内容可能不准确，请以教程原文为准。',
                        '',
                        '当前无法读取教程索引，请稍后重试。'
                    ].join('\n');
                }

                const promptText = String(prompt || '').trim();
                const tokens = collectIndexIntentTokens(promptText);
                const currentPath = String(CURRENT_DOC_PATH || '').trim().toLowerCase();

                let currentCategory = '';
                if (currentPath) {
                    const currentRecord = records.find(function (item) {
                        return item.path.toLowerCase() === currentPath;
                    });
                    currentCategory = currentRecord ? currentRecord.category : '';
                }

                const scored = records.map(function (item) {
                    const searchable = `${item.title} ${item.category} ${item.description} ${item.path}`.toLowerCase();
                    const matched = [];
                    let score = 0;

                    if (currentCategory && item.category === currentCategory) {
                        score += 6;
                    }

                    if (currentPath && item.path.toLowerCase() === currentPath) {
                        score -= 30;
                    }

                    tokens.forEach(function (token) {
                        if (searchable.includes(String(token).toLowerCase())) {
                            score += 10;
                            matched.push(token);
                        }
                    });

                    if (searchable.includes('入门') || searchable.includes('基础') || searchable.includes('第一')) {
                        score += 2;
                    }

                    return {
                        item: item,
                        score: score,
                        matchedTokens: matched
                    };
                }).sort(function (left, right) {
                    if (right.score !== left.score) return right.score - left.score;
                    if (left.item.order !== right.item.order) return left.item.order - right.item.order;
                    return left.item.title.localeCompare(right.item.title, 'zh-Hans-CN');
                });

                const selected = [];
                const selectedPaths = new Set();

                function tryPush(entry) {
                    if (!entry || !entry.item) return;
                    const key = entry.item.path;
                    if (selectedPaths.has(key)) return;
                    selected.push(entry);
                    selectedPaths.add(key);
                }

                scored.forEach(function (entry) {
                    if (selected.length >= 6) return;
                    if (entry.score > 0) {
                        tryPush(entry);
                    }
                });

                if (selected.length < 4 && currentCategory) {
                    scored.forEach(function (entry) {
                        if (selected.length >= 6) return;
                        if (entry.item.category === currentCategory) {
                            tryPush(entry);
                        }
                    });
                }

                if (selected.length < 4) {
                    scored.forEach(function (entry) {
                        if (selected.length >= 6) return;
                        tryPush(entry);
                    });
                }

                const lines = [];
                lines.push('> AI 生成内容可能不准确，请以教程原文为准。');
                lines.push('');
                lines.push('## 推荐阅读路线（本地推荐）');
                if (tokens.length > 0) {
                    lines.push(`关键词匹配：${tokens.join('、')}`);
                } else {
                    lines.push('未识别到明确关键词，已按当前文章和教程顺序推荐。');
                }
                lines.push('');

                selected.forEach(function (entry, index) {
                    const item = entry.item;
                    let reason = '';

                    if (entry.matchedTokens.length > 0) {
                        reason = `匹配关键词：${entry.matchedTokens.slice(0, 3).join('、')}`;
                    } else if (currentCategory && item.category === currentCategory) {
                        reason = `与当前文章同属分类：${item.category}`;
                    } else if (item.description) {
                        reason = item.description;
                    } else {
                        reason = `教程分类：${item.category}`;
                    }

                    lines.push(`${index + 1}. [${item.title}](${item.href}) - ${reason}`);
                });

                lines.push('');
                lines.push('说明：以上为本地目录推荐，不会调用 AI 接口。');
                return lines.join('\n');
            }

            function buildAiSystemPrompt(userPrompt) {
                const article = getCurrentArticleContextForAi(2600);
                const promptText = String(userPrompt || '').trim();

                return [
                    '你是 tModLoader 教程页面内的 AI 助手。',
                    '第一行必须原样输出：> AI 生成内容可能不准确，请以教程原文为准。',
                    '严格要求：',
                    '1. 只基于当前文章内容回答简单问题，不得编造事实。',
                    '2. 回答先给结论，再给 2-5 条简短步骤。',
                    '3. 不要输出长篇阅读索引；当用户要阅读路线时，由前端本地推荐处理。',
                    '4. 信息不足时，请明确写“我不确定”，并提醒以教程原文为准。',
                    '',
                    `当前文章标题: ${article.title}`,
                    `当前文章路径: ${article.path}`,
                    `当前文章内容摘录:\n${article.text}`,
                    '',
                    `用户问题: ${promptText}`
                ].join('\n');
            }

            function shouldUseIndexSuggestionMode(prompt) {
                const text = String(prompt || '').trim().toLowerCase();
                if (!text) return false;
                return text.includes('索引')
                    || text.includes('目录')
                    || text.includes('文章推荐')
                    || text.includes('阅读建议')
                    || text.includes('从哪开始')
                    || text.includes('教程路线')
                    || text.includes('学习路线')
                    || text.includes('先学什么')
                    || text.includes('推荐我读');
            }

            function formatCooldownSeconds(totalSeconds) {
                const seconds = Math.max(0, Math.ceil(Number(totalSeconds || 0)));
                const mm = String(Math.floor(seconds / 60)).padStart(2, '0');
                const ss = String(seconds % 60).padStart(2, '0');
                return `${mm}:${ss}`;
            }

            function getAiCooldownRemainingSeconds() {
                const diff = Number(state.aiCooldownUntil || 0) - Date.now();
                return Math.max(0, Math.ceil(diff / 1000));
            }

            function persistAiCooldown() {
                try {
                    if (state.aiCooldownUntil > Date.now()) {
                        localStorage.setItem(VIEWER_AI_COOLDOWN_STORAGE_KEY, String(state.aiCooldownUntil));
                    } else {
                        localStorage.removeItem(VIEWER_AI_COOLDOWN_STORAGE_KEY);
                    }
                } catch (_) {
                    // ignore local storage failures
                }
            }

            function stopAiCooldownTimer() {
                if (!cooldownTimer) return;
                clearInterval(cooldownTimer);
                cooldownTimer = 0;
            }

            function setAiSendBusy(isBusy) {
                state.aiBusy = !!isBusy;
                if (!dom.send) return;
                dom.send.textContent = isBusy ? '发送中...' : '发送 AI 对话';
                if (!isBusy) {
                    updateAiCooldownUi();
                    return;
                }
                dom.send.disabled = true;
            }

            function updateAiCooldownUi() {
                const remaining = getAiCooldownRemainingSeconds();
                const hasCooldown = remaining > 0;
                const isLoggedIn = !!state.authToken;

                if (dom.cooldown) {
                    dom.cooldown.textContent = hasCooldown ? `冷却中 ${formatCooldownSeconds(remaining)}` : '可发送';
                    dom.cooldown.style.color = hasCooldown ? 'var(--text-secondary)' : 'var(--text-color)';
                }

                if (dom.send && !state.aiBusy) {
                    dom.send.disabled = !isLoggedIn || hasCooldown;
                }

                if (!hasCooldown) {
                    stopAiCooldownTimer();
                    state.aiCooldownUntil = 0;
                }

                persistAiCooldown();
            }

            function startAiCooldown(seconds) {
                const ttl = Math.max(1, Math.ceil(Number(seconds || 0)));
                state.aiCooldownUntil = Date.now() + ttl * 1000;
                persistAiCooldown();
                stopAiCooldownTimer();
                updateAiCooldownUi();

                cooldownTimer = setInterval(function () {
                    updateAiCooldownUi();
                }, 1000);
            }

            function restoreAiCooldownFromStorage() {
                try {
                    const saved = Number(localStorage.getItem(VIEWER_AI_COOLDOWN_STORAGE_KEY) || 0);
                    if (saved > Date.now()) {
                        state.aiCooldownUntil = saved;
                        updateAiCooldownUi();
                        cooldownTimer = setInterval(function () {
                            updateAiCooldownUi();
                        }, 1000);
                        return;
                    }
                } catch (_) {
                    // ignore local storage failures
                }

                state.aiCooldownUntil = 0;
                updateAiCooldownUi();
            }

            function loadAuthSession() {
                try {
                    state.authToken = String(sessionStorage.getItem(VIEWER_AUTH_TOKEN_KEY) || '').trim();
                    state.githubUser = String(sessionStorage.getItem(VIEWER_AUTH_USER_KEY) || '').trim();
                } catch (_) {
                    state.authToken = '';
                    state.githubUser = '';
                }
            }

            function persistAuthSession() {
                try {
                    if (state.authToken) {
                        sessionStorage.setItem(VIEWER_AUTH_TOKEN_KEY, state.authToken);
                    } else {
                        sessionStorage.removeItem(VIEWER_AUTH_TOKEN_KEY);
                    }

                    if (state.githubUser) {
                        sessionStorage.setItem(VIEWER_AUTH_USER_KEY, state.githubUser);
                    } else {
                        sessionStorage.removeItem(VIEWER_AUTH_USER_KEY);
                    }
                } catch (_) {
                    // ignore session storage failures
                }
            }

            function clearAuthSession() {
                state.authToken = '';
                state.githubUser = '';
                persistAuthSession();
            }

            function updateAuthUi() {
                const isLoggedIn = !!state.authToken;
                const userText = state.githubUser ? `@${state.githubUser}` : '已登录';

                if (dom.authStatus) {
                    dom.authStatus.textContent = isLoggedIn ? userText : '未登录';
                    dom.authStatus.style.color = isLoggedIn ? 'var(--text-color)' : 'var(--text-secondary)';
                }

                if (dom.login) {
                    dom.login.textContent = isLoggedIn ? '切换 GitHub 账号' : 'GitHub 登录';
                }

                if (dom.logout) {
                    dom.logout.disabled = !isLoggedIn;
                }

                updateAiCooldownUi();
            }

            function authLoginUrl() {
                try {
                    const loginUrl = new URL('/auth/github/login', VIEWER_AUTH_WORKER_ORIGIN);
                    const returnTo = `${window.location.origin}${window.location.pathname}${window.location.search}`;
                    loginUrl.searchParams.set('return_to', returnTo);
                    return loginUrl.toString();
                } catch (_) {
                    return '';
                }
            }

            function authMeUrl() {
                try {
                    return new URL('/auth/me', VIEWER_AUTH_WORKER_ORIGIN).toString();
                } catch (_) {
                    return '';
                }
            }

            function consumeOauthResultFromHash() {
                const hash = String(window.location.hash || '').replace(/^#/, '');
                if (!hash) return false;

                const hasOauthToken = /(^|&)oauth_token=/.test(hash);
                const hasOauthError = /(^|&)oauth_error=/.test(hash);
                if (!hasOauthToken && !hasOauthError) return false;

                const params = new URLSearchParams(hash);
                const oauthToken = String(params.get('oauth_token') || '').trim();
                const githubUser = String(params.get('github_user') || '').trim();
                const oauthError = String(params.get('oauth_error') || '').trim();

                if (oauthToken) {
                    state.authToken = oauthToken;
                    state.githubUser = githubUser;
                    persistAuthSession();
                    updateAuthUi();
                    setAiOutput(`GitHub 登录成功${githubUser ? `：@${githubUser}` : ''}`);
                } else {
                    clearAuthSession();
                    updateAuthUi();
                    setAiOutput(`GitHub 登录失败：${oauthError || '未知错误'}`);
                }

                const cleanUrl = `${window.location.pathname}${window.location.search}`;
                window.history.replaceState(null, '', cleanUrl);
                return true;
            }

            async function verifyAuthSession() {
                if (!state.authToken) {
                    updateAuthUi();
                    return;
                }

                const meUrl = authMeUrl();
                if (!meUrl) {
                    clearAuthSession();
                    updateAuthUi();
                    setAiOutput('Worker 地址无效，无法验证 GitHub 登录状态');
                    return;
                }

                try {
                    const response = await fetch(meUrl, {
                        method: 'GET',
                        headers: {
                            'authorization': `Bearer ${state.authToken}`
                        }
                    });

                    const responseText = await response.text();
                    let responseData = null;
                    try {
                        responseData = responseText ? JSON.parse(responseText) : null;
                    } catch (_) {
                        responseData = null;
                    }

                    if (response.status === 401) {
                        clearAuthSession();
                        updateAuthUi();
                        setAiOutput('GitHub 登录已失效，请重新登录');
                        return;
                    }

                    if (!response.ok || !responseData || responseData.ok !== true || !responseData.user) {
                        updateAuthUi();
                        setAiOutput(`验证登录状态失败（HTTP ${response.status}），已保留登录态`);
                        return;
                    }

                    state.githubUser = String(responseData.user || '').trim();
                    persistAuthSession();
                    updateAuthUi();
                } catch (err) {
                    setAiOutput(`验证登录状态失败：${err && err.message ? err.message : String(err)}`);
                }
            }

            async function checkAuthTokenAgainstWorker(authToken) {
                const token = String(authToken || '').trim();
                const meUrl = authMeUrl();

                if (!token || !meUrl) {
                    return {
                        ok: false,
                        status: 0,
                        user: ''
                    };
                }

                try {
                    const response = await fetch(meUrl, {
                        method: 'GET',
                        headers: {
                            'authorization': `Bearer ${token}`
                        }
                    });

                    const responseText = await response.text();
                    let responseData = null;
                    try {
                        responseData = responseText ? JSON.parse(responseText) : null;
                    } catch (_) {
                        responseData = null;
                    }

                    if (!response.ok || !responseData || responseData.ok !== true || !responseData.user) {
                        return {
                            ok: false,
                            status: response.status,
                            user: ''
                        };
                    }

                    return {
                        ok: true,
                        status: response.status,
                        user: String(responseData.user || '').trim()
                    };
                } catch (_) {
                    return {
                        ok: false,
                        status: 0,
                        user: ''
                    };
                }
            }

            function toggleAiPanel(forceOpen) {
                const shouldOpen = typeof forceOpen === 'boolean' ? forceOpen : !!dom.panel.hidden;
                dom.panel.hidden = !shouldOpen;
                dom.fab.setAttribute('aria-expanded', shouldOpen ? 'true' : 'false');
                updatePanelAlignByFabPosition();
                const left = parsePx(dom.root.style.left);
                const top = parsePx(dom.root.style.top);
                if (left != null && top != null) {
                    snapFabToEdge(left, top, false);
                }
                if (shouldOpen && dom.input) {
                    dom.input.focus();
                }
            }

            async function submitViewerAiChat() {
                const apiUrl = normalizeAiApiUrl(dom.endpoint ? dom.endpoint.value : VIEWER_AI_ENDPOINT);
                const authToken = String(state.authToken || '').trim();
                const prompt = String(dom.input ? dom.input.value : '').trim();

                if (!prompt) {
                    setAiOutput('请输入问题后再发送 AI 对话');
                    if (dom.input) dom.input.focus();
                    return;
                }

                const preferIndexSuggestions = shouldUseIndexSuggestionMode(prompt);
                if (preferIndexSuggestions) {
                    setAiOutput(buildLocalIndexRecommendationMarkdown(prompt), { markdown: true });
                    return;
                }

                if (!authToken) {
                    setAiOutput('请先点击“GitHub 登录”后再使用 AI 对话');
                    if (dom.login) dom.login.focus();
                    updateAiCooldownUi();
                    return;
                }

                if (!apiUrl || /REPLACE_WITH_PROJECT_REF\.supabase\.co/i.test(apiUrl)) {
                    setAiOutput('请先把 AI API 地址改成你的 Supabase ai-chat 地址');
                    if (dom.endpoint) dom.endpoint.focus();
                    return;
                }

                const remaining = getAiCooldownRemainingSeconds();
                if (remaining > 0) {
                    setAiOutput(`AI 对话冷却中，请等待 ${formatCooldownSeconds(remaining)}`);
                    updateAiCooldownUi();
                    return;
                }
                if (dom.endpoint) {
                    dom.endpoint.value = apiUrl;
                }
                setAiSendBusy(true);
                setAiOutput('AI 正在思考，请稍候...');

                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'content-type': 'application/json',
                            'authorization': `Bearer ${authToken}`
                        },
                        body: JSON.stringify({
                            prompt: buildAiSystemPrompt(prompt)
                        })
                    });

                    const responseText = await response.text();
                    let responseData = null;
                    try {
                        responseData = responseText ? JSON.parse(responseText) : null;
                    } catch (_) {
                        responseData = null;
                    }

                    if (response.status === 401) {
                        const authCheck = await checkAuthTokenAgainstWorker(authToken);
                        if (authCheck.ok) {
                            if (authCheck.user) {
                                state.githubUser = authCheck.user;
                                persistAuthSession();
                            }
                            updateAuthUi();
                            throw new Error('AI 服务认证配置不一致：请检查 Supabase 的 PR_AUTH_ME_URL 与 Worker 会话签名配置');
                        }

                        clearAuthSession();
                        updateAuthUi();
                        throw new Error('GitHub 登录已过期，请重新登录');
                    }

                    if (response.status === 429) {
                        const retryAfter = responseData && responseData.retry_after_sec
                            ? Number(responseData.retry_after_sec)
                            : VIEWER_AI_COOLDOWN_SECONDS;
                        startAiCooldown(retryAfter);
                        throw new Error(`请求过于频繁，请等待 ${formatCooldownSeconds(retryAfter)}`);
                    }

                    if (!response.ok) {
                        const errMessage = responseData && responseData.error
                            ? String(responseData.error)
                            : `HTTP ${response.status}`;
                        throw new Error(errMessage);
                    }

                    const outputText = responseData && typeof responseData.text === 'string'
                        ? responseData.text
                        : (responseText || '').trim();

                    if (!outputText) {
                        throw new Error('AI 返回为空，请稍后重试');
                    }

                    setAiOutput(outputText, { markdown: true });
                    startAiCooldown(VIEWER_AI_COOLDOWN_SECONDS);
                } catch (err) {
                    setAiOutput(`请求失败：${err && err.message ? err.message : String(err)}`);
                } finally {
                    setAiSendBusy(false);
                    updateAiCooldownUi();
                }
            }

            function setupEvents() {
                if (dom.fab) {
                    dom.fab.addEventListener('click', function () {
                        if (state.fabDragging) return;
                        toggleAiPanel();
                    });
                }

                if (dom.close) {
                    dom.close.addEventListener('click', function () {
                        toggleAiPanel(false);
                    });
                }

                if (dom.login) {
                    dom.login.addEventListener('click', function () {
                        const loginUrl = authLoginUrl();
                        if (!loginUrl) {
                            setAiOutput('无法生成 GitHub 登录地址，请检查 Worker 配置');
                            return;
                        }
                        window.location.href = loginUrl;
                    });
                }

                if (dom.logout) {
                    dom.logout.addEventListener('click', function () {
                        clearAuthSession();
                        updateAuthUi();
                        setAiOutput('已退出 GitHub 登录状态');
                    });
                }

                if (dom.endpoint) {
                    dom.endpoint.addEventListener('blur', function () {
                        dom.endpoint.value = normalizeAiApiUrl(dom.endpoint.value);
                    });
                }

                if (dom.send) {
                    dom.send.addEventListener('click', submitViewerAiChat);
                }

                if (dom.input) {
                    dom.input.addEventListener('keydown', function (event) {
                        if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') {
                            event.preventDefault();
                            submitViewerAiChat();
                        }
                    });
                }
            }

            if (isStudioEmbedModeEnabled()) {
                dom.root.hidden = true;
                return;
            }

            dom.root.hidden = false;
            setupFabDrag();
            restoreFabPosition();

            window.addEventListener('resize', function () {
                const left = parsePx(dom.root.style.left);
                const top = parsePx(dom.root.style.top);
                if (left != null && top != null) {
                    snapFabToEdge(left, top, false);
                    return;
                }

                setFabDefaultPosition();
            });

            if (dom.endpoint) {
                dom.endpoint.value = normalizeAiApiUrl(VIEWER_AI_ENDPOINT);
            }

            loadAuthSession();
            consumeOauthResultFromHash();
            updateAuthUi();
            restoreAiCooldownFromStorage();
            setupEvents();
            verifyAuthSession();
        })();
    </script>
</body>

</html>
